<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiny</title>
  <subtitle>Stay Hungry, Stay Foolish, Stay Uncomfortable.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spinytech.github.io/"/>
  <updated>2016-12-16T11:18:19.000Z</updated>
  <id>http://spinytech.github.io/</id>
  
  <author>
    <name>Spiny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>View绘制分析笔记之onLayout</title>
    <link href="http://spinytech.github.io/2016/12/15/android_view_on_layout/"/>
    <id>http://spinytech.github.io/2016/12/15/android_view_on_layout/</id>
    <published>2016-12-15T12:00:00.000Z</published>
    <updated>2016-12-16T11:18:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我们了解了View的onMeasure，那么今天我们继续来学习Android View绘制三部曲的第二步，onLayout，布局。  </p>
<h2 id="ViewRootImpl-performLayout"><a href="#ViewRootImpl-performLayout" class="headerlink" title="ViewRootImpl#performLayout"></a>ViewRootImpl#performLayout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">        int desiredWindowHeight) &#123;</span><br><span class="line">    mLayoutRequested = false;</span><br><span class="line">    mScrollMayChange = true;</span><br><span class="line">    mInLayout = true;</span><br><span class="line"></span><br><span class="line">    final View host = mView;</span><br><span class="line">    if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, &quot;Laying out &quot; + host + &quot; to (&quot; +</span><br><span class="line">                host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout = false;</span><br><span class="line">        //此处省略的代码是在layout的过程中，重复的requestLayout，需要做的处理。</span><br><span class="line">        //具体的处理方案是重新measure，layout。</span><br><span class="line">        ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要的作用就是调用了host.layout，并把已经测绘好的宽高传计算成上下左右递过去，host就是decorView。</p>
<h2 id="View-layout"><a href="#View-layout" class="headerlink" title="View#layout"></a>View#layout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">    //根据mPrivateFlags3标记位状态判断，如果需要，则重新measure。</span><br><span class="line">    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int oldL = mLeft;</span><br><span class="line">    int oldT = mTop;</span><br><span class="line">    int oldB = mBottom;</span><br><span class="line">    int oldR = mRight;</span><br><span class="line">    </span><br><span class="line">    //检查是位置有变化，并setFrame</span><br><span class="line">    //setFrame分析见下文</span><br><span class="line">    boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">            </span><br><span class="line">    //如果位置有变化或者PFLAG_LAYOUT_REQUIRED标记位为on，则进行onLayout</span><br><span class="line">    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        //把PFLAG_LAYOUT_REQUIRED标记位置为off</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        </span><br><span class="line">        //进行onLayoutChange回调</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            int numListeners = listenersCopy.size();</span><br><span class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将PFLAG_FORCE_LAYOUT标记置为off，将PFLAG3_IS_LAID_OUT置为on</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-setFrame"><a href="#View-setFrame" class="headerlink" title="View#setFrame"></a>View#setFrame</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">protected boolean setFrame(int left, int top, int right, int bottom) &#123;</span><br><span class="line">    boolean changed = false;</span><br><span class="line"></span><br><span class="line">    if (DBG) &#123;</span><br><span class="line">        Log.d(&quot;View&quot;, this + &quot; View.setFrame(&quot; + left + &quot;,&quot; + top + &quot;,&quot;</span><br><span class="line">                + right + &quot;,&quot; + bottom + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果上下左右任意一项有改动，则继续往下进行，否则直接返回false</span><br><span class="line">    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        changed = true;</span><br><span class="line"></span><br><span class="line">        //记录PFLAG_DRAWN位状态，最后复原的时候需要</span><br><span class="line">        int drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        int oldWidth = mRight - mLeft;</span><br><span class="line">        int oldHeight = mBottom - mTop;</span><br><span class="line">        int newWidth = right - left;</span><br><span class="line">        int newHeight = bottom - top;</span><br><span class="line">        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        //刷新原有布局，invalidate方法将在另一篇文章中详细展开。</span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">        //设置该View的上下左右，也是setFrame的核心功能</span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line">        //PFLAG_HAS_BOUNDS位置为on</span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        //如果尺寸有改变，调用onSizeChange并且调用rebuildOutline</span><br><span class="line">        if (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123;</span><br><span class="line">            // If we are visible, force the DRAWN bit to on so that</span><br><span class="line">            // this invalidate will go through (at least to our parent).</span><br><span class="line">            // This is because someone may have invalidated this view</span><br><span class="line">            // before this call to setFrame came in, thereby clearing</span><br><span class="line">            // the DRAWN bit.</span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            // parent display list may need to be recreated based on a change in the bounds</span><br><span class="line">            // of any child</span><br><span class="line">            invalidateParentCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 把PFLAG_DRAWN设置为原有数值。（invalidate过程中会将其设为off）</span><br><span class="line">        mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">        mBackgroundSizeChanged = true;</span><br><span class="line">        if (mForegroundInfo != null) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //Android无障碍辅助通知</span><br><span class="line">        notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    return changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FrameLayout-onLayout"><a href="#FrameLayout-onLayout" class="headerlink" title="FrameLayout#onLayout"></a>FrameLayout#onLayout</h2><p>如果是View的话，执行完layout方法，那么他已经布局完成，不过如果是ViewGroup，那么它需要对它的子View进行处理。onLayout主要的作用就是调用layoutChildren，对子View进行布局，所以这里着重介绍layoutChildren。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, false /* no force left gravity */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line"></span><br><span class="line">    //计算parent的上下左右</span><br><span class="line">    final int parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    final int parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    final int parentTop = getPaddingTopWithForeground();</span><br><span class="line">    final int parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child = getChildAt(i);</span><br><span class="line">        if (child.getVisibility() != GONE) &#123;</span><br><span class="line">            final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int width = child.getMeasuredWidth();</span><br><span class="line">            final int height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            int childLeft;</span><br><span class="line">            int childTop;</span><br><span class="line"></span><br><span class="line">            int gravity = lp.gravity;</span><br><span class="line">            if (gravity == -1) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取layout默认方向，通常是从左到右，在某些特定语言的情况下是从右到左</span><br><span class="line">            final int layoutDirection = getLayoutDirection();</span><br><span class="line">            //通过刚才的方向值，计算出绝对的横向位置属性</span><br><span class="line">            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            //计算竖向位置属性</span><br><span class="line">            final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            //通过位置属性，计算子View的left和right</span><br><span class="line">            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.RIGHT:</span><br><span class="line">                    if (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Gravity.LEFT:</span><br><span class="line">                default:</span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //通过位置属性，计算子View的top和bottom</span><br><span class="line">            switch (verticalGravity) &#123;</span><br><span class="line">                case Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / 2 +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //调用子View的layout方法</span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="http://ogsbxb571.bkt.clouddn.com/onLayout%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="图为View layout 时序图"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里就介绍完了View绘制的layout方法。比起measure，layout可是简单多了。不过这里还预留了一些坑，没有交代清楚，比如invalidate，还有RenderNode硬件加速等，以后会写一些笔记专门针对这些知识点做梳理。</p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="http://blog.spinytech.com/2016/12/02/android_view_draw_setcontentview/" target="_blank" rel="external">Android 视图及View绘制分析笔记之setContentView</a><br><a href="http://blog.spinytech.com/2016/12/12/android_view_on_measure/" target="_blank" rel="external">View绘制分析笔记之onMeasure</a></p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#112;&#x69;&#110;&#121;&#x2e;&#116;&#x65;&#x63;&#104;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;">&#115;&#112;&#x69;&#110;&#121;&#x2e;&#116;&#x65;&#x63;&#104;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我们了解了View的onMeasure，那么今天我们继续来学习Android View绘制三部曲的第二步，onLayout，布局。  &lt;/p&gt;
&lt;h2 id=&quot;ViewRootImpl-performLayout&quot;&gt;&lt;a href=&quot;#ViewRootImpl-p
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="View绘制" scheme="http://spinytech.github.io/tags/View%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>View绘制分析笔记之onMeasure</title>
    <link href="http://spinytech.github.io/2016/12/12/android_view_on_measure/"/>
    <id>http://spinytech.github.io/2016/12/12/android_view_on_measure/</id>
    <published>2016-12-12T12:00:00.000Z</published>
    <updated>2016-12-15T11:16:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要学习记录一下Android View绘制三部曲的第一步，onMeasure，测量。  </p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>在Activity中，所有的View都是DecorView的子View，然后DecorView又是被ViewRootImpl所控制，当Activity显示的时候，ViewRootImpl的<code>performTranversals</code>方法开始运行，这个方法很长，不过核心的三个流程就是依次调用performMeasure、performLayout、performDraw三个方法，从而完成DecorView的绘制。</p>
<h2 id="ViewRootImpl-performMeasure"><a href="#ViewRootImpl-performMeasure" class="headerlink" title="ViewRootImpl#performMeasure"></a>ViewRootImpl#performMeasure</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接调用了mView的<code>measure</code>方法，参数是两个经过设置的MeasureSpec，接下来我们分析一下MeasureSpec是如何设置的。</p>
<h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><p>这个MeasureSpec不是实际测绘值，而是父View传递给子View的布局要求，MeasureSpec涵盖了对子View大小和模式的要求。其中，三种模式要求分别是：  </p>
<ul>
<li>UNSPECIFIED：对子View无任何要求，想要测绘多少由子View决定。  </li>
<li>EXACTLY：父View已确定了自己确切的大小。子View将在这个边界内测绘自己的宽高。  </li>
<li>AT_MOST：父View对子View没有要求，子View可以达到它想要的大小。  </li>
</ul>
<p>首先这个MeasureSpec是个32位的int值，其中31，32两位代表的是三种模式的要求，分别是00….、01….、11….，<code>makeMeasureSpec</code>方法中，sUseBrokenMakeMeasureSpec默认是false，所以一般执行(size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK)这个语句，这个意思就是说，MeasureSpec的高两位代表的是模式，低30位代表父View的尺寸。<br>下面是对应的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final int MODE_SHIFT = 30;</span><br><span class="line">private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,</span><br><span class="line">                                      @MeasureSpecMode int mode) &#123;</span><br><span class="line">    if (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        return size + mode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-measure"><a href="#View-measure" class="headerlink" title="View#measure"></a>View#measure</h2><p>计算完MeasureSpec，DecorView就该执行<code>measure</code>方法了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    ···</span><br><span class="line">    final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line">    ···</span><br><span class="line">    final boolean needsLayout = specChanged</span><br><span class="line">            &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">    if (forceLayout || needsLayout) &#123;</span><br><span class="line">        ···</span><br><span class="line">        int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);</span><br><span class="line">        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</span><br><span class="line">            // measure ourselves, this should set the measured dimension flag back</span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>measure方法是final的，所以不能重写，不过measure方法最主要的作用就是调用了onMeasure方法，由于DecorView是继承的FrameLayout，所以本篇文章我们主要分析FrameLayout的onMeasure方法。</p>
<h2 id="FrameLayout-onMeasure"><a href="#FrameLayout-onMeasure" class="headerlink" title="FrameLayout#onMeasure"></a>FrameLayout#onMeasure</h2><p>这个onMeasure方法，可能是View绘制中最难理解的了，所以我们逐步分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    //获取子View个数</span><br><span class="line">    int count = getChildCount();</span><br><span class="line">    </span><br><span class="line">    //判断是否是确定宽高的</span><br><span class="line">    //如果宽高都确定，那么boolean为false</span><br><span class="line">    //如果有一个不确定，那么boolean为true</span><br><span class="line">    final boolean measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    int maxHeight = 0;</span><br><span class="line">    int maxWidth = 0;</span><br><span class="line">    int childState = 0;</span><br><span class="line">    </span><br><span class="line">    //遍历所有不为GONE的子View，并加以计算</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child = getChildAt(i);</span><br><span class="line">        if (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            //计算各个子View宽高，包括Margin参数以及padding参数</span><br><span class="line">            //该方法详细分析见下文</span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">            final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            //用按位或的方法合并所有子View的State</span><br><span class="line">            //getMeasuredState方法详细解析在下面</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            //如果宽高有不确定的（即warp_content模式），将子View中宽或高是match_parent的添加到mMatchParentChildren中。</span><br><span class="line">            if (measureMatchParentChildren) &#123;</span><br><span class="line">                if (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算padding</span><br><span class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    // 与最小宽高作比较，二者取较大的</span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    // 与前景图宽高作比较，二者取较大的</span><br><span class="line">    final Drawable drawable = getForeground();</span><br><span class="line">    if (drawable != null) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //计算并保存measured宽高</span><br><span class="line">    //resolveSizeAndState方法分析在下面</span><br><span class="line">    //setMeasuredDimension方法分析在下面</span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                    </span><br><span class="line">    //计算macth_parent的子View的个数</span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    //只有FrameLayout中宽或者高有warp_content属性，</span><br><span class="line">    //并且match_parent的子view个数大于1才会执行下面代码。</span><br><span class="line">    //因为如果宽高都是match_parent的，或者设置好dp数值的，则mMatchParentChildren永远是空的。</span><br><span class="line">    </span><br><span class="line">    //在这里会重新计算传递给子View的MeasureSpec值，并重新测绘子View。</span><br><span class="line">    //关于MeasureSpec值的计算，可以参考下文ViewGroup#getChildMeasureSpec的表格。</span><br><span class="line">    //这里需要注意的是，match_parent行所有的结果均改为：EXACTLY + parentSize</span><br><span class="line">    if (count &gt; 1) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child = mMatchParentChildren.get(i);</span><br><span class="line">            final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int childWidthMeasureSpec;</span><br><span class="line">            if (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                final int width = Math.max(0, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int childHeightMeasureSpec;</span><br><span class="line">            if (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                final int height = Math.max(0, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewGroup-measureChildWithMargins"><a href="#ViewGroup-measureChildWithMargins" class="headerlink" title="ViewGroup#measureChildWithMargins"></a>ViewGroup#measureChildWithMargins</h2><p>该方法作用是测绘子View，在父View的onMeasure中循环调用，达到遍历的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">        int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">        int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">    //获取子View的LayoutParams</span><br><span class="line">    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    </span><br><span class="line">    //计算子View的MeasureSpec</span><br><span class="line">    //getChildMeasureSpec方法分析见下文</span><br><span class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">    //调用子View的measure方法，对子View进行测绘</span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewGroup-getChildMeasureSpec"><a href="#ViewGroup-getChildMeasureSpec" class="headerlink" title="ViewGroup#getChildMeasureSpec"></a>ViewGroup#getChildMeasureSpec</h2><p>此方法通过父View的MeasureSpec值以及LayoutParams的宽高，来生成子View的MeasureSpec值，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">    //计算父View的size和mode</span><br><span class="line">    int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    int specSize = MeasureSpec.getSize(spec);</span><br><span class="line">    </span><br><span class="line">    //计算刨除padding的size</span><br><span class="line">    int size = Math.max(0, specSize - padding);</span><br><span class="line"></span><br><span class="line">    int resultSize = 0;</span><br><span class="line">    int resultMode = 0;</span><br><span class="line"></span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">    // Parent has imposed an exact size on us</span><br><span class="line">    case MeasureSpec.EXACTLY:</span><br><span class="line"></span><br><span class="line">        if (childDimension &gt;= 0) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            // Child wants to be our size. So be it.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">            // bigger than us.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    // Parent has imposed a maximum size on us</span><br><span class="line">    case MeasureSpec.AT_MOST:</span><br><span class="line">        if (childDimension &gt;= 0) &#123;</span><br><span class="line">            // Child wants a specific size... so be it</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            // Child wants to be our size, but our size is not fixed.</span><br><span class="line">            // Constrain child to not be bigger than us.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">            // bigger than us.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    // Parent asked to see how big we want to be</span><br><span class="line">    case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        if (childDimension &gt;= 0) &#123;</span><br><span class="line">            // Child wants a specific size... let him have it</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            // Child wants to be our size... find out how big it should</span><br><span class="line">            // be</span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            // Child wants to determine its own size.... find out how</span><br><span class="line">            // big it should be</span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    //noinspection ResourceType</span><br><span class="line">    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，其实通过一张表格，就能很清楚的解释转换规律  </p>
<table>
<thead>
<tr>
<th>竖列代表LayoutParams的宽或高属性\横行父View传递的Mode</th>
<th>EXACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>精确值</td>
<td>EXACTLY + childSize</td>
<td>EXACTLY + childSize</td>
<td>EXACTLY + childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY + parentSize</td>
<td>AT_MOST + parentSize</td>
<td>UNSPECIFIED + parentSize</td>
</tr>
<tr>
<td>warp_content</td>
<td>AT_MOST  + parentSize</td>
<td>AT_MOST  + parentSize</td>
<td>UNSPECIFIED + parentSize</td>
</tr>
</tbody>
</table>
<h2 id="View-getMeasuredState"><a href="#View-getMeasuredState" class="headerlink" title="View#getMeasuredState"></a>View#getMeasuredState</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final int getMeasuredState() &#123;</span><br><span class="line">    return (mMeasuredWidth&amp;MEASURED_STATE_MASK)</span><br><span class="line">            | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)</span><br><span class="line">                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法返回一个表达View宽高measure_state值的整数，第8位代表height是否是MEASURED_STATE_TOO_SMALL，第24为代表width是否是MEASURED_STATE_TOO_SMALL的。<br>例如：<br>宽是MEASURED_STATE_TOO_SMALL的<br>返回:0000 0001 0000 0000 0000 0000 0000 0000<br>高是MEASURED_STATE_TOO_SMALL的<br>返回:0000 0000 0000 0000 0000 0001 0000 0000<br>宽高均是MEASURED_STATE_TOO_SMALL的<br>返回:0000 0001 0000 0000 0000 0001 0000 0000  </p>
<h2 id="View-resolveSizeAndState"><a href="#View-resolveSizeAndState" class="headerlink" title="View#resolveSizeAndState"></a>View#resolveSizeAndState</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static final int MEASURED_STATE_TOO_SMALL = 0x01000000;</span><br><span class="line">public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123;</span><br><span class="line">    //计算父view传递的size和mode</span><br><span class="line">    final int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    final int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    final int result;</span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (specSize &lt; size) &#123;</span><br><span class="line">                //如果父View给的size小于自身测绘出的size，</span><br><span class="line">                //则在第24位上加上measure_state标记。</span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        default:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果child在第24为上有measure_state标记，则在result的第24位上也加上measure_state标记，然后返回result。</span><br><span class="line">    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-setMeasuredDimension"><a href="#View-setMeasuredDimension" class="headerlink" title="View#setMeasuredDimension"></a>View#setMeasuredDimension</h2><p>该方法将计算好的measuredWidth和measuredHeight设置给成员变量mMeasuredWidth及mMeasuredHeight，并且将flag设置成PFLAG_MEASURED_DIMENSION_SET。<br>在4.3版本以上，如果设置了optical模式，则还要对width、height进一步修改，然后再设置mMeasuredWidth、mMeasuredHeight。<br>mMeasuredWidth和mMeasuredHeight的值，不光包括size，同时还包括state，具体请看<code>getMeasuredWidth</code>、<code>getMeasuredWidthAndState</code>、<code>getMeasuredHeight</code>、<code>getMeasuredHeightAndState</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    boolean optical = isLayoutModeOptical(this);</span><br><span class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        int opticalWidth  = insets.left + insets.right;</span><br><span class="line">        int opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="http://ogsbxb571.bkt.clouddn.com/onMeasure%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="图为onMeasure时序图"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，关于View的测绘我们大概的走了一遍。Measure的原理就是通过遍历，从上至下，利用传递的MeasureSpec以及子View的LayoutParams，依次进行测绘。不同的layout可能会进行多次的measure，所以熟读源码，合理布局，可以帮我们避免不必要的measure开销，达到提升性能的效果。  </p>
<p>最后，感谢阅读，也希望可以和大家多多交流，共同进步。</p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#115;&#x70;&#x69;&#110;&#121;&#x2e;&#116;&#x65;&#99;&#x68;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;">&#115;&#x70;&#x69;&#110;&#121;&#x2e;&#116;&#x65;&#99;&#x68;&#x40;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要学习记录一下Android View绘制三部曲的第一步，onMeasure，测量。  &lt;/p&gt;
&lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;在Activity中，所有的V
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="View绘制" scheme="http://spinytech.github.io/tags/View%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android 视图及View绘制分析笔记之setContentView</title>
    <link href="http://spinytech.github.io/2016/12/02/android_view_draw_setcontentview/"/>
    <id>http://spinytech.github.io/2016/12/02/android_view_draw_setcontentview/</id>
    <published>2016-12-02T12:00:00.000Z</published>
    <updated>2016-12-06T12:18:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从1983年第一台图形用户界面的个人电脑问世以来，几乎所有的PC操作系统都支持可视化操作，Android也不例外。对于所有Android Developer来说，我们接触最多的控件就是View。通常，我们使用自定义View，需要了解最多的除了事件分发，就是View的绘制过程。然而关于View的绘制，涉及到的知识点纷繁复杂，这么多的代码知识，要梳理起来，肯定是先要找个头。那么平常我们用的最多的方法是哪个方法呢？当然是<code>setContentView()</code>！</p>
<h1 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h1><p>首先我们直接在Android Studio中找到一个Activity（请注意，本文分析的是Activity，如果你看的是AppCompatActivity，实际代码会有出入），然后找到setContent方法然后点进去，我们可以看到  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后查找<code>getWindow()</code>方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Window mWindow;</span><br><span class="line">public Window getWindow() &#123;</span><br><span class="line">    return mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得知调用的是Window类的setContent()方法。然后再全类搜索mWindow，在attach方法中找到了赋值语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, int ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window) &#123;</span><br><span class="line">    ···</span><br><span class="line">    mWindow = new PhoneWindow(this, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    if (info.uiOptions != 0) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就引出了我们今天主要分析的对象PhoneWindow。 </p>
<h1 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h1><p>查找PhoneWindow的setContentView方法，可以看到有三个重载方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        final Scene newScene = new Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个方法大体的处理流程是：  </p>
<ol>
<li>初始化DecorView  </li>
<li>检查并处理转场动画  </li>
<li>将实际要显示的Layout或者View添加到mContentParent中  </li>
<li>通知Callback(即Activity)调用onContentChanged方法  </li>
</ol>
<h1 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h1><p>在上面的流程里面，相对比较重要的就是第一步的初始化DecorView，也就是<code>installDecor()</code>方法，下面我们继续分析这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">    ···</span><br><span class="line">    if (mDecor == null) &#123;</span><br><span class="line">        mDecor = generateDecor(-1);</span><br><span class="line">        ···</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mDecor.setWindow(this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>installDecor()</code>方法里，主要做的就是两件事，一个是generateDecor，生成mDecor，还有一个是generateLayout，生成mContentParent。generateDecor中，没有太多复杂逻辑，就是做一些判断，然后实例化出来一个DecorView，这里需要说一点的就是在Android7.0以前，DecorView是PhoneWindow的内部类，7.0以后，DecorView单独提出来变成了一个类，所以如果有用到反射的话，这里可能会出现问题，需要做好版本判断。然后我们看下generateLayout的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">    //通过系统获取样式</span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    //然后一系列的判断，获取样式里的属性，然后设置features</span><br><span class="line">    //例如是否悬浮，是否有Title等等</span><br><span class="line">    ···</span><br><span class="line">    int layoutResource;</span><br><span class="line">    int features = getLocalFeatures();</span><br><span class="line">    //拿到刚才设置的features，作出一系列if eles判断，找出对应的resourceId</span><br><span class="line">    //然后调用DecorView的onResourcesLoaded，对这个layout进行inflate</span><br><span class="line">    ···</span><br><span class="line">    mDecor.startChanging();</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    //通过com.android.internal.R.id.content找到对应的mContentParent</span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    if (contentParent == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //在经过一系列后续设置</span><br><span class="line">    ···</span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line">    //最后返回contentParent</span><br><span class="line">    return contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在generateLayout中，大概的流程是这样的。  </p>
<ol>
<li>先获取样式  </li>
<li>设置样式到Window的features里  </li>
<li>拿到features，判断对应的resourceId  </li>
<li>通过resourceId，inflate出来一个ViewGroup，添加到mDecor中</li>
<li>再通过findViewById，找到刚刚inflate的ViewGroup中的  com.android.internal.R.id.content，作为mContentParent</li>
<li>在经过一系列设置  </li>
<li>返回contentParent  </li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此，我们的setContentView就已经基本走完了，剩下的就等着Activity、WindowManager、WindowManagerGlobal、ViewRootImpl去调用了，这些类的调用，涉及到了Activity的启动流程，我们会在其他笔记中详细分析这一过程。  </p>
<p>下面会上一张整个setContentView的时序图，用来巩固一下刚才的流程。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/setContent%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="上图为Android setContentView的时序图"></p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#115;&#112;&#x69;&#x6e;&#x79;&#46;&#x74;&#x65;&#x63;&#x68;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#115;&#112;&#x69;&#x6e;&#x79;&#46;&#x74;&#x65;&#x63;&#x68;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从1983年第一台图形用户界面的个人电脑问世以来，几乎所有的PC操作系统都支持可视化操作，Android也不例外。对于所有Android Developer来说，我们接触最多的控件就是View。通常，我们使用自定义View，需要了解最多的除了事件分发，就是View的绘制过
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="View绘制" scheme="http://spinytech.github.io/tags/View%E7%BB%98%E5%88%B6/"/>
    
      <category term="Android视图" scheme="http://spinytech.github.io/tags/Android%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程注意事项</title>
    <link href="http://spinytech.github.io/2016/11/20/android_multiple_process_notice/"/>
    <id>http://spinytech.github.io/2016/11/20/android_multiple_process_notice/</id>
    <published>2016-11-20T12:00:00.000Z</published>
    <updated>2016-11-24T10:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/" target="_blank" rel="external">《Android多进程使用场景》</a>中，我们分析了一下多进程的使用场景，今天这篇文章，我们来聊聊Android多进程开发过程中可能会遇到的问题。</p>
<h3 id="多虚拟机潜在的问题"><a href="#多虚拟机潜在的问题" class="headerlink" title="多虚拟机潜在的问题"></a>多虚拟机潜在的问题</h3><p>由于每个进程创建以后，都会拥有独立的空间，独立的VM，所以，很多Java特性都会在多进程开发中失效。</p>
<h4 id="1-静态变量和单例模式完全失效"><a href="#1-静态变量和单例模式完全失效" class="headerlink" title="1.静态变量和单例模式完全失效"></a>1.静态变量和单例模式完全失效</h4><p>因为进程间，内存空间是相互独立的，所以VM方法区内的静态变量也都是相互独立的。因为单利模式是基于静态变量的，所以单例也会失效。在两个不同进程访问一个相同类的静态变量，所得的值未必相同，所以在开发中请避免此类代码。</p>
<h4 id="2-线程同步机制完全失效"><a href="#2-线程同步机制完全失效" class="headerlink" title="2.线程同步机制完全失效"></a>2.线程同步机制完全失效</h4><p>由于Java的同步机制是VM来进行调度的，两个进程拥有两个不同的VM，所以，同步也会在多进程开发中失效。synchronized关键字、voliate关键字等都是基于VM级别的同步，所以请不要跨进程去使用线程同步。比如主进程有个生产者，子进程的消费者是无法正常使用消费功能的，只能通过跨进程通信，让主进程的消费者去消费，然后再回调。</p>
<h3 id="Application会多次创建"><a href="#Application会多次创建" class="headerlink" title="Application会多次创建"></a>Application会多次创建</h3><p>每个新进程在创建的时候，都会新建一个Application，所以多进程还会面临着Application多次创建的问题，<code>onCreate</code>方法会多次被调用。解决的办法其实也不是很麻烦，因为Application会多次创建，所以我们可以根据进程名来区分不同的进程，进行不同的初始化，同时，不要在Application中设置过多的静态变量，导致内存增加。</p>
<h3 id="文件读写潜在的问题"><a href="#文件读写潜在的问题" class="headerlink" title="文件读写潜在的问题"></a>文件读写潜在的问题</h3><p>这里的文件指的泛指所有需要并发访问的文件，例如：本地文件，数据库文件，sharepreference等。由于Java中，文件锁、队列机制都是VM级别的，所以不同进程访问同一个文件锁是不管用的。（通过C++可以实现多进程文件锁机制，不过不在文本讨论范围内。）所以在实际开发过程中，还是避免多进程同时访问统一文件，多利用Android中IPC的C/S思想，提供服务，接口调用，避免直接去访问对方进程的文件或者数据库，提升设计美感，同时也能提升代码的稳定性。</p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x73;&#x70;&#x69;&#x6e;&#x79;&#x2e;&#116;&#x65;&#x63;&#x68;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;">&#x73;&#x70;&#x69;&#x6e;&#x79;&#x2e;&#116;&#x65;&#x63;&#x68;&#64;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#x63;&#111;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章&lt;a href=&quot;http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Android多进程使用场
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="多进程" scheme="http://spinytech.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程使用场景</title>
    <link href="http://spinytech.github.io/2016/11/17/android_multiple_process_usage_scenario/"/>
    <id>http://spinytech.github.io/2016/11/17/android_multiple_process_usage_scenario/</id>
    <published>2016-11-17T12:00:00.000Z</published>
    <updated>2016-12-12T10:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="http://blog.spinytech.com/2016/11/15/android_multiple_process/" target="_blank" rel="external">《Android多进程介绍》</a>中，我们大概了解了一下Android中的进程的概念以及其生命周期，另外还有Low Memory Killer相关知识。了解完原理，就该进行实践了。今天这篇文章，我们就来聊一聊，到底如何利用多进程开发，使我们的应用更稳定、用户体验更好？换言之就是Android开发中多进程开发的使用场景分析。  </p>
<font color="blue" size="3">*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</font>  



<h2 id="什么情况需要使用多进程"><a href="#什么情况需要使用多进程" class="headerlink" title="什么情况需要使用多进程"></a>什么情况需要使用多进程</h2><h3 id="常驻后台任务应用"><a href="#常驻后台任务应用" class="headerlink" title="常驻后台任务应用"></a>常驻后台任务应用</h3><p>类似音乐类、跑步健身类、手机管家类等长时间需要在后台运行的应用。这些应用的特点就是，当用户切到别的应用，或者关掉手机屏幕的时候，应用本身的核心模块还在正常运行，提供服务。如果因为手机内存过低，或者是进程重要性降低，导致应用被杀掉，后台服务停止，对于这些应用来说，就是灭顶之灾。合理利用多进程，将核心后台服务模块和其他UI模块进行分离，保证应用能更稳定的提供服务，从而提升用户体验。</p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>现在要做一款音乐播放器，现在有以下几种方案：<br>A. 在Activity中直接播放音乐。<br>B. 启动后台Service，播放音乐。<br>C. 启动前台Service，播放音乐。<br>D. 在新的进程中，启动后台Service，播放音乐。<br>E. 在新的进程中，启动前台Service，播放音乐。  </p>
<h4 id="首先我们分析A"><a href="#首先我们分析A" class="headerlink" title="首先我们分析A"></a>首先我们分析A</h4><p>在A中，我们的播放器是直接在activity中启动的。首先这么做肯定是不对的，我们需要在后台播放音乐，所以当activity退出后就播不了了，之所以给出这个例子是为了控制变量作对比。<br>然后我们来看下A的使用场景。<br>音乐播放器无非是打开app，选歌，播放，退到桌面，切其他应用。我们选取了三个场景，打开、按home切换其他应用、按back退回桌面。让我们看一下A的相对应的oom_adj、oom_score、oom_score_adj的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>当我们应用在前台的时候，无论adj还是score还是score_adj，他们的值都非常的小，基本不会被LMK所杀掉，但是当我们按了Home之后，进程的adj就会急剧增大，变为7，相应的score和score_adj也会增大。在上篇文章中我们得知，adj=7即为被切换的进程，两个进程来回切换，上一个进程就会被设为7。当我们按Back键的时候，adj就会被设为9，也就是缓存进程，优先级比较低，有很大的几率被杀掉。  </p>
<h4 id="接着我们分析B"><a href="#接着我们分析B" class="headerlink" title="接着我们分析B"></a>接着我们分析B</h4><p>B是直接启动一个后台service并且播放音乐，这个处理看起来比A好了很多，那么实际上，B的各个场景的优先级和A又有什么不同呢？让我们来看下B的对应的打开、切换、退出相应的adj、score、score_adj的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>B的情况其实是与A类似的，三种状态的adj、score_adj的值都是一样的，只有score有一点出入，其实分析源码得知，LMK杀进程的时候，score的左右其实并不大，所以我们暂时忽略它。所以，与A相比，他们的adj和score_adj的值都相同，如果遇到内存不足的情况下，这两个应用谁占得内存更大，谁就会被杀掉。不过鉴于A实在activity中播放音乐，所以B还是比A略好的方案。  </p>
<p>这里有朋友肯定要问了，为什么切到后台后，adj的值是7而不是5，后台不是还有service在跑吗？<br>我们通过查看源码可以找出来，当切换Home的时候，会调用<code>ActivityStack.java</code>的<code>finishCurrentActivityLocked</code>函数，然后调用到了<code>ActivityManagerService.java</code>的<code>computeOomAdjLocked</code>函数，在这里，对进程的ADJ值进行重新计算。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0) &#123;</span><br><span class="line">    if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">        schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;previous&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程为PreviousProcess情况，则ADJ=7。<br>具体的计算流程请看这里<a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="external">computeOomAdjLocked计算流程</a>  </p>
<h4 id="接下来分析C"><a href="#接下来分析C" class="headerlink" title="接下来分析C"></a>接下来分析C</h4><p>C的话是启动一个前台Service来播放音乐。让我们来看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>在前台的时候，和AB是一样的，adj都是0，当切到后台，或者back结束时，C对应的adj就是2，也就是可感知进程。adj=2可以说是很高优先级了，非root手机，非系统应用已经没有办法将其杀掉了。具体可参见<a href="https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="external">ActivityManagerService</a>的<code>killBackgroundProcesses</code>方法以及<code>killPackageProcessesLocked</code>方法。adj&lt;5的应用不会被杀掉。<br>总的来说，C方案比B优秀，拥有前台Service的C更不容易被系统或者其他应用所杀掉了，进程的优先级一下子提高到了2，相对于B来说更稳定，用户体验更好。不过有一点不足是必须启动一个前台service。不过现在大部分的音乐类软件都会提供一个前台service，也就不是什么缺点了。其实也是有灰色方法可以启动一个不显示通知的前台service，这里就不过多介绍了。  </p>
<p>那么还有可改进的余地吗？<br>答案当然是肯定的。</p>
<h4 id="让我们来看看D"><a href="#让我们来看看D" class="headerlink" title="让我们来看看D"></a>让我们来看看D</h4><p>终于我们的主角，多进程登场了。<br>D把应用进行了拆分，把用于播放音乐的service放到了新的进程内，让我们看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>上面三张图对应的是D应用主进程的ADJ相关值，我们可以看出来，跟A类似，adj都是0，7，9。由于少了service部分，内存使用变少，最后计算出的oom_score_adj也更低了，意味着主进程部分也更不容易被杀死。  </p>
<p>下面我们看下拆分出的service的相关值  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1.png" alt="上图为后台Service的oom_adj、oom_score、oom_score_adj的值"></p>
<p>因为是service进程，所以不受打开，关闭，切换所影响，这里就放了一张图。<br>我们可以看到，service的adj值一直是5，也就是活跃的服务进程，相比于B来说，优先级高了不少。不过对于C来说，其实这个方案反倒不如C的adj=2的前台进程更稳定。但是D可以自主释放主进程，使D实际所占用的内存很小，从而不容易被杀掉。那么到底C和D谁是更优秀的设计？我个人认为，在ABCDE这5个设计中，D是最具智慧的设计，具体是为什么？先卖个关子，等我们说完了E，再作总结。</p>
<h4 id="那就赶紧分析E吧"><a href="#那就赶紧分析E吧" class="headerlink" title="那就赶紧分析E吧"></a>那就赶紧分析E吧</h4><p>E也是使用了多进程，并且在新进程中，使用了前台service，先来看下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>这个不多解释，和ABD基本差不多，都是0，7，9。我们看下拆分出来的进程的值。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/per-1.png" alt="上图为后台Service的oom_adj、oom_score、oom_score_adj的值"></p>
<p>我们可以看到，这个进程的值是2，像C方案，非常小，非常稳定，而且，我们还可以在系统进入后台后，手动杀掉主进程，使整个应用的内存消耗降到最低，内存低，优先级又高，E获得了今天的最稳定的方案奖。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ABCDE，5种方案都已经分析完了。显然，E是最稳定的方案，不过，我刚才说过，我个人最倾向于D方案，并且认为D是最智慧的方案，这是为什么呢？<br>其实我们可以做个比喻，把整个Android系统比喻成一个旅游景点，Low Memory Killer就是景点的门卫兼保安，然后我们每个进程的ADJ相当于手里的门票，有的人是VIP门票，有的人是普通门票。景点平常没人的时候还好，谁拿票都能进，当人逐渐拥挤的时候，保安就开始根据票的等级，往外轰人。E方案就是一个拿着普通票的妈妈，带着一个VIP的孩子去参观，D方案就是一个拿着普通票的妈妈，带着一个拿着中等票的孩子参观。当内存不够的时候，保安会先把两个妈妈轰出去，孩子们在里面看，再不够了，就会把D孩子给轰出去。这么看来，显然E的效果更好一些，不过由于Android系统对于VIP票的发放没有节制，大家都可以领VIP票，那也就是相当于没有VIP票了。所以如果E方案是一种精明，那么D才是真正的智慧。将调度权还给系统，做好自己，维护好整个Android生态。  </p>
<p>其实现阶段，如果公司要做一个后台类型的应用，我个人也是会选择追逐眼前里利益，采用E方案的，这也是不得已而为之，大家都利用漏洞拿VIP票，你不拿，将来做出来的APP出了偏差，你是要负责任的，所以还是希望Android能把漏洞堵住，把内存分配给真正需要的人，而我们自己也应该遵守规矩，维护整个生态平衡。<br>还有一点，是因为现在部分Root的手机都有优化大师，其实这个优化大师，就好比是个临时工门卫，告诉你他能解决景区爆满问题，实际上他的做法是，把一些票的等级降低，比如把中等票变成赠票，然后给你名正言顺的轰出去，听着是不是很耳熟？“让一部分人先富裕起来，然后把不富裕的杀掉，达成共同富裕。”  </p>
<p>我的测试机之前装了某款优化软件，然后，在正常手机上的adj的值，都有一定程度的降低，来我们上证据。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1-king.png" alt="上图为D方案下，Service进程的oom_adj、oom_score、oom_score_adj的值"></p>
<p>看到没，安装了优化应用之后，本应该adj=5的活跃服务进程，被调整为8，意思是不活跃的服务进程，这种做法本身就违反了最初Android设计的思想。</p>
<p>还有<img src="http://ogsbxb571.bkt.clouddn.com/pem-3-king.png" alt="上图为E方案下，主进程在按了back键退出之后进程的oom_adj、oom_score、oom_score_adj的值"></p>
<p>本来应该adj=9的缓存进程，调整为adj=11。adj=11在Android中都没给出定义。</p>
<p>所以，选择E也是无奈之举。还是呼吁大家要克制吧，维护Android的生态系统是每个工程师的责任。</p>
<p>“喜欢是放肆，但爱是克制” — 阿尔伯特·爱因斯坦 [手动滑稽]</p>
<h3 id="多模块应用"><a href="#多模块应用" class="headerlink" title="多模块应用"></a>多模块应用</h3><p>多进程还有一种非常有用的场景，就是多模块应用。比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。  </p>
<p>首先多进程开发能为应用解决了OOM问题，Android对内存的限制是针对于进程的，这个阈值可以是48M、24M、16M等，视机型而定，所以，当我们需要加载大图之类的操作，可以在新的进程中去执行，避免主进程OOM。  </p>
<p>多进程不光解决OOM问题，还能更有效、合理的利用内存。我们可以在适当的时候生成新的进程，在不需要的时候及时杀掉，合理分配，提升用户体验。减少系统被杀掉的风险。  </p>
<p>多进程还能带来一个好处就是，单一进程崩溃并不影响整体应用的使用。例如我在图片浏览进程打开了一个过大的图片，java heap 申请内存失败，但是不影响我主进程的使用，而且，还能通过监控进程，将这个错误上报给系统，告知他在什么机型、环境下、产生了什么样的Bug，提升用户体验。  </p>
<p>再一个好处就是，当我们的应用开发越来越大，模块越来越多，团队规模也越来越大，协作开发也是个很麻烦的事情。项目解耦，模块化，是这阶段的目标。通过模块解耦，开辟新的进程，独立的JVM，来达到数据解耦目的。模块之间互不干预，团队并行开发，责任分工也明确。至于模块化开发与多进程的结合，后续会写一篇专门的文章来研究这个问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于多进程的使用场景今天大概先说这么多。使用多进程开发还是有很多好处的，不过也有不少坑，下一篇文章我就想总结一下<a href="http://blog.spinytech.com/2016/11/20/android_multiple_process_notice/" target="_blank" rel="external">《多进程开发注意事项》</a>。 </p>
<p>最后，多进程不一定适合所有的应用，合理利用分配进程，使程序更加稳定，才是我们追求的目标。  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#115;&#112;&#x69;&#110;&#121;&#x2e;&#116;&#101;&#x63;&#x68;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;">&#115;&#112;&#x69;&#110;&#121;&#x2e;&#116;&#101;&#x63;&#x68;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a></p>
<p>本文相关源码地址：<a href="https://github.com/SpinyTech/MultipleProcess" target="_blank" rel="external">MultipleProcess</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;http://blog.spinytech.com/2016/11/15/android_multiple_process/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Android多进程介绍》&lt;/a&gt;中，我们大概了解了一下
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="架构思考" scheme="http://spinytech.github.io/tags/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/"/>
    
      <category term="多进程" scheme="http://spinytech.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程介绍</title>
    <link href="http://spinytech.github.io/2016/11/15/android_multiple_process/"/>
    <id>http://spinytech.github.io/2016/11/15/android_multiple_process/</id>
    <published>2016-11-15T12:00:00.000Z</published>
    <updated>2016-11-22T02:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中，默认情况下，同一应用的所有组件均运行在同一进程中，且大多数应用都不会改变这一点。不过，单进程开发并不是Android应用的全部，今天我们就来说说Android中的多进程开发以及多进程的使用场景。  </p>
<h2 id="多进程介绍"><a href="#多进程介绍" class="headerlink" title="多进程介绍"></a>多进程介绍</h2><p>本篇文章内容基于<a href="https://developer.android.com/guide/components/processes-and-threads.html#Processes" target="_blank" rel="external">Android Developer官网</a></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>我们都知道Android系统是基于Linux改造而来的，进程系统也是一脉相承，进程，其实就是程序的具体实现。当程序第一次启动，Android会启动一个Linux进程（具体由Zygote fork出来）以及一个主线程，默认的情况下，所有组件都将运行在该进程内。同一个应用由系统分配一个独立的Linux账户，该应用的产生的所有进程，都会是这同一个Linux账户。</p>
<h3 id="使用多进程"><a href="#使用多进程" class="headerlink" title="使用多进程"></a>使用多进程</h3><p>在开发中，我们通常会使用修改清单文件的<code>android:process</code>来达到多进程的目的。<code>activity</code>、<code>service</code>、<code>receiver</code> 和 <code>provider</code>均支持<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。如果<code>android:process</code>的value值以冒号开头的话，那么该进程就是私有进程，如果是以其他字符开头，那么就是公有进程，拥有相同 <font color="#ff0000">ShareUID</font> 的不同应用可以跑在同一进程里，后续我会专门针对公私有进程做个试验。另外，我们还可以通过设置<code>application</code>的<code>android:process</code>属性，来设置所有组件的默认进程。  </p>
<p>至于创建进程的具体源码分析，网上有一篇很详细的文章，在这就不重复造轮子了，有需要的朋友可以前往 <a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="external">理解Android进程创建流程</a></p>
<p>还有一种方法开启进程，是通过JNI，利用C/C++，调用fork()方法来生成子进程，一般开发者会利用这种方法来做一些daemon进程，来实现防杀，保活等效果，不过不是太推荐，这么做，毕竟Android生态系统需要大家维护。</p>
<h3 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h3><p>刚刚聊了一下进程的“生”，作为一个生命周期，是时候该聊聊进程的“死”了。这里再次呼吁一下大家能正视进程的“死”，合理的利用多进程，适当的杀死不必要的进程才是本篇文章所关注的焦点，我们不要把“永生”作为自己的实现目标，Android设备内存就那么大，就像地球一样，大家都永生了，生态系统就会破坏。那么Android系统是如何维护这个生态系统的呢？</p>
<p>其实也是类似于现实生活中的优胜略汰，Android利用<code>重要性层次结构</code>，就是将最重要的保留，杀掉不重要的进程。Android将<code>重要性层次结构</code>分为5个层级，分为了：（以下5级描述节选自<a href="https://developer.android.com/guide/components/processes-and-threads.html#Lifecycle" target="_blank" rel="external">Android进程生命周期</a>）  </p>
<ol>
<li><p>前台进程<br>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：  </p>
<ul>
<li>托管用户正在交互的 <code>Activity</code>（已调用 <code>Activity</code> 的 <code>onResume()</code> 方法）  </li>
<li>托管某个 <code>Service</code>，后者绑定到用户正在交互的 <code>Activity</code></li>
<li>托管正在“前台”运行的 <code>Service</code>（服务已调用 <code>startForeground()</code>）  </li>
<li>托管正执行一个生命周期回调的 <code>Service</code>（<code>onCreate()</code>、<code>onStart()</code> 或 <code>onDestroy()</code>）  </li>
<li><p>托管正执行其 <code>onReceive()</code> 方法的 <code>BroadcastReceiver</code>  </p>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。<br>这就需要依靠系统的资源。  </p>
</li>
</ul>
</li>
<li><p>可见进程<br>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：  </p>
<ul>
<li>托管不在前台、但仍对用户可见的 <code>Activity</code>（已调用其 <code>onPause()</code> 方法）。例如，如果前台 <code>Activity</code> 启动了一个对话框，允许在其后显示上一 <code>Activity</code>，则有可能会发生这种情况。</li>
<li><p>托管绑定到可见（或前台）<code>Activity</code> 的 <code>Service</code>。  </p>
<p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。  </p>
</li>
</ul>
</li>
<li><p>服务进程<br>正在运行已使用 <code>startService()</code> 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。  </p>
</li>
<li><p>后台进程<br>包含目前对用户不可见的 <code>Activity</code> 的进程（已调用 <code>Activity</code> 的 <code>onStop()</code> 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 <code>Activity</code> 的进程最后一个被终止。如果某个 <code>Activity</code> 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 <code>Activity</code> 时，<code>Activity</code> 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 <code>Activity</code>文档。  </p>
</li>
<li><p>空进程<br>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。  </p>
</li>
</ol>
<p>根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 <code>Activity</code>，则会将此进程评定为可见进程，而不是服务进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 <code>Activity</code> 的进程，因此启动长时间运行操作的 <code>Activity</code> 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 <code>Activity</code> 更加持久时尤要如此。例如，正在将图片上传到网站的 <code>Activity</code> 应该启动服务来执行上传，这样一来，即使用户退出 <code>Activity</code>，仍可在后台继续执行上传操作。使用服务可以保证，无论 <code>Activity</code> 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h3 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h3><p>进程按照状态分完重要性之后，就要开始杀进程了。Android的Low Memory Killer基于Linux的OOM机制，在Linux中，内存是以页面(page)为单位，当申请页面分配不足的时候，系统会通过Low Memory Killer来杀掉bad进程，释放内存。Low Memory Killer会根据进程的adj级别以及所占的内存，来决定是否杀掉该进程，adj越大，占用内存越多，进程越容易被杀掉。<br>关于adj的分级，我们可以参考<a href="https://github.com/android/platform_frameworks_base/blob/marshmallow-release/services/core/java/com/android/server/am/ProcessList.java" target="_blank" rel="external">ProcessList.java</a>，这里面的常量定义了ADJ的分级。（7.0以后的adj分级与之前的不太一样(<a href="https://github.com/android/platform_frameworks_base/blob/nougat-release/services/core/java/com/android/server/am/ProcessList.java" target="_blank" rel="external">Processlist.java-Nougat</a>)，这个我们后续可以研究一下具体的改动是什么）  </p>
<h4 id="adj分级："><a href="#adj分级：" class="headerlink" title="adj分级："></a>adj分级：</h4><ul>
<li><p>UNKNOWN_ADJ = 16<br>级别最低级的进程，通常是被缓存的进程，但是系统也不清楚缓存的内容。  </p>
</li>
<li><p>CACHED_APP_MAX_ADJ = 15<br>这是一个只托管不可见的活动的进程，因此可以在没有任何中断的情况下被杀死。  </p>
</li>
<li><p>CACHED_APP_MIN_ADJ = 9<br>缓存进程，没有英文解释。  </p>
</li>
<li><p>SERVICE_B_ADJ = 8<br>不活跃的服务，不想adj=5的服务那么活跃。<br>PS:这里说一句，在root以后，有的系统优化大师，会把所有服务统一调成adj=8这个级别，来达到内存优化的目的，后面我们会说到。</p>
</li>
<li><p>PREVIOUS_APP_ADJ = 7<br>被切换的进程，一般是用户前一个使用的进程。两个应用来回切换，那么前一个应用一般adj设置为7。  </p>
</li>
<li><p>HOME_APP_ADJ = 6<br>与主应用程序有交互的进程。  </p>
</li>
<li><p>SERVICE_ADJ = 5<br>活跃的服务进程。  </p>
</li>
<li><p>HEAVY_WEIGHT_APP_ADJ = 4<br>高权重进程  </p>
</li>
<li><p>BACKUP_APP_ADJ = 3<br>正在备份的进程   </p>
</li>
<li><p>PERCEPTIBLE_APP_ADJ = 2<br>可感知进程（通常是前台Service进程）  </p>
</li>
<li><p>VISIBLE_APP_ADJ = 1<br>可见进程  </p>
</li>
<li><p>FOREGROUND_APP_ADJ = 0<br>前台进程  </p>
</li>
</ul>
<p>剩下的就是adj值为负数的进程，基本上都是系统集成，不在本文的讨论范围内。负数进程是不会被lmk杀掉的。</p>
<h4 id="如何查看进程优先级"><a href="#如何查看进程优先级" class="headerlink" title="如何查看进程优先级"></a>如何查看进程优先级</h4><p>首先通过 adb shell ps 指令查找对应进程的pid<br>然后通过 adb shell cat /proc/${pid}/oom_adj（设备需要root）返回对应进程的adj值。<br>还可以把oom_adj替换成oom_score或者oom_score_adj来查看这两项的数值，当oom_adj相同时，LowMemoryKiller会根据oom_score_adj和RSS内存大小来杀掉对应的进程。</p>
<h4 id="查看设备的内存临界值"><a href="#查看设备的内存临界值" class="headerlink" title="查看设备的内存临界值"></a>查看设备的内存临界值</h4><p>我们可以通过adb shell cat 查看下面两个文件<br>/sys/module/lowmemorykiller/parameters/adj<br>/sys/module/lowmemorykiller/parameters/minfree<br>（这里请注意，这两个文件是只可以写入的，cat之前请先用chmod赋予权限。）  </p>
<p>adj 代表的是oom_score_adj的值，对应的minfree则代表内存临界值。<br>比如我的测试机小米4C测试机对应的值就是：  </p>
<p>adj: 0,58,117,176,529,1000<br>这个值其实是oom_score_adj的值，用这个值*17再除1000四舍五入取整数，就是对应的adj的值，例如第二个值58即为 58*17/1000 = 1，对应的adj也就是1，所以这6个值对应的adj是0，1，2，3，9，15。1000默认就是15  </p>
<p>minfree: 18432,23040,27648,32256,56250,81250<br>这个值是页值，一页等于4KB，换算成MB大概是72，90，108，126，220，318<br>当可用内存小于318MB的时候，系统开始杀adj=15的进程，以此类推。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上，我们大概了解了一下Android进程、多进程、生命周期以及Low Memory Killer的相关知识。至于如何运用到实际开发当中，我们在下一篇文章<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/" target="_blank" rel="external">《Android多进程使用场景》</a>中继续探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android中，默认情况下，同一应用的所有组件均运行在同一进程中，且大多数应用都不会改变这一点。不过，单进程开发并不是Android应用的全部，今天我们就来说说Android中的多进程开发以及多进程的使用场景。  &lt;/p&gt;
&lt;h2 id=&quot;多进程介绍&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="多进程" scheme="http://spinytech.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何恰当的在闪屏页加载繁重的数据和库</title>
    <link href="http://spinytech.github.io/2016/07/25/2016-07-25/"/>
    <id>http://spinytech.github.io/2016/07/25/2016-07-25/</id>
    <published>2016-07-25T03:50:57.000Z</published>
    <updated>2016-07-26T05:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我将为你们展示开发者开启App时，因为加载一些库和数据遇到的初始化非常慢的这种情况。在这种情况下，开发者通常不会在主线程中初始化，因为这样做会使整个App卡住。相反，开发者希望通过后台初始化数据和库，然后在主线程处理初始化结果。</p>
<h2 id="闪屏页-SplashActivity"><a href="#闪屏页-SplashActivity" class="headerlink" title="闪屏页 SplashActivity"></a>闪屏页 SplashActivity</h2><p>首先，如果你已经有了一些需要在自定义Application类中初始化的东西，你可能想着要做一个恰当的闪屏页。这意味着你点击App图标的同时，闪屏页已经完整的显示出来了。通过设置闪屏页Theme的背景图，我们可以轻易实现这个需求。</p>
<p>res/values/styles.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">style</span> <span class="attr">name</span>=<span class="string">"SplashTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.NoActionBar"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/background_splash<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span><br><span class="line">  <span class="attr">android:name</span>=<span class="string">".splash.SplashActivity"</span></span><br><span class="line">  <span class="attr">android:theme</span>=<span class="string">"@style/SplashTheme"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，闪屏页一般是放个logo，所以 <code>@drawable/background_splash</code> 可以写成一个 <code>layer-list</code></p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/holo_blue_dark"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitmap</span></span><br><span class="line">      <span class="attr">android:gravity</span>=<span class="string">"center"</span></span><br><span class="line">      <span class="attr">android:src</span>=<span class="string">"@drawable/ic_hockey_stick"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>顺便说一下，如果你用了矢量的 <code>&lt;vector&gt;</code> 作为 <code>&lt;src&gt;</code> 赋予 <code>&lt;bitmap&gt;</code> ，那么请你注意<a href="http://stackoverflow.com/questions/34831142/how-to-center-vector-drawable-in-layer-list-without-scaling" target="_blank" rel="external">这个bug</a>。<br>坑爹的是，这个bug现在没办法解决，所以在API小于23的时候你只能用PNG来代替矢量图。</p>
<h2 id="初始化数据和库"><a href="#初始化数据和库" class="headerlink" title="初始化数据和库"></a>初始化数据和库</h2><p>现在我们已经可以瞬间打开App了，那么接下来该怎么做？我们应该想办法如何初始化这种加载缓慢的库。<code>Dagger2</code> 和 <code>RxJava</code> 或许对我们有帮助。</p>
<p>如果只是在闪屏页需要这种‘长初始化’库，来加载必要的资源，那么我们可以定义一个 <code>SplashModule</code> ，那么我们就能把所有库的引用都写到这里。可以，这很解耦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@NonNull</span> <span class="meta">@SplashScope</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> SplashLibrary <span class="title">splashLibrary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SplashLibrary(); <span class="comment">// Takes &gt;5 seconds.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们还不能注入 <code>@Inject</code> ，因为这样做会阻塞我们的主线程。我们需要通过RxJava来创建一个观察者 <code>Observable</code> ，用来接收 <code>SplashLibrary</code> 实例，由于我们用了懒加载 <code>Lazy&lt;&gt;</code> ，我们的库仍未初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashModule</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@NonNull</span> <span class="meta">@SplashScope</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Observable&lt;SplashLibrary&gt; <span class="title">observable</span><span class="params">(<span class="keyword">final</span> Lazy&lt;SplashLibrary&gt; library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;SplashLibrary&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Observable&lt;SplashLibrary&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(library.get());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入这个库"><a href="#注入这个库" class="headerlink" title="注入这个库"></a>注入这个库</h2><p>最后，我们要把库 <code>Observable&lt;SplashLibrary&gt;</code> 注入到我们的闪屏页 <code>SplashActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Observable which will emit an item when fully initialized. */</span></span><br><span class="line"><span class="meta">@Inject</span> Observable&lt;SplashLibrary&gt; splashLibraryObservable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Subscription to unsubscribe in onStop(). */</span></span><br><span class="line"><span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  subscription = splashLibraryObservable</span><br><span class="line">      <span class="comment">// Init library on another thread.</span></span><br><span class="line">      .subscribeOn(Schedulers.computation())</span><br><span class="line">      <span class="comment">// Observe result on the main thread.</span></span><br><span class="line">      .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">      .subscribe(<span class="keyword">new</span> Action1&lt;SplashLibrary&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Use the initialized library.</span></span><br><span class="line"></span><br><span class="line">          Intent intent = <span class="keyword">new</span> Intent(activity, MainActivity.class);</span><br><span class="line">          startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿还有一些个小问题等着你：</p>
<ol>
<li>库加载的过程中，可能会抛出异常，我们需要在 <code>onError</code> 方法中去处理它们。</li>
<li>库加载过程中，用户可能会离开此页或旋转屏幕。由于我们在回调函数中引用了 <code>Activity</code> ，所以有可能导致内存泄露。</li>
</ol>
<h2 id="处理加载过程中的异常"><a href="#处理加载过程中的异常" class="headerlink" title="处理加载过程中的异常"></a>处理加载过程中的异常</h2><p>为了处理这个问题，我们可以传一个 <code>Observer</code> 实例给 <code>subscribe()</code> 方法。</p>
<p>很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;SplashLibrary&gt;() &#123;</span><br><span class="line">  <span class="keyword">final</span> String TAG = <span class="string">"Observer&lt;SplashLibrary&gt;"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Library init error!"</span>, e);</span><br><span class="line">    <span class="comment">// Possible UI interaction.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Use the initialized library.</span></span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(activity, MainActivity.class);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="处理内存溢出问题"><a href="#处理内存溢出问题" class="headerlink" title="处理内存溢出问题"></a>处理内存溢出问题</h2><p>在这个例子中，我们不能从 <code>Subscription</code> 中取消订阅，因为对象一旦加载开始，<code>Subscription</code> 就不能释放资源了。这也就是为什么在内存中还存在着已经销毁的Activity对象，它导致了内存泄露。如果我们在Application中加入了严苛模式 <code>StrictMode.enableDefaults();</code> ，我们可以很容易的在 <code>LogCat</code> 中看到看到Log。当我们旋转屏幕，严苛模式显示了Acitivty的实例信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E/StrictMode: class .SplashActivity; instances=2; limit=1</span><br><span class="line">android.os.StrictMode$InstanceCountViolation: class .SplashActivity; instances=2; limit=1</span><br><span class="line">at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)</span><br></pre></td></tr></table></figure>
<p>这就是为什么我们需要在创建的 <code>Observer</code> 中释放Activity的引用了。我们可以创建一个静态类去实现 <code>Observer&lt;SplashActivity&gt;</code> ，在给他传入一个Activity的引用，然后在 <code>onDestroy</code> 中清除引用。这样，我们可以确保没有内存泄漏异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnInitObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">SplashLibrary</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> SplashActivity splashActivity;</span><br><span class="line"></span><br><span class="line">  OnInitObserver(<span class="meta">@NonNull</span> SplashActivity splashActivity) &#123;</span><br><span class="line">    <span class="keyword">this</span>.splashActivity = splashActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    splashActivity = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">  onInitObserver.releaseListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住这几点，我们就能轻松地在闪屏页中加载库、数据，执行网络请求或者做一些其他的繁重的任务。</p>
<p>感谢阅读，获取源码请点<a href="https://github.com/zsavely/FastStartUp" target="_blank" rel="external">这里</a>。</p>
<hr>
<p>原文地址：<a href="http://szagurskii.com/blog/how-to-load-heavy-libraries-on-splash-screen/?utm_source=Android+Weekly&amp;utm_campaign=644e634e1a-Android_Weekly_215&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-644e634e1a-338049121" target="_blank" rel="external">How to Load Heavy Libraries on Splash Screen [the proper way]</a></p>
<p>作者：SAVELII ZAGURSKII</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我将为你们展示开发者开启App时，因为加载一些库和数据遇到的初始化非常慢的这种情况。在这种情况下，开发者通常不会在主线程中初始化，因为这样做会使整个App卡住。相反，开发者希望通过后台初始化数据和库，然后在主线程处理初始化结果。&lt;/p&gt;
&lt;h2 id=&quot;闪屏页
    
    </summary>
    
      <category term="翻译" scheme="http://spinytech.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://spinytech.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxJava" scheme="http://spinytech.github.io/tags/RxJava/"/>
    
      <category term="Dagger2" scheme="http://spinytech.github.io/tags/Dagger2/"/>
    
  </entry>
  
</feed>
