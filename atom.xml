<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiny</title>
  <subtitle>Stay Hungry, Stay Foolish, Stay Uncomfortable.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.spinytech.com/"/>
  <updated>2017-03-03T09:22:44.000Z</updated>
  <id>http://blog.spinytech.com/</id>
  
  <author>
    <name>Spiny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The guide of the ModularizationArchitecture</title>
    <link href="http://blog.spinytech.com/2017/02/03/ma_get_start_en/"/>
    <id>http://blog.spinytech.com/2017/02/03/ma_get_start_en/</id>
    <published>2017-02-03T12:00:00.000Z</published>
    <updated>2017-03-03T09:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red" size="4">Githup Repository：<a href="https://github.com/SpinyTech/ModularizationArchitecture" target="_blank" rel="external">ModularizationArchitecture</a><br>My Homepage：<a href="https://github.com/SpinyTech" target="_blank" rel="external">SpinyTech</a><br>Welcome to add star and follow.</font><br><br><br>ModularizationArchitecture is a routing-based multi-process, component-based architecture on the Android platform: it communicates with different modules and processes by sharing routes without referring to other modules. It is suitable for medium-sized App architecture team collaboration, parallel development, business line decoupling, white-box testing and other scenes.</p>
<h2 id="1-Definition-of-terms"><a href="#1-Definition-of-terms" class="headerlink" title="1. Definition of terms"></a>1. Definition of terms</h2><ul>
<li><code>Main App Module</code>：The main module of the project, which can be run on the mobile.</li>
<li><code>Library Moudule</code>：The library of the project. It is a business module or a functional component of the project.</li>
<li><code>Test App Module</code>：The main module of the project, which can be run on the mobile. It used to test a library module.</li>
<li><code>Action</code>：The specific implementation of Cross-module calls.</li>
<li><code>ActionResult</code>：The result returned by the Action invoke.</li>
<li><code>Provider</code>：Provider is a actions cluster, It make register actions easier.</li>
<li><code>RouterRequest</code>：The request when invoke an action.</li>
<li><code>RouterResponse</code>：The response when an action invoked completed.</li>
<li><code>LocalRouter</code>：The local router.</li>
<li><code>WideRouter</code>：The multiple process wide router.</li>
<li><code>LocalRouterConnectService</code>：The guard service of local router, used to connect with the wide router, perform AIDL cross-process communication.  </li>
</ul>
<h2 id="2-Getting-start"><a href="#2-Getting-start" class="headerlink" title="2. Getting start"></a>2. Getting start</h2><h3 id="2-1-Integration-in-the-project"><a href="#2-1-Integration-in-the-project" class="headerlink" title="2.1 Integration in the project"></a>2.1 Integration in the project</h3><p>First of all, we need to add the following code into the <code>build.gradle</code> of the <strong>Main App Module</strong> and <strong>all Library Moudule</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.spinytech.ma:macore:0.2.1&apos;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Create-a-custom-Application"><a href="#2-2-Create-a-custom-Application" class="headerlink" title="2.2 Create a custom Application"></a>2.2 Create a custom Application</h3><p>Create a custom Application that inherits from the <code>MaApplication</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class CustomApplication extends MaApplication &#123;</span><br><span class="line"></span><br><span class="line">    // Register the local router for multiple processes</span><br><span class="line">, It is described in detail in chapter 2.7.1</span><br><span class="line">    @Override</span><br><span class="line">    public void initializeAllProcessRouter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Register the logic of application, It is described in detail in chapter 2.3</span><br><span class="line">    @Override</span><br><span class="line">    protected void initializeLogic() &#123;</span><br><span class="line">        //The first argument represents the process name, the second indicates the initialization priority, and the third is the Application logic class, which is instantiated by reflection when needed.</span><br><span class="line">        registerApplicationLogic(&quot;com.spinytech.maindemo&quot;,999, MainApplicationLogic.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The value of this methed returned means whether the app is multi-process, if it is a multi-process returns true, otherwise returns false.</span><br><span class="line">    @Override</span><br><span class="line">    public boolean needMultipleProcess() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Please note:<br>The package name in <code>registerApplicationLogic(&quot;com.spinytech.maindemo&quot;, 999, MainApplicationLogic.class)</code> must be passed in constant. Please do not use the <code>context.getPackageName ()</code> method instead, otherwise the multiprocessing can not register the application logic correctly.</strong></p>
<p>Then add the following code to your <code>AndroidManifest.xml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">      ...</span><br><span class="line">      android:name=&quot;xxx.xxx.CustomApplication&quot;</span><br><span class="line">      ...</span><br><span class="line">      &gt;</span><br><span class="line">      ...</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Create-a-custom-ApplicationLogic"><a href="#2-3-Create-a-custom-ApplicationLogic" class="headerlink" title="2.3 Create a custom ApplicationLogic"></a>2.3 Create a custom ApplicationLogic</h3><p>In the <code>initializeLogic</code> method, you need to separate the application logic from the Application.The reason for the separation, because if the introduction of multi-process, Application will be initialized many times. If the application logic has separated, each Application initialization, for different processes, initialization of different logic.  </p>
<p>The lifecycle of <code>ApplicationLogic</code> and <code>Application</code> are the same, they all have <code>onCreate</code>, <code>onTerminate</code>, <code>onLowMemory</code> method and so on.</p>
<p>Create a custom <code>ApplicationLogic</code> that inherits from the <code>BaseApplicationLogic</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CustomApplicationLogic extends BaseApplicationLogic &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        // Register providers. It is described in detail in chapter 2.4</span><br><span class="line">        LocalRouter.getInstance(mApplication).registerProvider(&quot;util&quot;,new UtilProvider());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onTerminate()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onLowMemory()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onTrimMemory(int level)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onConfigurationChanged(Configuration newConfig) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Create-a-custom-provider"><a href="#2-4-Create-a-custom-provider" class="headerlink" title="2.4 Create a custom provider"></a>2.4 Create a custom provider</h3><p><code>Provider</code> data structure is actually a HashMap, its function is to tie multiple Actions together, to facilitate the local router to register.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UtilProvider extends MaProvider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void registerActions() &#123;</span><br><span class="line">        registerAction(&quot;md5&quot;,new MD5EncryptAction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When the <code>Provider</code> is created, then register it to local router. It is usually registered in <code>onCreate</code> in <code>ApplicationLogic</code> (see 2.3). </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalRouter.getInstance(mApplication).registerProvider(&quot;util&quot;,new CustomProvider());</span><br></pre></td></tr></table></figure>
<p>The first parameter “util” is the provider key, it can be customized, It will be used later when we invoke the action.</p>
<h3 id="2-5-Create-a-custom-Action"><a href="#2-5-Create-a-custom-Action" class="headerlink" title="2.5 Create a custom Action"></a>2.5 Create a custom Action</h3><p>Each <code>Action</code> is a concrete implementation that provides to the invoke. We need to inherit and overwirte it.</p>
<p>There are two methods need to be overwriten, one is <code>isAsync()</code>, the other is <code>invoke()</code>.  </p>
<p><code>isAsync()</code> need to tell the caller whether the action is asynchronous. If it is asynchronous(such as network, IO and so on.), then return true, if it is synchronous return false. The reason for adding this judgment is that some action may be called in the main thread, we need to determine whether the action is time-consuming, and thus decide whether to start a new thread to invoke the action.   </p>
<p><code>Invoke ()</code> method is the actual implementation of the call. The method has a context <code>Context</code> and a set of request data<code>HashMap &lt;String, String&gt;</code>, which returns<code>AcationResult</code> as a result back to the caller.  </p>
<p>The data structure of <code>AcationResult</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code:xxx,</span><br><span class="line">    msg:xxx,</span><br><span class="line">    data:xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The implementation of the method is similar to that of a Web application, where a parameter is a set of key-value pairs, and the result is processed after a series of processing.  </p>
<p>Here we give a simple MD5 encryption example, create a custom <code>MD5EncryptAction</code> inherited from<code>MaAction</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MD5EncryptAction extends MaAction &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAsync(Context context, HashMap&lt;String, String&gt; requestData) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MaActionResult invoke(Context context, HashMap&lt;String, String&gt; requestData) &#123;</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        if(!TextUtils.isEmpty(requestData.get(&quot;params_1&quot;)))&#123;</span><br><span class="line">            result +=requestData.get(&quot;params_1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!TextUtils.isEmpty(requestData.get(&quot;params_2&quot;)))&#123;</span><br><span class="line">            result +=requestData.get(&quot;params_2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // The MD5Util is a dummy util, here we do not implement it.</span><br><span class="line">        result = MD5Util.md5(temp);</span><br><span class="line">        </span><br><span class="line">        MaActionResult result = new MaActionResult.Builder()</span><br><span class="line">                .code(MaActionResult.CODE_SUCCESS)</span><br><span class="line">                .msg(&quot;success&quot;)</span><br><span class="line">                .data(result)</span><br><span class="line">                .object(null)</span><br><span class="line">                .build();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When the <code>Action</code> is created, then register it to <code>Provider</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerAction(&quot;md5&quot;,new MD5EncryptAction());</span><br></pre></td></tr></table></figure>
<p>The first parameter “md5” is the action key, it can be customized, It will be used later when we invoke the action.  </p>
<h3 id="2-6-Invoke"><a href="#2-6-Invoke" class="headerlink" title="2.6 Invoke"></a>2.6 Invoke</h3><p>In previous chapters, we have defined everything, and we’ll invoke this chapter.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterResponse response = LocalRouter.getInstance(MaApplication.getMaApplication())</span><br><span class="line">                            .route(context, RouterRequest.obtain(context)</span><br><span class="line">                            .provider(&quot;util&quot;)</span><br><span class="line">                            .action(&quot;md5&quot;)</span><br><span class="line">                            .data(&quot;params_1&quot;, &quot;Hello&quot;)</span><br><span class="line">                            .data(&quot;params_2&quot;, &quot;World&quot;));</span><br></pre></td></tr></table></figure>
<p>First we get the instance of <code>LocalRouter</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalRouter.getInstance(MaApplication.getMaApplication())</span><br></pre></td></tr></table></figure>
<p>Then use <code>route</code> to invoke.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route(Context context,RouterRequest request)</span><br></pre></td></tr></table></figure>
<h3 id="2-6-1-Create-the-RouterRequest"><a href="#2-6-1-Create-the-RouterRequest" class="headerlink" title="2.6.1 Create the RouterRequest"></a>2.6.1 Create the RouterRequest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RouterRequest.obtain(context)</span><br><span class="line">                            .provider(&quot;util&quot;)</span><br><span class="line">                            .action(&quot;md5&quot;)</span><br><span class="line">                            .data(&quot;params_1&quot;, &quot;Hello&quot;)</span><br><span class="line">                            .data(&quot;params_2&quot;, &quot;World&quot;);</span><br></pre></td></tr></table></figure>
<p>This code means that find the registration of the name “util” of the provider, and then find its registered name “md5” action. The two parameters is “params_1”, “params_2”.  </p>
<p>Send the router request to the local router to finish the invoke.</p>
<p><strong>Note: RouterRequest uses the object memory pool technology, will be recycled after use, so do not hold a reference to RouterRequest, in order to avoid unnecessary errors.</strong></p>
<h3 id="2-6-2-Deal-with-RouterResponse"><a href="#2-6-2-Deal-with-RouterResponse" class="headerlink" title="2.6.2 Deal with RouterResponse"></a>2.6.2 Deal with RouterResponse</h3><p>The <code>route()</code> method will return the instance of <code>RouterRequest</code>. This method is nonblocking and returns <code>RouterResponse</code> immediately after invoke. The <code>isAsync()</code> method of <code>RouterResponse</code> tells you whether the call is asynchronous or not. The<code>get()</code>method of<code>RouterResponse</code> returns the result of that call. <strong>Please note that the <code>get()</code> method may cause blocking, depending on <code>isAsync()</code>, so please be careful when you use the <code>get()</code> method in main thread.</strong></p>
<h3 id="2-7-Multiple-process"><a href="#2-7-Multiple-process" class="headerlink" title="2.7 Multiple process"></a>2.7 Multiple process</h3><p>In chapter 2.2, overwirte the <code>needMultipleProcess()</code> method and set the return true.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean needMultipleProcess() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-1-Create-connect-service-register-local-router"><a href="#2-7-1-Create-connect-service-register-local-router" class="headerlink" title="2.7.1 Create connect service, register local router"></a>2.7.1 Create connect service, register local router</h3><p>Because it involves multiple processes, so we need to use AIDL for inter-process communication. Therefore, each process within the app, you need to create a connection Service, used to communicate with the wide router.</p>
<p>Create a custom Service inherited from <code>LocalRouterConnectService</code>, we do not need to write any code.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MainRouterConnectService extends LocalRouterConnectService &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Register the connect service in <code>Androidmanifest.xml</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;xxx.xxx.MainRouterConnectService&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>Then register the connect service in <code>initializeAllProcessRouter()</code> method.<br>The first parameter of <code>WideRouter.registerLocalRouter</code> method is the process name, the second is the class of the connect service. See the following code.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void initializeAllProcessRouter() &#123;</span><br><span class="line">    WideRouter.registerLocalRouter(&quot;com.spinytech.maindemo&quot;,MainRouterConnectService.class);</span><br><span class="line">    WideRouter.registerLocalRouter(&quot;com.spinytech.maindemo:music&quot;,MusicRouterConnectService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-2-Cross-process-invoke"><a href="#2-7-2-Cross-process-invoke" class="headerlink" title="2.7.2 Cross-process invoke"></a>2.7.2 Cross-process invoke</h3><p>Cross-process invoking is similar to the local invoking. But in generating <code>RouterRequest</code> time, we need to add a <code>Domain</code>, <code>Domain</code> is the process name. (When you obtain the <code>RouterRequest</code>, if not add domain, the default domain is the current process name)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RouterRequest</span><br><span class="line">    .obtain(context)</span><br><span class="line">    .domain(&quot;com.spinytech.maindemo:music&quot;)</span><br><span class="line">    .provider(&quot;music&quot;)</span><br><span class="line">    .action(&quot;play&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="2-8-RouterRequest-with-the-attachment-Object-and-RouterResponse-with-the-return-Object-Added-in-v0-2-0"><a href="#2-8-RouterRequest-with-the-attachment-Object-and-RouterResponse-with-the-return-Object-Added-in-v0-2-0" class="headerlink" title="2.8 RouterRequest with the attachment Object and RouterResponse with the return Object (Added in v0.2.0)"></a>2.8 RouterRequest with the attachment Object and RouterResponse with the return Object (Added in v0.2.0)</h3><p>In the v0.2.0 version, we added a function that we can add an attach object into the <code>RouterRequest</code>. (only in a single process).</p>
<p>In <code>RouterRequest</code>, the <code>object(Object attachment)</code> method is added to add the attachment object to the request.  </p>
<p>In the abstract class <code>MaAction</code>, we added two methods  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Public boolean isAsync (context context, HashMap &lt;String, String&gt; requestData, Object object)`  </span><br><span class="line">Public MaActionResult invoke (Context context, HashMap &lt;String, String&gt; requestData, Object object)</span><br></pre></td></tr></table></figure>
<p>By judging whether or not <code>RouterRequest</code> carries the attachment object,<code>LocalRouter</code> will call the different invoke methods.  </p>
<p>Related code:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RouterResponse.mIsAsync = attachment == null? TargetAction.isAsync (context, params): targetAction.isAsync (context, params, attachment);</span><br><span class="line">MaActionResult result = attachment == null? TargetAction.invoke (context, params): targetAction.invoke (context, params, attachment);</span><br></pre></td></tr></table></figure>
<p>When you return the result, you can use the <code>object(Object returnedObject)</code> method in <code>MaActionResult.Builder</code> to return an object instance to the caller, using the <code>getObject()</code> method of <code>RouterResponse</code> to get the returned Object.</p>
<p><strong> Please note: Because the inter-process memory is not shared, all attachments Object can only be passed in the process. The attachment object of the process will be ignored by default, please do not cross the process with the attachment Object call. </strong></p>
<p>For details, please refer to: [AttachObjectAction.java] (<a href="https://github.com/SpinyTech/ModularizationArchitecture/blob/master/maindemo/src/main/java/com/spinytech/maindemo/AttachObjectAction.java" target="_blank" rel="external">https://github.com/SpinyTech/ModularizationArchitecture/blob/master/maindemo/src/main/java/com/spinytech/maindemo/AttachObjectAction.java</a>)</p>
<h2 id="3-Principle"><a href="#3-Principle" class="headerlink" title="3. Principle"></a>3. Principle</h2><p>The principles of this architecture have not yet been translated into English. You can refer to the following article, and use google translate to read. If you have any questions, please email me. </p>
<p><a href="http://blog.spinytech.com/2016/12/28/android_modularization/">《Android架构思考》</a></p>
<h2 id="4-Defect"><a href="#4-Defect" class="headerlink" title="4. Defect"></a>4. Defect</h2><ul>
<li>Calls between two Apks of the same ShareUid are not supported at this time.</li>
<li>Need to inherit from <code>MaApplication</code>, the original <code>Application</code> code may be changed.</li>
</ul>
<h2 id="5-Future-plans"><a href="#5-Future-plans" class="headerlink" title="5. Future plans"></a>5. Future plans</h2><ul>
<li>Add the <code>Action</code> fail switch so that it can be dynamically controlled by the server.  </li>
<li>Add the <code>Action</code> hot fix feature.</li>
<li>Optimize the process of packaging and unpacking in the process of message passing.</li>
<li>Add <code>SocketAction</code> to make the <code>Action</code> can instant messaging.</li>
</ul>
<h2 id="6-Version"><a href="#6-Version" class="headerlink" title="6. Version"></a>6. Version</h2><h3 id="v0-2-1"><a href="#v0-2-1" class="headerlink" title="v0.2.1"></a>v0.2.1</h3><ul>
<li>Fixed the bug that In synchronization method of <code>RouterResponse</code> can not get code, message, data.</li>
</ul>
<h3 id="v0-2-0"><a href="#v0-2-0" class="headerlink" title="v0.2.0"></a>v0.2.0</h3><ul>
<li>Added a new method <code>object(Object attachment)</code> of <code>RouterRequest</code> that make <code>Action</code> can incomming a object parameter.  </li>
<li>The <code>Action</code> can return an attachment object by <code>MaActionResult</code>.  </li>
<li>Fixed some bugs.</li>
<li>New example is added to maindemo.</li>
</ul>
<hr>
<p>Original article, reproduced please contact the author: <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#115;&#x70;&#x69;&#x6e;&#121;&#46;&#x74;&#x65;&#99;&#104;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#115;&#x70;&#x69;&#x6e;&#121;&#46;&#x74;&#x65;&#99;&#104;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;red&quot; size=&quot;4&quot;&gt;Githup Repository：&lt;a href=&quot;https://github.com/SpinyTech/ModularizationArchitecture&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="ModularizationArchitecture" scheme="http://blog.spinytech.com/tags/ModularizationArchitecture/"/>
    
      <category term="Architecture" scheme="http://blog.spinytech.com/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>ModularizationArchitecture 使用教程</title>
    <link href="http://blog.spinytech.com/2017/02/01/ma_get_start_cn/"/>
    <id>http://blog.spinytech.com/2017/02/01/ma_get_start_cn/</id>
    <published>2017-02-01T12:00:00.000Z</published>
    <updated>2017-03-03T09:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><font color="red" size="4">项目地址：<a href="https://github.com/SpinyTech/ModularizationArchitecture" target="_blank" rel="external">ModularizationArchitecture</a><br>个人主页：<a href="https://github.com/SpinyTech" target="_blank" rel="external">SpinyTech</a><br>欢迎各位读者 Star Follow</font><br><br><br>ModularizationArchitecture 是Android平台上一种基于路由的多进程、组件化架构:它通过共有路由，在不引用其他模块的前提下，实现不同模块，不同进程之间的通信。它适合中型App架构的团队协作，并行开发，业务线解耦，白盒测试等场景。  </p>
<h2 id="1-关键词定义"><a href="#1-关键词定义" class="headerlink" title="1. 关键词定义"></a>1. 关键词定义</h2><ul>
<li><code>主App Module</code>：Android studio中的可运行的Module，项目的主Module</li>
<li><code>模块Library Moudule</code>：Android studio中的Library Module，模块化中的单一业务或功能组件</li>
<li><code>测试App Module</code>：Android studio中的可运行的Module，用于测试某一个模块Library的可运行的壳子Module</li>
<li><code>Action</code>：跨模块调用的具体实现</li>
<li><code>ActionResult</code>：Action调用后返回的结果</li>
<li><code>Provider</code>：Action簇，将一组Action放到一起，便于注册</li>
<li><code>RouterRequest</code>：调用Action时的请求信息</li>
<li><code>RouterResponse</code>：Action调用完成之后的响应信息</li>
<li><code>LocalRouter</code>：单进程本地局域路由器</li>
<li><code>WideRouter</code>：多进程广域路由器</li>
<li><code>LocalRouterConnectService</code>：本地路由器Service，用于和广域路由器连接，进行AIDL跨进程通信</li>
</ul>
<h2 id="2-开始使用"><a href="#2-开始使用" class="headerlink" title="2. 开始使用"></a>2. 开始使用</h2><h3 id="2-1-在项目中集成"><a href="#2-1-在项目中集成" class="headerlink" title="2.1 在项目中集成"></a>2.1 在项目中集成</h3><p>首先我们需要在<strong>主App Moudule</strong>和<strong>所有模块Library Moudule</strong>的build.gradle中都需要添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.spinytech.ma:macore:0.2.1&apos;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建自定义Application"><a href="#2-2-创建自定义Application" class="headerlink" title="2.2 创建自定义Application"></a>2.2 创建自定义Application</h3><p>创建自定义的Application继承自<code>MaApplication</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CustomApplication extends MaApplication &#123;</span><br><span class="line"></span><br><span class="line">    // 注册多个进程的本地路由器，在2.7.1中有详细介绍</span><br><span class="line">    @Override</span><br><span class="line">    public void initializeAllProcessRouter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 注册Application逻辑，详见2.3</span><br><span class="line">    @Override</span><br><span class="line">    protected void initializeLogic() &#123;</span><br><span class="line">        //第一个参数表示进程名，第二个表示初始化优先级，第三个是对应的Application逻辑类，在需要的时候会反射初始化</span><br><span class="line">        registerApplicationLogic(&quot;com.spinytech.maindemo&quot;,999, MainApplicationLogic.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 标记该App是否是多进程的，如果是多进程则返回true，否则返回false</span><br><span class="line">    @Override</span><br><span class="line">    public boolean needMultipleProcess() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请注意：<br><code>registerApplicationLogic(&quot;com.spinytech.maindemo&quot;,999, MainApplicationLogic.class)</code>中的包名一定要用常量传入。请不要使用<code>context.getPackageName()</code>方法代替，否则多进程无法正确注册application逻辑。</strong></p>
<p>然后在<code>AndroidManifest.xml</code>中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">      ...</span><br><span class="line">      android:name=&quot;xxx.xxx.CustomApplication&quot;</span><br><span class="line">      ...</span><br><span class="line">      &gt;</span><br><span class="line">      ...</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-创建自定义ApplicationLogic"><a href="#2-3-创建自定义ApplicationLogic" class="headerlink" title="2.3 创建自定义ApplicationLogic"></a>2.3 创建自定义ApplicationLogic</h3><p>在<code>initializeLogic</code>方法中，需要对<code>Application</code>和实际的<code>ApplicationLogic</code>进行分离，之所以分离，是因为如果引入多进程，<code>Application</code>会初始化多次，如果将逻辑分离，则每次<code>Application</code>初始化，会针对不同的进程，初始化不同的逻辑。  </p>
<p><code>ApplicationLogic</code>的生命周期和<code>Application</code>是相同的，都具有<code>onCreate</code>、<code>onTerminate</code>、<code>onLowMemory</code>等。</p>
<p>创建自定义<code>ApplicationLogic</code>继承自<code>BaseApplicationLogic</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CustomApplicationLogic extends BaseApplicationLogic &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        // 注册Provider，详见2.4</span><br><span class="line">        LocalRouter.getInstance(mApplication).registerProvider(&quot;util&quot;,new UtilProvider());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onTerminate()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onLowMemory()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onTrimMemory(int level)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onConfigurationChanged(Configuration newConfig) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-实现Provider"><a href="#2-4-实现Provider" class="headerlink" title="2.4 实现Provider"></a>2.4 实现Provider</h3><p><code>Provider</code>的数据结构实际上就是一个HashMap，它的功能就是将多个<code>Action</code>绑到一起，便于本地局域路由器进行注册。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class UtilProvider extends MaProvider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void registerActions() &#123;</span><br><span class="line">        registerAction(&quot;md5&quot;,new MD5EncryptAction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Provider</code>创建好了之后，就在本地局域路由器中进行注册，通常是在<code>ApplicationLogic</code>的<code>onCreate</code>方法中进行注册(可以参考2.3)。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalRouter.getInstance(mApplication).registerProvider(&quot;util&quot;,new CustomProvider());</span><br></pre></td></tr></table></figure>
<p>第一个参数”util”是provider key，可以自定义，以后在调用的时候需要用到。</p>
<h3 id="2-5-实现Action"><a href="#2-5-实现Action" class="headerlink" title="2.5 实现Action"></a>2.5 实现Action</h3><p>每一个<code>Action</code>都是一个对外提供调用的具体实现。我们需要对其进行继承，重写。</p>
<p><code>Action</code>中有两个方法需要重写，一个是<code>isAsync()</code>，一个是<code>invoke()</code>。  </p>
<p><code>isAsync()</code>需要告诉调用者，该Action是否是耗时异步的，如果是耗时的（比如网络操作、IO操作等），则返回true，如果非耗时的，则返回false。之所以加上这个判断，是因为有一些调用可能是在主线程进行，我们需要判断这个调用是否是耗时的，从而决定是否要新开工作进程进行调用。</p>
<p><code>invoke()</code>方法就是实际调用的实现方法。该方法的入参有上下文<code>Context</code>和一组请求数据<code>HashMap&lt;String,String&gt;</code>，该方法返回<code>AcationResult</code>作为结果返回给调用者。<br><code>AcationResult</code>的数据结构是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    code:xxx,</span><br><span class="line">    msg:xxx,</span><br><span class="line">    data:xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个方法执行过程类似于Web应用，入参是一组key-value键值对，进行一系列处理后，返回处理结果。</p>
<p>下面我们举个简单的MD5加密例子，创建自定义<code>MD5EncryptAction</code>继承自<code>MaAction</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MD5EncryptAction extends MaAction &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAsync(Context context, HashMap&lt;String, String&gt; requestData) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MaActionResult invoke(Context context, HashMap&lt;String, String&gt; requestData) &#123;</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        if(!TextUtils.isEmpty(requestData.get(&quot;params_1&quot;)))&#123;</span><br><span class="line">            result +=requestData.get(&quot;params_1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!TextUtils.isEmpty(requestData.get(&quot;params_2&quot;)))&#123;</span><br><span class="line">            result +=requestData.get(&quot;params_2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // MD5Util为模块下自定义的工具类，这里就省略了。</span><br><span class="line">        result = MD5Util.md5(temp);</span><br><span class="line">        </span><br><span class="line">        MaActionResult result = new MaActionResult.Builder()</span><br><span class="line">                .code(MaActionResult.CODE_SUCCESS)</span><br><span class="line">                .msg(&quot;success&quot;)</span><br><span class="line">                .data(result)</span><br><span class="line">                .object(null)</span><br><span class="line">                .build();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Action</code>创建好后，可以直接在<code>Provider中进行注册</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerAction(&quot;md5&quot;,new MD5EncryptAction());</span><br></pre></td></tr></table></figure>
<p>第一个参数”md5”是action key，可以自定义，以后在调用的时候需要用到。  </p>
<h3 id="2-6-调用"><a href="#2-6-调用" class="headerlink" title="2.6 调用"></a>2.6 调用</h3><p>前面几节，我们已经把一切都定义好了，这节我们就来调用。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterResponse response = LocalRouter.getInstance(MaApplication.getMaApplication())</span><br><span class="line">                            .route(context, RouterRequest.obtain(context)</span><br><span class="line">                            .provider(&quot;util&quot;)</span><br><span class="line">                            .action(&quot;md5&quot;)</span><br><span class="line">                            .data(&quot;params_1&quot;, &quot;Hello&quot;)</span><br><span class="line">                            .data(&quot;params_2&quot;, &quot;World&quot;));</span><br></pre></td></tr></table></figure>
<p>首先通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalRouter.getInstance(MaApplication.getMaApplication())</span><br></pre></td></tr></table></figure>
<p>拿到<code>LocalRouter</code>的实例，然后通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route(Context context,RouterRequest request)</span><br></pre></td></tr></table></figure>
<p>方法进行调用。</p>
<h3 id="2-6-1-创建RouterRequest"><a href="#2-6-1-创建RouterRequest" class="headerlink" title="2.6.1 创建RouterRequest"></a>2.6.1 创建RouterRequest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">RouterRequest.obtain(context)</span><br><span class="line">                            .provider(&quot;util&quot;)</span><br><span class="line">                            .action(&quot;md5&quot;)</span><br><span class="line">                            .data(&quot;params_1&quot;, &quot;Hello&quot;)</span><br><span class="line">                            .data(&quot;params_2&quot;, &quot;World&quot;);</span><br></pre></td></tr></table></figure>
<p>这段代码的意思是，找到注册名为”util”的provider，然后再找到其注册名为”md5”的action。传入两个参数，key分别为”params_1”、”params_2”。</p>
<p>在2.6中的route方法中，将RouterRequest传入进去，即可完成调用。</p>
<p><strong>注意：RouterRequest使用了对象内存池技术，使用过后会被回收，所以请不要持有RouterRequest的引用，以免发生不必要的错误。</strong></p>
<h3 id="2-6-2-处理RouterResponse"><a href="#2-6-2-处理RouterResponse" class="headerlink" title="2.6.2 处理RouterResponse"></a>2.6.2 处理RouterResponse</h3><p>2.6中的<code>route</code>方法会返回<code>RouterResponse</code>实例。该方法是非阻塞方法，每次调用都会立即返回<code>RouterResponse</code>结果。通过<code>RouterResponse</code>的<code>isAsync()</code>方法可以得知该次调用是否是异步的，通过<code>RouterResponse</code>的<code>get()</code>方法可以返回该次调用的结果。<strong>请注意，<code>get()</code>方法有可能会造成阻塞，这取决于<code>isAsync()</code>，所以，请在调用<code>get()</code>方法前进行判断，不要在主线程调用阻塞的<code>get()</code>方法。</strong></p>
<h3 id="2-7-开启多进程模式"><a href="#2-7-开启多进程模式" class="headerlink" title="2.7 开启多进程模式"></a>2.7 开启多进程模式</h3><p>在2.2中，自定义的Application中，重写<code>needMultipleProcess()</code>方法，并将返回值设为true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean needMultipleProcess() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-1-创建连接Service，注册本地路由"><a href="#2-7-1-创建连接Service，注册本地路由" class="headerlink" title="2.7.1 创建连接Service，注册本地路由"></a>2.7.1 创建连接Service，注册本地路由</h3><p>涉及到多进程，所以我们需要利用AIDL来进行进程间的通信。所以，应用内的每条进程，都需要创建一个连接Service，用来和广域路由进行通信。</p>
<p>创建自定义的Service继承自<code>LocalRouterConnectService</code>，不用做任何处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MainRouterConnectService extends LocalRouterConnectService &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在AndroidManifest.xml中进行注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;xxx.xxx.MainRouterConnectService&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>然后再在自定义的Application中的<code>initializeAllProcessRouter()</code>方法中，将该进程的连接Service注册给广域路由。  </p>
<p><code>WideRouter.registerLocalRouter</code>方法中第一个参数代表注册的进程名，第二个参数是对应连接Service的类名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void initializeAllProcessRouter() &#123;</span><br><span class="line">    WideRouter.registerLocalRouter(&quot;com.spinytech.maindemo&quot;,MainRouterConnectService.class);</span><br><span class="line">    WideRouter.registerLocalRouter(&quot;com.spinytech.maindemo:music&quot;,MusicRouterConnectService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-2-多进程调用"><a href="#2-7-2-多进程调用" class="headerlink" title="2.7.2 多进程调用"></a>2.7.2 多进程调用</h3><p>多进程调用与2.6中本地调用基本一样，只是在生成<code>RouterRequest</code>的时候，需要多加一个Domain，Domain就是需要调用的进程名。(在obtain<code>RouterRequest</code>的时候，如果不加domain，则默认domain是当前进程名)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RouterRequest</span><br><span class="line">    .obtain(context)</span><br><span class="line">    .domain(&quot;com.spinytech.maindemo:music&quot;)</span><br><span class="line">    .provider(&quot;music&quot;)</span><br><span class="line">    .action(&quot;play&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="2-8-RouterRequest中携带附件Object、RouterResponse中携带返回Object-v0-2-0新增"><a href="#2-8-RouterRequest中携带附件Object、RouterResponse中携带返回Object-v0-2-0新增" class="headerlink" title="2.8 RouterRequest中携带附件Object、RouterResponse中携带返回Object (v0.2.0新增)"></a>2.8 RouterRequest中携带附件Object、RouterResponse中携带返回Object (v0.2.0新增)</h3><p>在v0.2.0版本中，我们新增了<code>RouterRequest</code>中可以添加附件Object的功能(仅在单进程中有效)。</p>
<p>在<code>RouterRequest</code>中，新增了<code>object(Object attachment)</code>方法，来向请求中添加附件object。</p>
<p>在抽象类<code>MaAction</code>中，我们新增了两个方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Public boolean isAsync (context context, HashMap &lt;String, String&gt; requestData, Object object)`  </span><br><span class="line">Public MaActionResult invoke (Context context, HashMap &lt;String, String&gt; requestData, Object object)</span><br></pre></td></tr></table></figure>
<p>通过判断<code>RouterRequest</code>中，是否有携带附件Object，<code>LocalRouter</code>会去调用不同的invoke方法。  </p>
<p>相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RouterResponse.mIsAsync = attachment == null? TargetAction.isAsync (context, params): targetAction.isAsync (context, params, attachment);</span><br><span class="line">MaActionResult result = attachment == null? TargetAction.invoke (context, params): targetAction.invoke (context, params, attachment);</span><br></pre></td></tr></table></figure>
<p>在返回结果的时候，可以利用<code>MaActionResult.Builder</code>中的<code>object(Object returnedObject)</code>方法，向调用者返回一个对象实例，利用<code>RouterResponse</code>的<code>getObject()</code>方法来获取返回的Object。</p>
<p><strong>请注意：由于进程间内存不共享，所有的附件Object均只能在本进程内传递。跨进程的附件Object会默认被无视，请不要跨进程带附件Object调用。</strong></p>
<p>具体实现请参考：<a href="https://github.com/SpinyTech/ModularizationArchitecture/blob/master/maindemo/src/main/java/com/spinytech/maindemo/AttachObjectAction.java" target="_blank" rel="external">AttachObjectAction.java</a></p>
<h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h2><p>整个架构都是基于路由的原理来实现的，具体的实现原理，可以参考之前的一篇关于架构思考的文章，<br><a href="http://blog.spinytech.com/2016/12/28/android_modularization/">《Android架构思考》</a>，本项目基本的设计思路都在这篇文章中有所体现。</p>
<h2 id="4-存在缺陷"><a href="#4-存在缺陷" class="headerlink" title="4. 存在缺陷"></a>4. 存在缺陷</h2><ul>
<li>暂不支持多个相同ShareUid的Apk之间的调用。</li>
<li>需要继承自<code>MaApplication</code>，对原有<code>Application</code>代码有改动。</li>
</ul>
<h2 id="5-未来版本计划"><a href="#5-未来版本计划" class="headerlink" title="5. 未来版本计划"></a>5. 未来版本计划</h2><ul>
<li>加入<code>Action</code>失效开关，使其可以由服务端动态控制</li>
<li>加入<code>Action</code>热替换功能</li>
<li>优化消息传递过程中的打包拆包过程</li>
<li>加入<code>SokectAction</code>，实现<code>Action</code>的即时通信</li>
</ul>
<h2 id="6-版本"><a href="#6-版本" class="headerlink" title="6. 版本"></a>6. 版本</h2><h3 id="v0-2-1"><a href="#v0-2-1" class="headerlink" title="v0.2.1"></a>v0.2.1</h3><ul>
<li>修复了同步方法中<code>RouterResponse</code>无法正常获取code、message、data的BUG。</li>
</ul>
<h3 id="v0-2-0"><a href="#v0-2-0" class="headerlink" title="v0.2.0"></a>v0.2.0</h3><ul>
<li>增加了request中携带object的方法</li>
<li>支持单一进程中，传入和返回附件object功能</li>
<li>修复了一些小bug</li>
<li>maindemo中增加了新功能示例</li>
</ul>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x73;&#x70;&#x69;&#110;&#x79;&#46;&#x74;&#101;&#x63;&#x68;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">&#x73;&#x70;&#x69;&#110;&#x79;&#46;&#x74;&#101;&#x63;&#x68;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;red&quot; size=&quot;4&quot;&gt;项目地址：&lt;a href=&quot;https://github.com/SpinyTech/ModularizationArchitecture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Modulari
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="ModularizationArchitecture" scheme="http://blog.spinytech.com/tags/ModularizationArchitecture/"/>
    
      <category term="架构" scheme="http://blog.spinytech.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高并发对象池思考</title>
    <link href="http://blog.spinytech.com/2017/01/10/concurrent_object_pool/"/>
    <id>http://blog.spinytech.com/2017/01/10/concurrent_object_pool/</id>
    <published>2017-01-10T12:00:00.000Z</published>
    <updated>2017-02-15T08:47:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在整理一套Android的路由框架，在整理的过程中，发现在路由消息传递过程中，传输载体类会大量的生成，对于这种载体类来说，他们本身是可重复利用的，并不需要大量的创建，大量的废弃，所以，我打算引入对象池，来解决类的重复创建问题。</p>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>Java对象的生命周期大致包括三个阶段：<strong>对象的创建，对象的使用，对象的清除</strong>。因此，对象的生命周期长度可用如下的表达式表示：T = T1 + T2 +T3。其中T1表示对象的创建时间，T2表示对象的使用时间，而T3则表示其清除时间。由此，我们可以看出，只有T2是真正有效的时间，而T1、T3则是对象本身的开销。所以，避免和减少T1和T3的时间，能有效的提升程序的性能。</p>
<h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>在EffectJava的第五条建议中，明确给出了<strong>“避免创建不必要的对象”</strong>这样的建议。对于<strong>可重复利用的对象</strong>，我们不应该频繁的创建销毁，而是应该反复利用。  </p>
<p>重复利用对象，我们就需要建一个对象池，把所有可复用的对象都统一放到池中，同时对外提供<code>obtain()</code>方法来获取对象。通常，我们利用静态对象数组来实现对象池。</p>
<p>对象池的初始化策略分为两种，一种是统一初始化，即在特定时机统一初始化池内所有对象，第一次使用的时候会有一定的开销。另一种是即时初始化，就是在使用中进行初始化，每次都会有一定的开销，直到池内充满。</p>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>在对象池创建好之后，我们就需要考虑如何分配、回收对象池的对象了。由于是路由系统的载体类，所以势必会有多线程进行访问，我们还要考虑到线程安全，以及并发性能。  </p>
<p>关于线程安全，一般的做法是通过<code>synchronized</code>关键字来进行线程同步。不过这么做的话，相当于是对<code>obtain()</code>函数加了<strong>悲观锁</strong>。这么做虽然可以有效的防止同步问题，而且<code>synchronized</code>关键字也经过了JVM多次性能优化，不过，在性能上依然不能满足高并发的要求。</p>
<p>这时候我们参考可以参考<code>ConcurrentHashMap</code>，利用<strong>CAS算法</strong>(非阻塞同步算法)实现乐观锁。我们在类中创建一个<code>AtomicBoolean</code>变量，命名为<code>isIdle</code>，默认值为true(空闲状态)，当多个线程去争抢一个对象的时候，会调用<code>isIdle.compareAndSet(true,false)</code>，该方法会返回boolean类型的结果，如果返回true，则表明竞争成功，isIdle被设置为false（占用中），如果返回false，则表明该类已经被别的线程所占用，重新申请另外的对象，直到该对象的isIdle竞争成功。</p>
<p>相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 顺序计数器</span><br><span class="line">private static AtomicInteger sIndex;</span><br><span class="line">// 空闲标识</span><br><span class="line">AtomicBoolean isIdle;</span><br><span class="line">// 计数器重置参数</span><br><span class="line">private static final int RESET_NUM = 1000;</span><br><span class="line">public static ConcurrentRouterRequest obtain()&#123;</span><br><span class="line">    // 获取下一个计数器的值</span><br><span class="line">    int index = sIndex.getAndIncrement();</span><br><span class="line">    // 如果计数器过大，则置0</span><br><span class="line">    if(index&gt;RESET_NUM)&#123;</span><br><span class="line">        sIndex.compareAndSet(index,0);</span><br><span class="line">        if(index&gt;RESET_NUM*2)&#123;</span><br><span class="line">            sIndex.set(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算计数器对应对象数组的对象下标</span><br><span class="line">    int num = index&amp;(length-1);</span><br><span class="line"></span><br><span class="line">    // 获取对应对象</span><br><span class="line">    ConcurrentRouterRequest target = table[num];</span><br><span class="line"></span><br><span class="line">    // 竞争该对象的空闲标识，其中第一个参数true是我们希望的值，第二个参数是需要设置的值false。  </span><br><span class="line">    // 如果设置成功，那么直接返回target，如果失败，则继续寻找下一个空闲的对象。</span><br><span class="line">    if(target.isIdle.compareAndSet(true,false))&#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return obtain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要说一下，关于对象池如何分配对象的问题，这里采用的是顺序分配，每次获取都会在对象池中往后顺延一位。同时，对象池的长度默认为2的N次方，这样做的好处是通过按位与计算，能快速找出对象池中的数组下标，这个模仿了HashMap中的Hash值存储。</p>
<h3 id="测试对比"><a href="#测试对比" class="headerlink" title="测试对比"></a>测试对比</h3><p>模拟的条件是100条线程并发请求，每单个线程请求1000次，总计十万次并发。</p>
<table>
<thead>
<tr>
<th></th>
<th>时间开销</th>
<th>内存开销</th>
</tr>
</thead>
<tbody>
<tr>
<td>新建对象</td>
<td>220ms</td>
<td>1.53MB</td>
</tr>
<tr>
<td>利用对象池</td>
<td>180ms</td>
<td>1.25KB</td>
</tr>
</tbody>
</table>
<p>第一种情况是直接用new关键字新建对象，处理请求，最后的结果是耗时220ms，内存消耗100000*16(byte)=1.53MB。</p>
<p>第二种情况是使用对象池处理请求，最后耗时180ms，内存消耗为64*20(byte)=1.25KB。</p>
<p>通过对比我们可以看出，首先，由于减少了对象的创建，虽然多了同步，不过在时间性能上，对象池还是优于新建对象，大概提升了20%左右的性能。该时间还不包括GC回收的开销，如果加上的话，性能提升会更明显。其次，在内存上面，两者的差距是1000倍左右的，极大地节省了内存的开销，减少了GC的触发。</p>
<h3 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h3><p>下面放一个纯Java实现的高并发对象池</p>
<p>对象池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public final class ObjectPool&lt;OBJECT extends ObjectPool.RecyclableObject&gt; &#123;</span><br><span class="line">    private OBJECT[] mTable;</span><br><span class="line">    private AtomicInteger mOrderNumber;</span><br><span class="line">    public static int RESET_NUM = 1000;</span><br><span class="line"></span><br><span class="line">    public ObjectPool(OBJECT[] inputArray) &#123;</span><br><span class="line">        mOrderNumber = new AtomicInteger(0);</span><br><span class="line">        mTable = inputArray;</span><br><span class="line">        if (mTable == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;The input array is null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int length = inputArray.length;</span><br><span class="line">        if ((length &amp; length - 1) != 0) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;The length of input array is not 2^n.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void recycle(OBJECT object) &#123;</span><br><span class="line">        object.isIdle.set(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public OBJECT obtain() &#123;</span><br><span class="line">        int index = mOrderNumber.getAndIncrement();</span><br><span class="line">        if (index &gt; RESET_NUM) &#123;</span><br><span class="line">            mOrderNumber.compareAndSet(index, 0);</span><br><span class="line">            if (index &gt; RESET_NUM * 2) &#123;</span><br><span class="line">                mOrderNumber.set(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int num = index &amp; (mTable.length - 1);</span><br><span class="line"></span><br><span class="line">        OBJECT target = mTable[num];</span><br><span class="line"></span><br><span class="line">        if (target.isIdle.compareAndSet(true, false)) &#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 注意：此处可能会因为OBJECT回收不及时，而导致栈溢出。</span><br><span class="line">            // 请增加retryTime参数，以及retryTime过多后的判断。</span><br><span class="line">            // 具体思路请参考</span><br><span class="line">            // https://github.com/SpinyTech/ModularizationArchitecture/blob/master/macore/src/main/java/com/spinytech/macore/router/RouterRequest.java</span><br><span class="line">            // 中的obtain()及obtain(int retryTime);方法</span><br><span class="line">            return obtain();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract static class RecyclableObject &#123;</span><br><span class="line">        AtomicBoolean isIdle = new AtomicBoolean(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestObject[] array = new TestObject[32];</span><br><span class="line">        for(int i = 0 ; i &lt; 32 ;i++)&#123;</span><br><span class="line">            array[i] = new TestObject();</span><br><span class="line">        &#125;</span><br><span class="line">        final ObjectPool&lt;TestObject&gt; objectPool = new ObjectPool&lt;&gt;(array);</span><br><span class="line"></span><br><span class="line">        for(int i = 0 ; i &lt; 50; i++)&#123;</span><br><span class="line">            new Thread(&quot;Thread:&quot;+i)&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    super.run();</span><br><span class="line">                    for(int j = 0 ; j &lt; 50 ; j++)&#123;</span><br><span class="line">                        TestObject testObject = objectPool.obtain();</span><br><span class="line">                        testObject.print(getName(),&quot;--index:&quot;+j);</span><br><span class="line">                        objectPool.recycle(testObject);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestObject extends ObjectPool.RecyclableObject&#123;</span><br><span class="line">        public TestObject()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        public void print(String thread, String index)&#123;</span><br><span class="line">            System.out.println(thread+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#115;&#x70;&#105;&#x6e;&#x79;&#46;&#x74;&#101;&#99;&#104;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;">&#115;&#x70;&#105;&#x6e;&#x79;&#46;&#x74;&#101;&#99;&#104;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在整理一套Android的路由框架，在整理的过程中，发现在路由消息传递过程中，传输载体类会大量的生成，对于这种载体类来说，他们本身是可重复利用的，并不需要大量的创建，大量的废弃，所以，我打算引入对象池，来解决类的重复创建问题。&lt;/p&gt;
&lt;h3 id=&quot;对象的生命周期&quot;
    
    </summary>
    
      <category term="Java" scheme="http://blog.spinytech.com/categories/Java/"/>
    
    
      <category term="高并发" scheme="http://blog.spinytech.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="对象池" scheme="http://blog.spinytech.com/tags/%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android架构思考(模块化、多进程)</title>
    <link href="http://blog.spinytech.com/2016/12/28/android_modularization/"/>
    <id>http://blog.spinytech.com/2016/12/28/android_modularization/</id>
    <published>2016-12-28T12:00:00.000Z</published>
    <updated>2017-02-20T09:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于<strong>模块化(组件化)</strong>这个问题，我想每个开发者可能都认真的思考过。随着项目的开发，<strong>业务不断壮大，业务模块越来越多，各个模块间相互引用，耦合越来越严重</strong>，同时有些项目（比如我们公司）还伴随着子应用单独包装推广，影子应用单独发布等等需求，重新调整架构迫在眉睫。今天，我们就来聊聊模块化(组件化)，这篇文章同时也是我这几年，对项目架构的理解。</p>
<font color="blue" size="3">*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</font>  

<h2 id="最初的超小型项目"><a href="#最初的超小型项目" class="headerlink" title="最初的超小型项目"></a>最初的超小型项目</h2><p>当我们最开始做Android项目的时候，大多数人都是没考虑项目架构的，我们先上一张图。<br><img src="http://ogsbxb571.bkt.clouddn.com/old_architecture1.jpg" alt="2012年开发的一个小项目"></p>
<p>这个分包结构有没有很熟悉，各种组件都码在一个包里，完全没有层级结构，<strong>业务、界面、<br>逻辑都耦合在一起</strong>。这是我12年底刚开始入门Android的时候开发的一个小项目，半年后，来了个小伙伴，然后我们一起开发，然后天天因为谁修改了谁的代码<strong>打的不可开交</strong>。  </p>
<h2 id="架构改进，小型项目"><a href="#架构改进，小型项目" class="headerlink" title="架构改进，小型项目"></a>架构改进，小型项目</h2><p>再后来开发App，人员比之前多了，所以不能按照以前那样了，必须得重构。于是我把公用的代码提取出来制作成<strong>SDK基础库</strong>，把单独的功能封装成<strong>Library包</strong>，不同业务通过分包结构分到不同<strong>module</strong>下，组内每人开发自己的module。刚开始都还轻松加愉快，并行开发啥的，一片融洽的场景，如下图。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E6%97%A9%E6%9C%9F%E6%9E%B6%E6%9E%84-1.png" alt="刚刚重构之后的架构"></p>
<p>随着时间推移，我们的App迭代了几个版本，这几个版本也没什么别的，大体来讲就是三件事情：</p>
<ul>
<li>扩展了一些新业务模块，同时模块间相互调用也增加了。  </li>
<li>修改增加了一些新的库文件，来支持新的业务模块。  </li>
<li>对Common SDK进行了扩展、修复。  </li>
</ul>
<p><del>很惭愧，就做了一些微小的工作</del>，但是架构就变成下图这样。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E6%97%A9%E6%9C%9F%E6%9E%B6%E6%9E%84-2.png" alt="做了几件微小的工作之后"></p>
<p>可以看到，随着几个版本业务的增加，各个业务某块之间耦合愈发严重，导致代码很难维护，更新，更别说写测试代码了。虽然后期引入统一广播系统，一定程度改善了模块间相互引用的问题，但是局限性和耦合性还是很高，没办法根治这个问题。这个架构做到最后，<strong>扩展性和可维护性都是很差</strong>，并且<strong>难以测试</strong>，所以最终被历史的进程所抛弃。</p>
<h2 id="中小型项目，路由架构"><a href="#中小型项目，路由架构" class="headerlink" title="中小型项目，路由架构"></a>中小型项目，路由架构</h2><p>时间很快就来到了2015年，这一年动态加载、热修复很火，360、阿里等大公司先后开源了自己的解决方案，如droidplugin、andfix等。在研究了一圈发现，这些技术对架构升级有一定的帮助，尤其是droidplugin的加载apk的思想，能很好地解决耦合度高、方法数超过65535、动态修复bug等问题，不过由于项目本身不是很大，并且没有专门的人来维护架构，所以最后放弃了功能强大、但是问题也同样多的<strong>插件化</strong>，退而求其次，选择了利用<strong>路由机制</strong>来实现<strong>组件化</strong>解耦。  </p>
<p>关于路由机制，熟悉iOS开发的朋友可能并不陌生，在iOS上有很多架构方案都是采用路由机制来时间模块之间的解耦的，比如<strong>VIPER（View Interactor Presenter Entity Routing）</strong>思想等等。其实思路都是相同的，Android上面组件化也是通过<strong>公用的路由</strong>，来实现模块与模块之间的隔离。  </p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>我们先来看下路由架构图。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-1.png" alt="路由架构">  </p>
<p><a href="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-1.png" target="_blank" rel="external">大图点我</a>  </p>
<p>通过上图可以看到，我们在最基础的Common库中，创建了一个路由<code>Router</code>，中间有n个模块<code>Module</code>，这个<code>Module</code>实际上就是Android Studio中的module，这些<code>Module</code>都是<strong>Android Library Module</strong>，最上面的Module Main是<strong>可运行的Android  Application Module</strong>。  </p>
<p><strong>这几个<code>Module</code>都引用了Common库，同时Main Module还引用了A、B、N这几个<code>Module</code></strong>，经过这样的处理之后，<strong>所有的<code>Module</code>之间的相互调用就都消失了，耦合性降低，所有的通信统一都交给Router来处理分发，而注册工作则交由Main Module去进行初始化</strong>。这个架构思想其实和Binder的思想很类似，采用C/S模式，模块之间隔离，数据通过共享区域进行传递。模块与模块之间只暴露对外开放的Action，所以也具备<strong>面向接口编程思想</strong>。  </p>
<p>图中的红色矩形代表的是行动<code>Action</code>，<code>Action</code>是具体的执行类，其内部的<strong>invoke方法是具体执行的代码逻辑</strong>。如果涉及到<strong>并发操作</strong>的话，可以在<strong>invoke方法内加入锁，或者直接在invoke方法上加上synchronized描述</strong>。  </p>
<p>图中的黄色矩形代表的是供应商<code>Provider</code>，每个<code>Provider</code>中包含1个或多个<code>Action</code>，其内部的数据结构以<strong>HashMap</strong>来存储Action。<strong>首先HashMap查询的时间复杂度是O(1)，符合我们对调用速度上的要求，其次，由于我们是统一进行注册，所以在写入时并不存在并发线程并发问题，在读取时，并发问题则交由Action的invoke去具体处理。</strong>在每一个<code>Module</code>内都会有1个或多个供应商<code>Provider</code>（如果不包含<code>Provider</code>，那么这个<code>Module</code>将无法为其他<code>Module</code>提供服务）。</p>
<p>途中蓝色矩形代表的是路由<code>Router</code>，每个<code>Router</code>中包含多个<code>Provider</code>，其内部的数据结构也是以<strong>HashMap</strong>来存储<code>Provider</code>，原理也和<code>Provider</code>是一样的。之所以用了两次HashMap，有两点原因，一个是因为这样做，<strong>不容易导致<code>Action</code>的重名</strong>，另一个是因为在注册的时候，只注册<code>Provider</code>会<strong>减少注册代码，更易读</strong>。并且由于HashMap的查询时间复杂度是O(1)，所以两次查找不会浪费太多时间。当查找不到对应<code>Action</code>的时候，Router会生成一个<code>ErrorAction</code>，会告之调用者没有找到对应的<code>Action</code>，由调用者来决定接下来如何处理。  </p>
<h3 id="一次请求流程"><a href="#一次请求流程" class="headerlink" title="一次请求流程"></a>一次请求流程</h3><p>通过Router调用的具体流程是这样的:  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/Router%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Router时序图"></p>
<ol>
<li>任意代码创建一个<code>RouterRequest</code>，包含<code>Provider</code>和<code>Action</code>信息，向<code>Router</code>进行请求。  </li>
<li><code>Router</code>接到请求，通过<code>RouterRequest</code>的<code>Provider</code>信息，在内部的HashMap中查找对应的<code>Provider</code>。  </li>
<li><code>Provider</code>接到请求，在内部的HashMap中查找到对应的<code>Action</code>信息。  </li>
<li><code>Action</code>调用invoke方法。    </li>
<li>返回invoke方法生成的<code>ActionResult</code>。    </li>
<li>将<code>Result</code>封装成<code>RouterResponse</code>，返回给调用者。  </li>
</ol>
<h3 id="耦合降低"><a href="#耦合降低" class="headerlink" title="耦合降低"></a>耦合降低</h3><p>所有的<code>Module</code>之间的相互依赖没有了，我们可以在主app中，取消任意的<code>Module</code>引用而不影响整体App的编译及运行。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-2.png" alt="取消对Module N的依赖"></p>
<p>如图所示，我们取消了对<code>Module N</code>的依赖，整体应用依然可以稳定运行，遇到调用<code>Module N</code>的地方，会返回Not Found提示，实际开发中可以根据需求做具体的处理。</p>
<h3 id="可测试性增强"><a href="#可测试性增强" class="headerlink" title="可测试性增强"></a>可测试性增强</h3><p>由于每个<code>Module</code>并不依赖其他的<code>Module</code>，所以在开发过程中，我们只针对自己的模块进行开发，并可以建一个测试App来进行白盒测试。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-3.png" alt="测试Module A"></p>
<h3 id="复用性增强"><a href="#复用性增强" class="headerlink" title="复用性增强"></a>复用性增强</h3><p>关于复用性这块。作者所处的行业是招商投资这块，这个行业需要围绕主业务开发很多影子APP，将覆盖面扩大（有点类似58-&gt;58租房、58招聘，美团-&gt;美团外卖等）。这个时候，这个架构的复用性就体现出来了，我们可以把业务进行拆分，然后写一个包装App，就可以生成一个独立的影子APP，这个影子APP用到哪些<code>Module</code>就引用哪些就可以了，开发迅速，并且后期<code>Module</code>业务有变化，也不用更改所有的代码，减少了代码的复制。比如我们就曾经把IM模块和投资咨询模块单独拿出来，写了一些界面和样式，就生成了“招商经纪人”App。  </p>
<h3 id="支持并行开发"><a href="#支持并行开发" class="headerlink" title="支持并行开发"></a>支持并行开发</h3><p>整套架构很类似Git的Branch思想，基于主线，分支单独开发，最后再回归主线这种思路。这里只是思路和branch相似，实际的开发过程中，我们每个module可以是一个branch，也可以是一个仓库。每个模块都需要自己有单独的版本控制，便于问题管理及溯源。主项目对各个模块的引用可以是直接引用，也可以是导出aar引用，或者是上传JCenter Maven等等方式。不过思路是统一的：继承公共-&gt;独立开发-&gt;主线合并。</p>
<h3 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h3><p>2017.2.20新增</p>
<p>最近有朋友在评论里问公共的类还有共有资源怎么处理，其实非常简单，我们在Router和Module之间再加一层，加一层CommonBaseLibrary，里面放一些所有项目都会用到的资源文件，Model类，工具类等等，然后CommonBaseLibrary再引入Router即可。</p>
<p>如下图</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-4.png" alt="引入基础库"></p>
<p><a href="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-4.png" target="_blank" rel="external">大图点我</a></p>
<p>需要注意的是，我们的Module A，不需要CommonBaseLibrary中的公共资源，所以没有引用CommonBaseLibrary，但是实际其他还是可以被其他模块所调用，因为它内部有Router。</p>
<h2 id="多进程思考，中型项目"><a href="#多进程思考，中型项目" class="headerlink" title="多进程思考，中型项目"></a>多进程思考，中型项目</h2><p>随着项目的不断扩大，App在运行时的内存消耗也在不断增加，而且有时线上的BUG也会导致整体崩溃。为了保证良好的用户体验，减少对系统资源的消耗，我们开始考虑采取多进程重新架构程序，通过按需加载，及时释放，达到优化的目的。  </p>
<h3 id="多进程优势"><a href="#多进程优势" class="headerlink" title="多进程优势"></a>多进程优势</h3><p>多进程的优点和使用场景，之前在<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/">《Android多进程使用场景》</a>中也做过介绍，大体优点有这么几个：</p>
<ul>
<li>提高各个进程的稳定性，单一进程崩溃后不影响整个程序。  </li>
<li>对于内存的时候更可控，可以通过手工释放进程，达到内存优化目的。  </li>
<li>基于独立的JVM，各个模块可以充分解耦。  </li>
<li>只保留daemon进程的情况下，会使应用存活时间更长，不容易被回收掉。  </li>
</ul>
<h3 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h3><p>但是启用多进程，那就意味着Router系统的失效。<strong>Router是JVM级别的单例模式，并不支持跨进程访问</strong>。也就是说，你的后台进程的所有<code>Provider</code>、<code>Action</code>，是注册给后台Router的。当你在前台进程调用的时候，根本调用不到其他进程的<code>Action</code>。  </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实解决的方法也并不复杂。原来的路由系统还可以继续使用，我们可以<strong>把整套架构想象成互联网</strong>，现在多个进程有多个路由，我们只需要把多个路由连接到一起，那么整个路由系统还是可以正常运行的。所以我们把原有的路由<code>Router</code>称之为本地路由<code>LocalRouter</code>，现在，我们需要提供一个IPS、DNS供应商，那就创建一个进程，该进程的作用就是注册路由，链接路由，转发报文，我们称之为广域路由<code>WideRouter</code>。  </p>
<p>我们先来看下路由连接架构图</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B7%AF%E7%94%B1%E8%BF%9E%E6%8E%A5%E5%9B%BE.png" alt="路由连接架构"></p>
<p><a href="http://ogsbxb571.bkt.clouddn.com/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B7%AF%E7%94%B1%E8%BF%9E%E6%8E%A5%E5%9B%BE.png" target="_blank" rel="external">点击大图</a></p>
<p>如图所示，竖直方向上，每一列，代表一个进程，通过虚线隔开，分别有Process WideRouter、Process Main、Process A、···、Process N这些进程。浅黄色的代表<code>WideRouter</code>，深黄色的代表<code>WideRouter</code>的守护Service。浅蓝色的代表每个进程的<code>LocalRouter</code>，深蓝色的代表每个<code>LocalRouter</code>的守护Service。<code>WideRouter</code>通过AIDL与每个进程<code>LocalRouter</code>的守护Service绑定到一起，每个<code>LocalRouter</code>也是通过AIDL与<code>WideRouter</code>的守护Service绑定到一起，这样，就达到了所有路由都是双向互连的目的。</p>
<h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p>之前单一路由的事件分发是通过两层HashMap查找<code>Provider</code>和<code>Action</code>，进行事件下发。那么现在在外面加了一层<code>WideRouter</code>，那么我们再加一层<code>Domain</code>，<strong><code>Domain</code>对应的是Android应用内，各个进程的进程名</strong>。通常情况下，如果事件是在同一进程下，那么就类似于局域网内部事件传递，不需要通过<code>WideRouter</code>，直接内部按照之前的路由逻辑进行转发，如果不在相同进程内，就由<code>WideRouter</code>进行进程间通信，达到跨进程调用的效果。  </p>
<p>事件请求<code>RouterRequest</code>可以写成两种，<strong>一种是URL，一种JSON</strong>。（内部处理的时候统一使用JSON），同时也提供了对URL和JSON的解析方法，方便使用。  </p>
<p>URL:xxxDomain/xxxProvider/xxxAction?data1=xxx&amp;data2=xxx<br>这就和Http请求很像了。这样做的好处就是对后续WebView上可以非常便利得直接调用本地<code>Action</code>。</p>
<p>JSON:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    domain: xxx,</span><br><span class="line">    provider: xxx,</span><br><span class="line">    action: xxx,</span><br><span class="line">    data&#123;</span><br><span class="line">        data1: xxx,</span><br><span class="line">        data2: xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON方式简单明了，可作为接口返回值由服务器下发给客户端。  </p>
<p>下面仔细讲一下一次跨进程请求，事件是如何传递的：</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E5%B9%BF%E5%9F%9F%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="事件传递图"></p>
<p><a href="http://ogsbxb571.bkt.clouddn.com/%E5%B9%BF%E5%9F%9F%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%97%B6%E5%BA%8F%E5%9B%BE.png" target="_blank" rel="external">点击大图</a>  </p>
<p>从图中可以清晰地看出，我们主要是分两大部分去完成事件分发传递的。</p>
<ul>
<li>第一部分，跨进程判断目标<code>Action</code>是否是异步程序。</li>
<li>第二部分，跨进程执行目标<code>Action</code>调用。</li>
</ul>
<p>首先我们先通过<code>Domain</code>、<code>Provider</code>、<code>Action</code>去跨进程查找是否是异步程序。如果是异步程序，那么我们直接生成RouterResponse(Step13)，并且，将Step14-Step24统一封装成Future，放在RouterResponse中，直接返回。如果是同步程序，那么就在当前方法内执行Step14-Step24，将返回结果放入RouterResponse内(Step25)，直接返回。这么做的目的是，我们的路由调用方法<code>route(RouterRequest)</code>默认是同步方法，不耗时的，可以直接在主线程里调用而不造成阻塞，不造成ANR。如果调用的目标<code>Action</code>是异步的，那么可以利用Java的FutureTask原理，调用<code>RouterResponse</code>的<code>get()</code>方法，获取结果。这个<code>get()</code>方法有可能是耗时的，是否耗时，取决于<code>RouterResponse.isAsync</code>的值是否是<code>true</code>。</p>
<p>至于本地事件分发，还是与之前的Router模式，从Step17到Step21，都是我们上文中，单进程同步Router分发机制，没有作任何改变。  </p>
<h3 id="多进程Application逻辑分发"><a href="#多进程Application逻辑分发" class="headerlink" title="多进程Application逻辑分发"></a>多进程Application逻辑分发</h3><p>在多进程中，每启动一个新的进程，都会重新创建一次Application，所以，我们需要把各个进程的Application逻辑剥离出来，然后根据不同的<code>Process Name</code>，选择不同的Application逻辑进行处理。  </p>
<p>实际的Application启动流程如下：</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E5%A4%9A%E8%BF%9B%E7%A8%8BApplication%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="多进程Application启动流程"></p>
<p>首先，我们先把所有<code>ApplicationLogic</code>注册到Application中，然后，Application会根据注册时的进程名信息进行筛选，选择相同进程名的<code>ApplicationLogic</code>，保存到本进程中，然后，对这些本进程的<code>ApplicationLogic</code>进行实例化，最后，调用<code>ApplicationLogic</code>的<code>onCreate</code>方法，实现<code>ApplicationLogic</code>与<code>Application</code>生命周期同步，同时还有<code>onTerminate</code>、<code>onLowMemory</code>、<code>onTrimMemory</code>、<code>onConfigurationChanged</code>等方法，与<code>onCreate</code>一致。</p>
<h3 id="结束进程，释放内存"><a href="#结束进程，释放内存" class="headerlink" title="结束进程，释放内存"></a>结束进程，释放内存</h3><p>在我们不使用某些进程的时候，比如听音乐的时候，可以把主界面关掉等等。我们可以调用对应进程的<code>LocalRouter</code>的<code>stopSelf()</code>方法，该方法可以使本进程与<code>WideRouter</code>进行解绑，然后我们在手动关掉进程内的其他组件，最后调用<code>System.exit()</code>，达到释放内存的目的。合理的释放内存，能有效的改善用户体验。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章大概讲了一下作者这几年对Android架构的理解。其实本文中没有什么很深的技术点，大多是一些设计模式，架构思想。这套框比起大公司的一些优秀的动态更新、编译分包、apk插件化加载，还是简单很多的，更适合中小型应用。</p>
<p>这套框架目前还有比较多可以改进的地方，目前正在整理的：</p>
<ul>
<li>增加对<code>Action</code>的动态关闭功能。</li>
<li>通过<code>Instant Run</code>原理，实现<code>Action</code>的热更新。</li>
<li>增加<code>Message Pool</code>，实现<code>Request</code>、<code>Response</code>的循环利用，减少GC触发。<br>已解决<a href="http://blog.spinytech.com/2017/01/10/concurrent_object_pool/">《高并发对象池思考》</a></li>
<li>优化<code>Message</code>在传递过程中的打包，拆包的速度，提升整体性能。</li>
<li>etc.</li>
</ul>
<p>本文项目地址：<a href="https://github.com/SpinyTech/ModularizationArchitecture" target="_blank" rel="external">ModularizationArchitecture</a>，欢迎大家star、fork、提建议。</p>
<p>或者直接在项目中引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.spinytech.ma:macore:0.2.0&apos;</span><br></pre></td></tr></table></figure>
<p>相关教程：<a href="http://blog.spinytech.com/2017/02/01/ma_get_start_cn/">ModularizationArchitecture 使用教程</a></p>
<p>如果有疑问或者建议，欢迎联系我，邮箱是：<a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x73;&#112;&#105;&#x6e;&#x79;&#46;&#x74;&#x65;&#99;&#x68;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;">&#x73;&#112;&#105;&#x6e;&#x79;&#46;&#x74;&#x65;&#99;&#x68;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#111;&#x6d;</a><br>谢谢大家阅读</p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#x73;&#x70;&#105;&#110;&#x79;&#46;&#x74;&#101;&#x63;&#104;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;">&#x73;&#x70;&#105;&#110;&#x79;&#46;&#x74;&#101;&#x63;&#104;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;strong&gt;模块化(组件化)&lt;/strong&gt;这个问题，我想每个开发者可能都认真的思考过。随着项目的开发，&lt;strong&gt;业务不断壮大，业务模块越来越多，各个模块间相互引用，耦合越来越严重&lt;/strong&gt;，同时有些项目（比如我们公司）还伴随着子应用单独包装推广，影
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="架构思考" scheme="http://blog.spinytech.com/tags/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/"/>
    
      <category term="模块化" scheme="http://blog.spinytech.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="多进程" scheme="http://blog.spinytech.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>View绘制分析笔记之onDraw</title>
    <link href="http://blog.spinytech.com/2016/12/19/android_view_on_draw/"/>
    <id>http://blog.spinytech.com/2016/12/19/android_view_on_draw/</id>
    <published>2016-12-19T12:00:00.000Z</published>
    <updated>2016-12-22T03:18:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我们了解了View的onLayout，那么今天我们来学习Android View绘制三部曲的最后一步，onDraw，绘制。  </p>
<h2 id="ViewRootImpl-performDraw"><a href="#ViewRootImpl-performDraw" class="headerlink" title="ViewRootImpl#performDraw"></a>ViewRootImpl#performDraw</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void performDraw() &#123;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">    final boolean fullRedrawNeeded = mFullRedrawNeeded;</span><br><span class="line">    mFullRedrawNeeded = false;</span><br><span class="line"></span><br><span class="line">    mIsDrawing = true;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;draw&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">       mIsDrawing = false;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performDraw主要的作用是调用<code>ViewRootImpl#draw</code>方法，并传递一个mFullRedrawNeeded参数，这个参数就是告诉draw方法，是否需要整体重新绘制，所以，我们把重点放在<code>ViewRootImpl#draw</code>这里。</p>
<h2 id="ViewRootImpl-draw"><a href="#ViewRootImpl-draw" class="headerlink" title="ViewRootImpl#draw"></a>ViewRootImpl#draw</h2><p>下面代码为draw方法的关键代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">    //省略</span><br><span class="line">    ···</span><br><span class="line">    //生成绘制区域</span><br><span class="line">    final Rect dirty = mDirty;</span><br><span class="line">    //如果需要全屏绘制，则将dirty区域宽高设为全屏</span><br><span class="line">    if (fullRedrawNeeded) &#123;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = true;</span><br><span class="line">        dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));</span><br><span class="line">    &#125;</span><br><span class="line">    //省略</span><br><span class="line">    ···</span><br><span class="line">    //调用drawSoftware方法，并传递dirty区域</span><br><span class="line">    if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewRootImpl-drawSoftware"><a href="#ViewRootImpl-drawSoftware" class="headerlink" title="ViewRootImpl#drawSoftware"></a>ViewRootImpl#drawSoftware</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">        boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line"></span><br><span class="line">    //通过dirty区域，获取并锁定canvas，后续传给decorView</span><br><span class="line">    final Canvas canvas;</span><br><span class="line">    try &#123;</span><br><span class="line">        final int left = dirty.left;</span><br><span class="line">        final int top = dirty.top;</span><br><span class="line">        final int right = dirty.right;</span><br><span class="line">        final int bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    &#125; catch (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        mLayoutRequested = true;    </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略</span><br><span class="line">    ···</span><br><span class="line">    //开始调用decorView的draw方法</span><br><span class="line">    mView.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-draw"><a href="#View-draw" class="headerlink" title="View#draw"></a>View#draw</h2><p>终于到了View的部分，View的draw方法，答题包括了6个步骤，稍后我们通过源代码进行逐步分析。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">@CallSuper</span><br><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">    final int privateFlags = mPrivateFlags;</span><br><span class="line">    //获取dirty区域是否不透明</span><br><span class="line">    final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    //将flag22位21位设置为off，并且将PFLAG_DRAWN设置为on</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line">      </span><br><span class="line">    //下面的注释是google对view的draw方法的6步分解注释  </span><br><span class="line">    /*</span><br><span class="line">     * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">     * in the appropriate order:</span><br><span class="line">     *</span><br><span class="line">     *      1. Draw the background</span><br><span class="line">     *      2. If necessary, save the canvas&apos; layers to prepare for fading</span><br><span class="line">     *      3. Draw view&apos;s content</span><br><span class="line">     *      4. Draw children</span><br><span class="line">     *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">     *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // 第一步，绘制背景，如果需要的话。</span><br><span class="line">    int saveCount;</span><br><span class="line">    // 如果dirty区域是不透明的，则跳过绘制背景。</span><br><span class="line">    if (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 大多数情况(不需要绘制边界阴影的情况)都不需要2和5这两部，跳过</span><br><span class="line">    final int viewFlags = mViewFlags;</span><br><span class="line">    // 是否需要绘制横向边界阴影</span><br><span class="line">    boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">    // 是否需要绘制竖向向边界阴影</span><br><span class="line">    boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">    // 不需要绘制横向和竖向阴影，执行3，4，6步</span><br><span class="line">    if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        // Step 3, draw the content</span><br><span class="line">        if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Step 4, draw the children</span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        // Overlay is part of the content and draws beneath Foreground</span><br><span class="line">        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Step 6, draw decorations (foreground, scrollbars)</span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        // we&apos;re done...</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Here we do the full fledged routine...</span><br><span class="line">     * (this is an uncommon case where speed matters less,</span><br><span class="line">     * this is why we repeat some of the tests that have been</span><br><span class="line">     * done above)</span><br><span class="line">     */</span><br><span class="line">    // 需要绘制阴影的话，则执行全部2-6的流程，不过这个流程并不常见，而且性能和速度上也不是很优秀。 </span><br><span class="line">    boolean drawTop = false;</span><br><span class="line">    boolean drawBottom = false;</span><br><span class="line">    boolean drawLeft = false;</span><br><span class="line">    boolean drawRight = false;</span><br><span class="line"></span><br><span class="line">    float topFadeStrength = 0.0f;</span><br><span class="line">    float bottomFadeStrength = 0.0f;</span><br><span class="line">    float leftFadeStrength = 0.0f;</span><br><span class="line">    float rightFadeStrength = 0.0f;</span><br><span class="line"></span><br><span class="line">    // 第二步，保存fading相关的canvas图层信息</span><br><span class="line">    int paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    final boolean offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">    if (offsetRequired) &#123;</span><br><span class="line">        paddingLeft += getLeftPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int left = mScrollX + paddingLeft;</span><br><span class="line">    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">    int top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">    int bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">    if (offsetRequired) &#123;</span><br><span class="line">        right += getRightPaddingOffset();</span><br><span class="line">        bottom += getBottomPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">    final float fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">    int length = (int) fadeHeight;</span><br><span class="line"></span><br><span class="line">    // clip the fade length if top and bottom fades overlap</span><br><span class="line">    // overlapping fades produce odd-looking artifacts</span><br><span class="line">    if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">        length = (bottom - top) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // also clip horizontal fades if necessary</span><br><span class="line">    if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">        length = (right - left) / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verticalEdges) &#123;</span><br><span class="line">        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));</span><br><span class="line">        drawTop = topFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));</span><br><span class="line">        drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (horizontalEdges) &#123;</span><br><span class="line">        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));</span><br><span class="line">        drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));</span><br><span class="line">        drawRight = rightFadeStrength * fadeHeight &gt; 1.0f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    int solidColor = getSolidColor();</span><br><span class="line">    if (solidColor == 0) &#123;</span><br><span class="line">        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">        if (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, null, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第三步，如果不是透明的，则调用onDraw方法进行绘制</span><br><span class="line">    if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    // 第四步，调用dispatchDraw方法，绘制子View</span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    // 第五步，绘制阴影边缘</span><br><span class="line">    final Paint p = scrollabilityCache.paint;</span><br><span class="line">    final Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    final Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    if (drawTop) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (drawBottom) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * bottomFadeStrength);</span><br><span class="line">        matrix.postRotate(180);</span><br><span class="line">        matrix.postTranslate(left, bottom);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (drawLeft) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * leftFadeStrength);</span><br><span class="line">        matrix.postRotate(-90);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (drawRight) &#123;</span><br><span class="line">        matrix.setScale(1, fadeHeight * rightFadeStrength);</span><br><span class="line">        matrix.postRotate(90);</span><br><span class="line">        matrix.postTranslate(right, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    // 绘制覆盖物，这个覆盖物在前景图的下面（API18引入）</span><br><span class="line">    if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第六步，绘制前景图</span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-drawBackground"><a href="#View-drawBackground" class="headerlink" title="View#drawBackground"></a>View#drawBackground</h2><p>这是第一步，绘制背景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void drawBackground(Canvas canvas) &#123;</span><br><span class="line">    final Drawable background = mBackground;</span><br><span class="line">    if (background == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果背景边界发生变化，则重新设置边界大小</span><br><span class="line">    setBackgroundBounds();</span><br><span class="line"></span><br><span class="line">    // 如果设置了硬件加速，则使用 display list 绘制背景</span><br><span class="line">    if (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo != null</span><br><span class="line">            &amp;&amp; mAttachInfo.mHardwareRenderer != null) &#123;</span><br><span class="line">        mBackgroundRenderNode = getDrawableRenderNode(background, mBackgroundRenderNode);</span><br><span class="line"></span><br><span class="line">        final RenderNode renderNode = mBackgroundRenderNode;</span><br><span class="line">        if (renderNode != null &amp;&amp; renderNode.isValid()) &#123;</span><br><span class="line">            setBackgroundRenderNodeProperties(renderNode);</span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //获取滑动偏移量，如果有偏移，则先把canvas移动，然后绘制背景，最后再移动回来。</span><br><span class="line">    final int scrollX = mScrollX;</span><br><span class="line">    final int scrollY = mScrollY;</span><br><span class="line">    if ((scrollX | scrollY) == 0) &#123;</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        canvas.translate(scrollX, scrollY);</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">        canvas.translate(-scrollX, -scrollY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewGroup-dispatchDraw"><a href="#ViewGroup-dispatchDraw" class="headerlink" title="ViewGroup#dispatchDraw"></a>ViewGroup#dispatchDraw</h2><p>这里是第四步，绘制子View，dispatchDraw方法由ViewGroup实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    final int childrenCount = mChildrenCount;</span><br><span class="line">    final View[] children = mChildren;</span><br><span class="line">    int flags = mGroupFlags;</span><br><span class="line">    //查看FLAG_RUN_ANIMATION是否是on，如果是的话，则为子View设置动画，并启动动画</span><br><span class="line">    if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) &#123;</span><br><span class="line">        final boolean buildCache = !isHardwareAccelerated();</span><br><span class="line">        for (int i = 0; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            final View child = children[i];</span><br><span class="line">            if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">                final LayoutParams params = child.getLayoutParams();</span><br><span class="line">                attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class="line">                bindLayoutAnimation(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final LayoutAnimationController controller = mLayoutAnimationController;</span><br><span class="line">        if (controller.willOverlap()) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        controller.start();</span><br><span class="line"></span><br><span class="line">        mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;</span><br><span class="line"></span><br><span class="line">        if (mAnimationListener != null) &#123;</span><br><span class="line">            mAnimationListener.onAnimationStart(controller.getAnimation());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int clipSaveCount = 0;</span><br><span class="line">    // 对canvas设置padding区域</span><br><span class="line">    final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">    if (clipToPadding) &#123;</span><br><span class="line">        clipSaveCount = canvas.save();</span><br><span class="line">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我们将启动子View的动画，所以把这里的PFLAG_DRAW_ANIMATION置为off</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">    boolean more = false;</span><br><span class="line">    //获取绘图时开始的时间</span><br><span class="line">    final long drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">    if (usingRenderNodeProperties) canvas.insertReorderBarrier();</span><br><span class="line">    final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();</span><br><span class="line">    int transientIndex = transientCount != 0 ? 0 : -1;</span><br><span class="line">    // 如果启用硬件加速，那么就不支持view绘制优先级了，硬件内部会处理绘制的先后顺序</span><br><span class="line">    final ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties</span><br><span class="line">            ? null : buildOrderedChildList();</span><br><span class="line">    final boolean customOrder = preorderedList == null</span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    for (int i = 0; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        //绘制瞬态视图，</span><br><span class="line">        //目前瞬态视图的add方法是在两年前android M中加入进来的，目前还是@hide的，</span><br><span class="line">        //所以transientIndex是-1，所以这个while循环不会执行到，</span><br><span class="line">        //可能这段代码是google为以后的功能做的铺垫。</span><br><span class="line">        while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">            final View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">            if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != null) &#123;</span><br><span class="line">                more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            transientIndex++;</span><br><span class="line">            if (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                transientIndex = -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //按绘制顺序获取子View index</span><br><span class="line">        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        //通过index获取需要绘制的View，并执行drawChild方法</span><br><span class="line">        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;</span><br><span class="line">            //绘制子View，下面详细介绍</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //绘制瞬态View，略过，可能会在以后的某个版本中</span><br><span class="line">    while (transientIndex &gt;= 0) &#123;</span><br><span class="line">        // there may be additional transient views after the normal views</span><br><span class="line">        final View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">        if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                transientChild.getAnimation() != null) &#123;</span><br><span class="line">            more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">        transientIndex++;</span><br><span class="line">        if (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (preorderedList != null) preorderedList.clear();</span><br><span class="line"></span><br><span class="line">    // 绘制正在消失的View（还没结束动画）</span><br><span class="line">    if (mDisappearingChildren != null) &#123;</span><br><span class="line">        final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;</span><br><span class="line">        final int disappearingCount = disappearingChildren.size() - 1;</span><br><span class="line">        // Go backwards -- we may delete as animations finish</span><br><span class="line">        for (int i = disappearingCount; i &gt;= 0; i--) &#123;</span><br><span class="line">            final View child = disappearingChildren.get(i);</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (usingRenderNodeProperties) canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">    if (debugDraw()) &#123;</span><br><span class="line">        onDebugDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (clipToPadding) &#123;</span><br><span class="line">        canvas.restoreToCount(clipSaveCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果FLAG_INVALIDATE_REQUIRED是on，则调用invalidate刷新</span><br><span class="line">    flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) &#123;</span><br><span class="line">        invalidate(true);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //动画结束后发出通知，并擦除缓存</span><br><span class="line">    if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp;</span><br><span class="line">            mLayoutAnimationController.isDone() &amp;&amp; !more) &#123;</span><br><span class="line">        // We want to erase the drawing cache and notify the listener after the</span><br><span class="line">        // next frame is drawn because one extra invalidate() is caused by</span><br><span class="line">        // drawChild() after the animation is over</span><br><span class="line">        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;</span><br><span class="line">        final Runnable end = new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               notifyAnimationListener();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        post(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-draw-Canvas-canvas-ViewGroup-parent-long-drawingTime"><a href="#View-draw-Canvas-canvas-ViewGroup-parent-long-drawingTime" class="headerlink" title="View#draw(Canvas canvas, ViewGroup parent, long drawingTime)"></a>View#draw(Canvas canvas, ViewGroup parent, long drawingTime)</h2><p>这个方法是被ViewGroup调用，让子View来绘制自己的。该方法是View基于 layer type 以及硬件加速来专门处理渲染行为的代码段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line">boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123;</span><br><span class="line">    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();</span><br><span class="line">    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.</span><br><span class="line">     *</span><br><span class="line">     * If a view is dettached, its DisplayList shouldn&apos;t exist. If the canvas isn&apos;t</span><br><span class="line">     * HW accelerated, it can&apos;t handle drawing RenderNodes.</span><br><span class="line">     */</span><br><span class="line">    // 检测是否启动硬件加速</span><br><span class="line">    boolean drawingWithRenderNode = mAttachInfo != null</span><br><span class="line">            &amp;&amp; mAttachInfo.mHardwareAccelerated</span><br><span class="line">            &amp;&amp; hardwareAcceleratedCanvas;</span><br><span class="line"></span><br><span class="line">    boolean more = false;</span><br><span class="line">    final boolean childHasIdentityMatrix = hasIdentityMatrix();</span><br><span class="line">    final int parentFlags = parent.mGroupFlags;</span><br><span class="line"></span><br><span class="line">    if ((parentFlags &amp; ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) &#123;</span><br><span class="line">        parent.getChildTransformation().clear();</span><br><span class="line">        parent.mGroupFlags &amp;= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Transformation transformToApply = null;</span><br><span class="line">    boolean concatMatrix = false;</span><br><span class="line">    final boolean scalingRequired = mAttachInfo != null &amp;&amp; mAttachInfo.mScalingRequired;</span><br><span class="line">    final Animation a = getAnimation();</span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);</span><br><span class="line">        concatMatrix = a.willChangeTransformationMatrix();</span><br><span class="line">        if (concatMatrix) &#123;</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">        &#125;</span><br><span class="line">        transformToApply = parent.getChildTransformation();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ((mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) &#123;</span><br><span class="line">            // 不再执行动画，全部清除掉</span><br><span class="line">            mRenderNode.setAnimationMatrix(null);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!drawingWithRenderNode</span><br><span class="line">                &amp;&amp; (parentFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) &#123;</span><br><span class="line">            final Transformation t = parent.getChildTransformation();</span><br><span class="line">            final boolean hasTransform = parent.getChildStaticTransformation(this, t);</span><br><span class="line">            if (hasTransform) &#123;</span><br><span class="line">                final int transformType = t.getTransformationType();</span><br><span class="line">                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;</span><br><span class="line">                concatMatrix = (transformType &amp; Transformation.TYPE_MATRIX) != 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    concatMatrix |= !childHasIdentityMatrix;</span><br><span class="line"></span><br><span class="line">    // 尽早设置PFLAG_DRAWN参数，使invalidate()可以成功调用</span><br><span class="line">    mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    if (!concatMatrix &amp;&amp;</span><br><span class="line">            (parentFlags &amp; (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |</span><br><span class="line">                    ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &amp;&amp;</span><br><span class="line">            canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) &amp;&amp;</span><br><span class="line">            (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == 0) &#123;</span><br><span class="line">        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;</span><br><span class="line">        return more;</span><br><span class="line">    &#125;</span><br><span class="line">    mPrivateFlags2 &amp;= ~PFLAG2_VIEW_QUICK_REJECTED;</span><br><span class="line"></span><br><span class="line">    if (hardwareAcceleratedCanvas) &#123;</span><br><span class="line">        // 清楚PFLAG_INVALIDATED标志位</span><br><span class="line">        mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != 0;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_INVALIDATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RenderNode renderNode = null;</span><br><span class="line">    Bitmap cache = null;</span><br><span class="line">    int layerType = getLayerType(); // TODO: signify cache state with just &apos;cache&apos; local</span><br><span class="line">    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) &#123;</span><br><span class="line">         if (layerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">             // 如果没有RenderNode，则使用SW绘制</span><br><span class="line">             layerType = LAYER_TYPE_SOFTWARE;</span><br><span class="line">             buildDrawingCache(true);</span><br><span class="line">        &#125;</span><br><span class="line">        cache = getDrawingCache(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (drawingWithRenderNode) &#123;</span><br><span class="line">        // 延迟获取Display List，直到animation-driven alpha的值被设置好。</span><br><span class="line">        renderNode = updateDisplayListIfDirty();</span><br><span class="line">        if (!renderNode.isValid()) &#123;</span><br><span class="line">            // 不常见的，略过</span><br><span class="line">            renderNode = null;</span><br><span class="line">            drawingWithRenderNode = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //下面是对view当前状态的分析，scale、alpha和translate，然后对canvas进行调整。</span><br><span class="line">    int sx = 0;</span><br><span class="line">    int sy = 0;</span><br><span class="line">    if (!drawingWithRenderNode) &#123;</span><br><span class="line">        computeScroll();</span><br><span class="line">        sx = mScrollX;</span><br><span class="line">        sy = mScrollY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final boolean drawingWithDrawingCache = cache != null &amp;&amp; !drawingWithRenderNode;</span><br><span class="line">    final boolean offsetForScroll = cache == null &amp;&amp; !drawingWithRenderNode;</span><br><span class="line"></span><br><span class="line">    int restoreTo = -1;</span><br><span class="line">    if (!drawingWithRenderNode || transformToApply != null) &#123;</span><br><span class="line">        restoreTo = canvas.save();</span><br><span class="line">    &#125;</span><br><span class="line">    if (offsetForScroll) &#123;</span><br><span class="line">        canvas.translate(mLeft - sx, mTop - sy);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!drawingWithRenderNode) &#123;</span><br><span class="line">            canvas.translate(mLeft, mTop);</span><br><span class="line">        &#125;</span><br><span class="line">        if (scalingRequired) &#123;</span><br><span class="line">            if (drawingWithRenderNode) &#123;</span><br><span class="line">                // TODO: Might not need this if we put everything inside the DL</span><br><span class="line">                restoreTo = canvas.save();</span><br><span class="line">            &#125;</span><br><span class="line">            // mAttachInfo cannot be null, otherwise scalingRequired == false</span><br><span class="line">            final float scale = 1.0f / mAttachInfo.mApplicationScale;</span><br><span class="line">            canvas.scale(scale, scale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());</span><br><span class="line">    if (transformToApply != null</span><br><span class="line">            || alpha &lt; 1</span><br><span class="line">            || !hasIdentityMatrix()</span><br><span class="line">            || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) &#123;</span><br><span class="line">        if (transformToApply != null || !childHasIdentityMatrix) &#123;</span><br><span class="line">            int transX = 0;</span><br><span class="line">            int transY = 0;</span><br><span class="line"></span><br><span class="line">            if (offsetForScroll) &#123;</span><br><span class="line">                transX = -sx;</span><br><span class="line">                transY = -sy;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (transformToApply != null) &#123;</span><br><span class="line">                if (concatMatrix) &#123;</span><br><span class="line">                    if (drawingWithRenderNode) &#123;</span><br><span class="line">                        renderNode.setAnimationMatrix(transformToApply.getMatrix());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Undo the scroll translation, apply the transformation matrix,</span><br><span class="line">                        // then redo the scroll translate to get the correct result.</span><br><span class="line">                        canvas.translate(-transX, -transY);</span><br><span class="line">                        canvas.concat(transformToApply.getMatrix());</span><br><span class="line">                        canvas.translate(transX, transY);</span><br><span class="line">                    &#125;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                float transformAlpha = transformToApply.getAlpha();</span><br><span class="line">                if (transformAlpha &lt; 1) &#123;</span><br><span class="line">                    alpha *= transformAlpha;</span><br><span class="line">                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!childHasIdentityMatrix &amp;&amp; !drawingWithRenderNode) &#123;</span><br><span class="line">                canvas.translate(-transX, -transY);</span><br><span class="line">                canvas.concat(getMatrix());</span><br><span class="line">                canvas.translate(transX, transY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Deal with alpha if it is or used to be &lt;1</span><br><span class="line">        if (alpha &lt; 1 || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) &#123;</span><br><span class="line">            if (alpha &lt; 1) &#123;</span><br><span class="line">                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;</span><br><span class="line">            &#125;</span><br><span class="line">            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;</span><br><span class="line">            if (!drawingWithDrawingCache) &#123;</span><br><span class="line">                final int multipliedAlpha = (int) (255 * alpha);</span><br><span class="line">                if (!onSetAlpha(multipliedAlpha)) &#123;</span><br><span class="line">                    if (drawingWithRenderNode) &#123;</span><br><span class="line">                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());</span><br><span class="line">                    &#125; else if (layerType == LAYER_TYPE_NONE) &#123;</span><br><span class="line">                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(),</span><br><span class="line">                                multipliedAlpha);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Alpha is handled by the child directly, clobber the layer&apos;s alpha</span><br><span class="line">                    mPrivateFlags |= PFLAG_ALPHA_SET;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if ((mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) &#123;</span><br><span class="line">        onSetAlpha(255);</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_ALPHA_SET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!drawingWithRenderNode) &#123;</span><br><span class="line">        // apply clips directly, since RenderNode won&apos;t do it for this draw</span><br><span class="line">        if ((parentFlags &amp; ViewGroup.FLAG_CLIP_CHILDREN) != 0 &amp;&amp; cache == null) &#123;</span><br><span class="line">            if (offsetForScroll) &#123;</span><br><span class="line">                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!scalingRequired || cache == null) &#123;</span><br><span class="line">                    canvas.clipRect(0, 0, getWidth(), getHeight());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mClipBounds != null) &#123;</span><br><span class="line">            // clip bounds ignore scroll</span><br><span class="line">            canvas.clipRect(mClipBounds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 这里调用子View的draw方法，并将调整好的canvas传进去</span><br><span class="line">    if (!drawingWithDrawingCache) &#123;</span><br><span class="line">        if (drawingWithRenderNode) &#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Fast path for layouts with no backgrounds</span><br><span class="line">            if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">                dispatchDraw(canvas);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                draw(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    // 如果是cache模式，则利用cache</span><br><span class="line">    else if (cache != null) &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) &#123;</span><br><span class="line">            // no layer paint, use temporary paint to draw bitmap</span><br><span class="line">            Paint cachePaint = parent.mCachePaint;</span><br><span class="line">            if (cachePaint == null) &#123;</span><br><span class="line">                cachePaint = new Paint();</span><br><span class="line">                cachePaint.setDither(false);</span><br><span class="line">                parent.mCachePaint = cachePaint;</span><br><span class="line">            &#125;</span><br><span class="line">            cachePaint.setAlpha((int) (alpha * 255));</span><br><span class="line">            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // use layer paint to draw the bitmap, merging the two alphas, but also restore</span><br><span class="line">            int layerPaintAlpha = mLayerPaint.getAlpha();</span><br><span class="line">            if (alpha &lt; 1) &#123;</span><br><span class="line">                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);</span><br><span class="line">            if (alpha &lt; 1) &#123;</span><br><span class="line">                mLayerPaint.setAlpha(layerPaintAlpha);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (restoreTo &gt;= 0) &#123;</span><br><span class="line">        canvas.restoreToCount(restoreTo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (a != null &amp;&amp; !more) &#123;</span><br><span class="line">        if (!hardwareAcceleratedCanvas &amp;&amp; !a.getFillAfter()) &#123;</span><br><span class="line">            onSetAlpha(255);</span><br><span class="line">        &#125;</span><br><span class="line">        parent.finishAnimatingView(this, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (more &amp;&amp; hardwareAcceleratedCanvas) &#123;</span><br><span class="line">        if (a.hasAlpha() &amp;&amp; (mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) &#123;</span><br><span class="line">            // alpha animations should cause the child to recreate its display list</span><br><span class="line">            invalidate(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mRecreateDisplayList = false;</span><br><span class="line"></span><br><span class="line">    return more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，整个View及子View的绘制的调用就基本完成了，剩下的就交给各个View的onDraw方法去实现不同的绘制。</p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="http://ogsbxb571.bkt.clouddn.com/onDraw%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="图为View绘制时序图"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>View的绘制大体是6步来进行。  </p>
<ol>
<li>绘制背景  </li>
<li>保存fade canvas信息  </li>
<li>调用onDraw  </li>
<li>dispatchDraw，遍历绘制子View  </li>
<li>绘制fade  </li>
<li>绘制前景</li>
</ol>
<p>源码中还有不少涉及到硬件加速、RenderNode、display list、动画的代码，后续会专门进行研究。</p>
<p>到这篇文章截止，View视图三部曲就结束了，感谢阅读。</p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="http://blog.spinytech.com/2016/12/02/android_view_draw_setcontentview/">Android 视图及View绘制分析笔记之setContentView</a><br><a href="http://blog.spinytech.com/2016/12/12/android_view_on_measure/">View绘制分析笔记之onMeasure</a><br><a href="http://blog.spinytech.com/2016/12/15/android_view_on_layout/">View绘制分析笔记之onLayout</a><br><a href="http://blog.spinytech.com/2016/12/19/android_view_on_draw/">View绘制分析笔记之onDraw</a>  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#x73;&#x70;&#x69;&#110;&#x79;&#46;&#x74;&#101;&#99;&#x68;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;">&#x73;&#x70;&#x69;&#110;&#x79;&#46;&#x74;&#101;&#99;&#x68;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我们了解了View的onLayout，那么今天我们来学习Android View绘制三部曲的最后一步，onDraw，绘制。  &lt;/p&gt;
&lt;h2 id=&quot;ViewRootImpl-performDraw&quot;&gt;&lt;a href=&quot;#ViewRootImpl-perform
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="View绘制" scheme="http://blog.spinytech.com/tags/View%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>View绘制分析笔记之onLayout</title>
    <link href="http://blog.spinytech.com/2016/12/15/android_view_on_layout/"/>
    <id>http://blog.spinytech.com/2016/12/15/android_view_on_layout/</id>
    <published>2016-12-15T12:00:00.000Z</published>
    <updated>2016-12-22T03:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章我们了解了View的onMeasure，那么今天我们继续来学习Android View绘制三部曲的第二步，onLayout，布局。  </p>
<h2 id="ViewRootImpl-performLayout"><a href="#ViewRootImpl-performLayout" class="headerlink" title="ViewRootImpl#performLayout"></a>ViewRootImpl#performLayout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">        int desiredWindowHeight) &#123;</span><br><span class="line">    mLayoutRequested = false;</span><br><span class="line">    mScrollMayChange = true;</span><br><span class="line">    mInLayout = true;</span><br><span class="line"></span><br><span class="line">    final View host = mView;</span><br><span class="line">    if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, &quot;Laying out &quot; + host + &quot; to (&quot; +</span><br><span class="line">                host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout = false;</span><br><span class="line">        //此处省略的代码是在layout的过程中，重复的requestLayout，需要做的处理。</span><br><span class="line">        //具体的处理方案是重新measure，layout。</span><br><span class="line">        ...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要的作用就是调用了host.layout，并把已经测绘好的宽高传计算成上下左右递过去，host就是decorView。</p>
<h2 id="View-layout"><a href="#View-layout" class="headerlink" title="View#layout"></a>View#layout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">    //根据mPrivateFlags3标记位状态判断，如果需要，则重新measure。</span><br><span class="line">    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int oldL = mLeft;</span><br><span class="line">    int oldT = mTop;</span><br><span class="line">    int oldB = mBottom;</span><br><span class="line">    int oldR = mRight;</span><br><span class="line">    </span><br><span class="line">    //检查是位置有变化，并setFrame</span><br><span class="line">    //setFrame分析见下文</span><br><span class="line">    boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">            </span><br><span class="line">    //如果位置有变化或者PFLAG_LAYOUT_REQUIRED标记位为on，则进行onLayout</span><br><span class="line">    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        //把PFLAG_LAYOUT_REQUIRED标记位置为off</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        </span><br><span class="line">        //进行onLayoutChange回调</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            int numListeners = listenersCopy.size();</span><br><span class="line">            for (int i = 0; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将PFLAG_FORCE_LAYOUT标记置为off，将PFLAG3_IS_LAID_OUT置为on</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-setFrame"><a href="#View-setFrame" class="headerlink" title="View#setFrame"></a>View#setFrame</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">protected boolean setFrame(int left, int top, int right, int bottom) &#123;</span><br><span class="line">    boolean changed = false;</span><br><span class="line"></span><br><span class="line">    if (DBG) &#123;</span><br><span class="line">        Log.d(&quot;View&quot;, this + &quot; View.setFrame(&quot; + left + &quot;,&quot; + top + &quot;,&quot;</span><br><span class="line">                + right + &quot;,&quot; + bottom + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果上下左右任意一项有改动，则继续往下进行，否则直接返回false</span><br><span class="line">    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        changed = true;</span><br><span class="line"></span><br><span class="line">        //记录PFLAG_DRAWN位状态，最后复原的时候需要</span><br><span class="line">        int drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        int oldWidth = mRight - mLeft;</span><br><span class="line">        int oldHeight = mBottom - mTop;</span><br><span class="line">        int newWidth = right - left;</span><br><span class="line">        int newHeight = bottom - top;</span><br><span class="line">        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        //刷新原有布局，invalidate方法将在另一篇文章中详细展开。</span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">        //设置该View的上下左右，也是setFrame的核心功能</span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line">        //PFLAG_HAS_BOUNDS位置为on</span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        //如果尺寸有改变，调用onSizeChange并且调用rebuildOutline</span><br><span class="line">        if (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) &#123;</span><br><span class="line">            // If we are visible, force the DRAWN bit to on so that</span><br><span class="line">            // this invalidate will go through (at least to our parent).</span><br><span class="line">            // This is because someone may have invalidated this view</span><br><span class="line">            // before this call to setFrame came in, thereby clearing</span><br><span class="line">            // the DRAWN bit.</span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            // parent display list may need to be recreated based on a change in the bounds</span><br><span class="line">            // of any child</span><br><span class="line">            invalidateParentCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 把PFLAG_DRAWN设置为原有数值。（invalidate过程中会将其设为off）</span><br><span class="line">        mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">        mBackgroundSizeChanged = true;</span><br><span class="line">        if (mForegroundInfo != null) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //Android无障碍辅助通知</span><br><span class="line">        notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    return changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FrameLayout-onLayout"><a href="#FrameLayout-onLayout" class="headerlink" title="FrameLayout#onLayout"></a>FrameLayout#onLayout</h2><p>如果是View的话，执行完layout方法，那么他已经布局完成，不过如果是ViewGroup，那么它需要对它的子View进行处理。onLayout主要的作用就是调用layoutChildren，对子View进行布局，所以这里着重介绍layoutChildren。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, false /* no force left gravity */);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line"></span><br><span class="line">    //计算parent的上下左右</span><br><span class="line">    final int parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    final int parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    final int parentTop = getPaddingTopWithForeground();</span><br><span class="line">    final int parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child = getChildAt(i);</span><br><span class="line">        if (child.getVisibility() != GONE) &#123;</span><br><span class="line">            final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int width = child.getMeasuredWidth();</span><br><span class="line">            final int height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            int childLeft;</span><br><span class="line">            int childTop;</span><br><span class="line"></span><br><span class="line">            int gravity = lp.gravity;</span><br><span class="line">            if (gravity == -1) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取layout默认方向，通常是从左到右，在某些特定语言的情况下是从右到左</span><br><span class="line">            final int layoutDirection = getLayoutDirection();</span><br><span class="line">            //通过刚才的方向值，计算出绝对的横向位置属性</span><br><span class="line">            final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            //计算竖向位置属性</span><br><span class="line">            final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            //通过位置属性，计算子View的left和right</span><br><span class="line">            switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.RIGHT:</span><br><span class="line">                    if (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                case Gravity.LEFT:</span><br><span class="line">                default:</span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //通过位置属性，计算子View的top和bottom</span><br><span class="line">            switch (verticalGravity) &#123;</span><br><span class="line">                case Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / 2 +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                case Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //调用子View的layout方法</span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="http://ogsbxb571.bkt.clouddn.com/onLayout%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="图为View layout 时序图"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里就介绍完了View绘制的layout方法。比起measure，layout可是简单多了。不过这里还预留了一些坑，没有交代清楚，比如invalidate，还有RenderNode硬件加速等，以后会写一些笔记专门针对这些知识点做梳理。</p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="http://blog.spinytech.com/2016/12/02/android_view_draw_setcontentview/">Android 视图及View绘制分析笔记之setContentView</a><br><a href="http://blog.spinytech.com/2016/12/12/android_view_on_measure/">View绘制分析笔记之onMeasure</a><br><a href="http://blog.spinytech.com/2016/12/15/android_view_on_layout/">View绘制分析笔记之onLayout</a><br><a href="http://blog.spinytech.com/2016/12/19/android_view_on_draw/">View绘制分析笔记之onDraw</a>  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#115;&#x70;&#105;&#x6e;&#x79;&#x2e;&#x74;&#x65;&#99;&#x68;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#115;&#x70;&#105;&#x6e;&#x79;&#x2e;&#x74;&#x65;&#99;&#x68;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#x6f;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章我们了解了View的onMeasure，那么今天我们继续来学习Android View绘制三部曲的第二步，onLayout，布局。  &lt;/p&gt;
&lt;h2 id=&quot;ViewRootImpl-performLayout&quot;&gt;&lt;a href=&quot;#ViewRootImpl-p
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="View绘制" scheme="http://blog.spinytech.com/tags/View%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>View绘制分析笔记之onMeasure</title>
    <link href="http://blog.spinytech.com/2016/12/12/android_view_on_measure/"/>
    <id>http://blog.spinytech.com/2016/12/12/android_view_on_measure/</id>
    <published>2016-12-12T12:00:00.000Z</published>
    <updated>2016-12-22T03:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要学习记录一下Android View绘制三部曲的第一步，onMeasure，测量。  </p>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>在Activity中，所有的View都是DecorView的子View，然后DecorView又是被ViewRootImpl所控制，当Activity显示的时候，ViewRootImpl的<code>performTranversals</code>方法开始运行，这个方法很长，不过核心的三个流程就是依次调用performMeasure、performLayout、performDraw三个方法，从而完成DecorView的绘制。</p>
<h2 id="ViewRootImpl-performMeasure"><a href="#ViewRootImpl-performMeasure" class="headerlink" title="ViewRootImpl#performMeasure"></a>ViewRootImpl#performMeasure</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接调用了mView的<code>measure</code>方法，参数是两个经过设置的MeasureSpec，接下来我们分析一下MeasureSpec是如何设置的。</p>
<h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><p>这个MeasureSpec不是实际测绘值，而是父View传递给子View的布局要求，MeasureSpec涵盖了对子View大小和模式的要求。其中，三种模式要求分别是：  </p>
<ul>
<li>UNSPECIFIED：对子View无任何要求，想要测绘多少由子View决定。  </li>
<li>EXACTLY：父View已确定了自己确切的大小。子View将在这个边界内测绘自己的宽高。  </li>
<li>AT_MOST：父View对子View没有要求，子View可以达到它想要的大小。  </li>
</ul>
<p>首先这个MeasureSpec是个32位的int值，其中31，32两位代表的是三种模式的要求，分别是00….、01….、11….，<code>makeMeasureSpec</code>方法中，sUseBrokenMakeMeasureSpec默认是false，所以一般执行(size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK)这个语句，这个意思就是说，MeasureSpec的高两位代表的是模式，低30位代表父View的尺寸。<br>下面是对应的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static final int MODE_SHIFT = 30;</span><br><span class="line">private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;</span><br><span class="line">public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,</span><br><span class="line">                                      @MeasureSpecMode int mode) &#123;</span><br><span class="line">    if (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        return size + mode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-measure"><a href="#View-measure" class="headerlink" title="View#measure"></a>View#measure</h2><p>计算完MeasureSpec，DecorView就该执行<code>measure</code>方法了。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    ···</span><br><span class="line">    final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line">    ···</span><br><span class="line">    final boolean needsLayout = specChanged</span><br><span class="line">            &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize);</span><br><span class="line"></span><br><span class="line">    if (forceLayout || needsLayout) &#123;</span><br><span class="line">        ···</span><br><span class="line">        int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key);</span><br><span class="line">        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</span><br><span class="line">            // measure ourselves, this should set the measured dimension flag back</span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ···</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">        &#125;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>measure方法是final的，所以不能重写，不过measure方法最主要的作用就是调用了onMeasure方法，由于DecorView是继承的FrameLayout，所以本篇文章我们主要分析FrameLayout的onMeasure方法。</p>
<h2 id="FrameLayout-onMeasure"><a href="#FrameLayout-onMeasure" class="headerlink" title="FrameLayout#onMeasure"></a>FrameLayout#onMeasure</h2><p>这个onMeasure方法，可能是View绘制中最难理解的了，所以我们逐步分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">    //获取子View个数</span><br><span class="line">    int count = getChildCount();</span><br><span class="line">    </span><br><span class="line">    //判断是否是确定宽高的</span><br><span class="line">    //如果宽高都确定，那么boolean为false</span><br><span class="line">    //如果有一个不确定，那么boolean为true</span><br><span class="line">    final boolean measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    int maxHeight = 0;</span><br><span class="line">    int maxWidth = 0;</span><br><span class="line">    int childState = 0;</span><br><span class="line">    </span><br><span class="line">    //遍历所有不为GONE的子View，并加以计算</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child = getChildAt(i);</span><br><span class="line">        if (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            //计算各个子View宽高，包括Margin参数以及padding参数</span><br><span class="line">            //该方法详细分析见下文</span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);</span><br><span class="line">            final LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            //用按位或的方法合并所有子View的State</span><br><span class="line">            //getMeasuredState方法详细解析在下面</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            //如果宽高有不确定的（即warp_content模式），将子View中宽或高是match_parent的添加到mMatchParentChildren中。</span><br><span class="line">            if (measureMatchParentChildren) &#123;</span><br><span class="line">                if (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算padding</span><br><span class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    // 与最小宽高作比较，二者取较大的</span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    // 与前景图宽高作比较，二者取较大的</span><br><span class="line">    final Drawable drawable = getForeground();</span><br><span class="line">    if (drawable != null) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //计算并保存measured宽高</span><br><span class="line">    //resolveSizeAndState方法分析在下面</span><br><span class="line">    //setMeasuredDimension方法分析在下面</span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">                    </span><br><span class="line">    //计算macth_parent的子View的个数</span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    //只有FrameLayout中宽或者高有warp_content属性，</span><br><span class="line">    //并且match_parent的子view个数大于1才会执行下面代码。</span><br><span class="line">    //因为如果宽高都是match_parent的，或者设置好dp数值的，则mMatchParentChildren永远是空的。</span><br><span class="line">    </span><br><span class="line">    //在这里会重新计算传递给子View的MeasureSpec值，并重新测绘子View。</span><br><span class="line">    //关于MeasureSpec值的计算，可以参考下文ViewGroup#getChildMeasureSpec的表格。</span><br><span class="line">    //这里需要注意的是，match_parent行所有的结果均改为：EXACTLY + parentSize</span><br><span class="line">    if (count &gt; 1) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child = mMatchParentChildren.get(i);</span><br><span class="line">            final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            final int childWidthMeasureSpec;</span><br><span class="line">            if (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                final int width = Math.max(0, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final int childHeightMeasureSpec;</span><br><span class="line">            if (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                final int height = Math.max(0, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewGroup-measureChildWithMargins"><a href="#ViewGroup-measureChildWithMargins" class="headerlink" title="ViewGroup#measureChildWithMargins"></a>ViewGroup#measureChildWithMargins</h2><p>该方法作用是测绘子View，在父View的onMeasure中循环调用，达到遍历的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">        int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">        int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">    //获取子View的LayoutParams</span><br><span class="line">    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    </span><br><span class="line">    //计算子View的MeasureSpec</span><br><span class="line">    //getChildMeasureSpec方法分析见下文</span><br><span class="line">    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">    //调用子View的measure方法，对子View进行测绘</span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ViewGroup-getChildMeasureSpec"><a href="#ViewGroup-getChildMeasureSpec" class="headerlink" title="ViewGroup#getChildMeasureSpec"></a>ViewGroup#getChildMeasureSpec</h2><p>此方法通过父View的MeasureSpec值以及LayoutParams的宽高，来生成子View的MeasureSpec值，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">    //计算父View的size和mode</span><br><span class="line">    int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    int specSize = MeasureSpec.getSize(spec);</span><br><span class="line">    </span><br><span class="line">    //计算刨除padding的size</span><br><span class="line">    int size = Math.max(0, specSize - padding);</span><br><span class="line"></span><br><span class="line">    int resultSize = 0;</span><br><span class="line">    int resultMode = 0;</span><br><span class="line"></span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">    // Parent has imposed an exact size on us</span><br><span class="line">    case MeasureSpec.EXACTLY:</span><br><span class="line"></span><br><span class="line">        if (childDimension &gt;= 0) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            // Child wants to be our size. So be it.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">            // bigger than us.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    // Parent has imposed a maximum size on us</span><br><span class="line">    case MeasureSpec.AT_MOST:</span><br><span class="line">        if (childDimension &gt;= 0) &#123;</span><br><span class="line">            // Child wants a specific size... so be it</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            // Child wants to be our size, but our size is not fixed.</span><br><span class="line">            // Constrain child to not be bigger than us.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">            // bigger than us.</span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    // Parent asked to see how big we want to be</span><br><span class="line">    case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        if (childDimension &gt;= 0) &#123;</span><br><span class="line">            // Child wants a specific size... let him have it</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            // Child wants to be our size... find out how big it should</span><br><span class="line">            // be</span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            // Child wants to determine its own size.... find out how</span><br><span class="line">            // big it should be</span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    //noinspection ResourceType</span><br><span class="line">    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，其实通过一张表格，就能很清楚的解释转换规律  </p>
<table>
<thead>
<tr>
<th>竖列代表LayoutParams的宽或高属性\横行父View传递的Mode</th>
<th>EXACTLY</th>
<th>AT_MOST</th>
<th>UNSPECIFIED</th>
</tr>
</thead>
<tbody>
<tr>
<td>精确值</td>
<td>EXACTLY + childSize</td>
<td>EXACTLY + childSize</td>
<td>EXACTLY + childSize</td>
</tr>
<tr>
<td>match_parent</td>
<td>EXACTLY + parentSize</td>
<td>AT_MOST + parentSize</td>
<td>UNSPECIFIED + parentSize</td>
</tr>
<tr>
<td>warp_content</td>
<td>AT_MOST  + parentSize</td>
<td>AT_MOST  + parentSize</td>
<td>UNSPECIFIED + parentSize</td>
</tr>
</tbody>
</table>
<h2 id="View-getMeasuredState"><a href="#View-getMeasuredState" class="headerlink" title="View#getMeasuredState"></a>View#getMeasuredState</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final int getMeasuredState() &#123;</span><br><span class="line">    return (mMeasuredWidth&amp;MEASURED_STATE_MASK)</span><br><span class="line">            | ((mMeasuredHeight&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT)</span><br><span class="line">                    &amp; (MEASURED_STATE_MASK&gt;&gt;MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法返回一个表达View宽高measure_state值的整数，第8位代表height是否是MEASURED_STATE_TOO_SMALL，第24为代表width是否是MEASURED_STATE_TOO_SMALL的。<br>例如：<br>宽是MEASURED_STATE_TOO_SMALL的<br>返回:0000 0001 0000 0000 0000 0000 0000 0000<br>高是MEASURED_STATE_TOO_SMALL的<br>返回:0000 0000 0000 0000 0000 0001 0000 0000<br>宽高均是MEASURED_STATE_TOO_SMALL的<br>返回:0000 0001 0000 0000 0000 0001 0000 0000  </p>
<h2 id="View-resolveSizeAndState"><a href="#View-resolveSizeAndState" class="headerlink" title="View#resolveSizeAndState"></a>View#resolveSizeAndState</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static final int MEASURED_STATE_TOO_SMALL = 0x01000000;</span><br><span class="line">public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123;</span><br><span class="line">    //计算父view传递的size和mode</span><br><span class="line">    final int specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    final int specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line">    final int result;</span><br><span class="line">    switch (specMode) &#123;</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (specSize &lt; size) &#123;</span><br><span class="line">                //如果父View给的size小于自身测绘出的size，</span><br><span class="line">                //则在第24位上加上measure_state标记。</span><br><span class="line">                result = specSize | MEASURED_STATE_TOO_SMALL;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result = size;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            break;</span><br><span class="line">        case MeasureSpec.UNSPECIFIED:</span><br><span class="line">        default:</span><br><span class="line">            result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果child在第24为上有measure_state标记，则在result的第24位上也加上measure_state标记，然后返回result。</span><br><span class="line">    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-setMeasuredDimension"><a href="#View-setMeasuredDimension" class="headerlink" title="View#setMeasuredDimension"></a>View#setMeasuredDimension</h2><p>该方法将计算好的measuredWidth和measuredHeight设置给成员变量mMeasuredWidth及mMeasuredHeight，并且将flag设置成PFLAG_MEASURED_DIMENSION_SET。<br>在4.3版本以上，如果设置了optical模式，则还要对width、height进一步修改，然后再设置mMeasuredWidth、mMeasuredHeight。<br>mMeasuredWidth和mMeasuredHeight的值，不光包括size，同时还包括state，具体请看<code>getMeasuredWidth</code>、<code>getMeasuredWidthAndState</code>、<code>getMeasuredHeight</code>、<code>getMeasuredHeightAndState</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    boolean optical = isLayoutModeOptical(this);</span><br><span class="line">    if (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        int opticalWidth  = insets.left + insets.right;</span><br><span class="line">        int opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="http://ogsbxb571.bkt.clouddn.com/onMeasure%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="图为onMeasure时序图"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，关于View的测绘我们大概的走了一遍。Measure的原理就是通过遍历，从上至下，利用传递的MeasureSpec以及子View的LayoutParams，依次进行测绘。不同的layout可能会进行多次的measure，所以熟读源码，合理布局，可以帮我们避免不必要的measure开销，达到提升性能的效果。  </p>
<p>最后，感谢阅读，也希望可以和大家多多交流，共同进步。</p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="http://blog.spinytech.com/2016/12/02/android_view_draw_setcontentview/">Android 视图及View绘制分析笔记之setContentView</a><br><a href="http://blog.spinytech.com/2016/12/12/android_view_on_measure/">View绘制分析笔记之onMeasure</a><br><a href="http://blog.spinytech.com/2016/12/15/android_view_on_layout/">View绘制分析笔记之onLayout</a><br><a href="http://blog.spinytech.com/2016/12/19/android_view_on_draw/">View绘制分析笔记之onDraw</a>  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#115;&#x70;&#105;&#110;&#x79;&#46;&#116;&#x65;&#x63;&#x68;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#115;&#x70;&#105;&#110;&#x79;&#46;&#116;&#x65;&#x63;&#x68;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要学习记录一下Android View绘制三部曲的第一步，onMeasure，测量。  &lt;/p&gt;
&lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;在Activity中，所有的V
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="View绘制" scheme="http://blog.spinytech.com/tags/View%E7%BB%98%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android 视图及View绘制分析笔记之setContentView</title>
    <link href="http://blog.spinytech.com/2016/12/02/android_view_draw_setcontentview/"/>
    <id>http://blog.spinytech.com/2016/12/02/android_view_draw_setcontentview/</id>
    <published>2016-12-02T12:00:00.000Z</published>
    <updated>2016-12-22T03:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从1983年第一台图形用户界面的个人电脑问世以来，几乎所有的PC操作系统都支持可视化操作，Android也不例外。对于所有Android Developer来说，我们接触最多的控件就是View。通常，我们使用自定义View，需要了解最多的除了事件分发，就是View的绘制过程。然而关于View的绘制，涉及到的知识点纷繁复杂，这么多的代码知识，要梳理起来，肯定是先要找个头。那么平常我们用的最多的方法是哪个方法呢？当然是<code>setContentView()</code>！</p>
<h1 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h1><p>首先我们直接在Android Studio中找到一个Activity（请注意，本文分析的是Activity，如果你看的是AppCompatActivity，实际代码会有出入），然后找到setContent方法然后点进去，我们可以看到  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后查找<code>getWindow()</code>方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Window mWindow;</span><br><span class="line">public Window getWindow() &#123;</span><br><span class="line">    return mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得知调用的是Window类的setContent()方法。然后再全类搜索mWindow，在attach方法中找到了赋值语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, int ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window) &#123;</span><br><span class="line">    ···</span><br><span class="line">    mWindow = new PhoneWindow(this, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(this);</span><br><span class="line">    mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    if (info.uiOptions != 0) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);</span><br><span class="line">    if (mParent != null) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就引出了我们今天主要分析的对象PhoneWindow。 </p>
<h1 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h1><p>查找PhoneWindow的setContentView方法，可以看到有三个重载方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view) &#123;</span><br><span class="line">    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        view.setLayoutParams(params);</span><br><span class="line">        final Scene newScene = new Scene(mContentParent, view);</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mContentParent.addView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个方法大体的处理流程是：  </p>
<ol>
<li>初始化DecorView  </li>
<li>检查并处理转场动画  </li>
<li>将实际要显示的Layout或者View添加到mContentParent中  </li>
<li>通知Callback(即Activity)调用onContentChanged方法  </li>
</ol>
<h1 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h1><p>在上面的流程里面，相对比较重要的就是第一步的初始化DecorView，也就是<code>installDecor()</code>方法，下面我们继续分析这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">    ···</span><br><span class="line">    if (mDecor == null) &#123;</span><br><span class="line">        mDecor = generateDecor(-1);</span><br><span class="line">        ···</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mDecor.setWindow(this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>installDecor()</code>方法里，主要做的就是两件事，一个是generateDecor，生成mDecor，还有一个是generateLayout，生成mContentParent。generateDecor中，没有太多复杂逻辑，就是做一些判断，然后实例化出来一个DecorView，这里需要说一点的就是在Android7.0以前，DecorView是PhoneWindow的内部类，7.0以后，DecorView单独提出来变成了一个类，所以如果有用到反射的话，这里可能会出现问题，需要做好版本判断。然后我们看下generateLayout的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">    //通过系统获取样式</span><br><span class="line">    TypedArray a = getWindowStyle();</span><br><span class="line">    //然后一系列的判断，获取样式里的属性，然后设置features</span><br><span class="line">    //例如是否悬浮，是否有Title等等</span><br><span class="line">    ···</span><br><span class="line">    int layoutResource;</span><br><span class="line">    int features = getLocalFeatures();</span><br><span class="line">    //拿到刚才设置的features，作出一系列if eles判断，找出对应的resourceId</span><br><span class="line">    //然后调用DecorView的onResourcesLoaded，对这个layout进行inflate</span><br><span class="line">    ···</span><br><span class="line">    mDecor.startChanging();</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">    //通过com.android.internal.R.id.content找到对应的mContentParent</span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    if (contentParent == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //在经过一系列后续设置</span><br><span class="line">    ···</span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line">    //最后返回contentParent</span><br><span class="line">    return contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在generateLayout中，大概的流程是这样的。  </p>
<ol>
<li>先获取样式  </li>
<li>设置样式到Window的features里  </li>
<li>拿到features，判断对应的resourceId  </li>
<li>通过resourceId，inflate出来一个ViewGroup，添加到mDecor中</li>
<li>再通过findViewById，找到刚刚inflate的ViewGroup中的  com.android.internal.R.id.content，作为mContentParent</li>
<li>在经过一系列设置  </li>
<li>返回contentParent  </li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此，我们的setContentView就已经基本走完了，剩下的就等着Activity、WindowManager、WindowManagerGlobal、ViewRootImpl去调用了，这些类的调用，涉及到了Activity的启动流程，我们会在其他笔记中详细分析这一过程。  </p>
<p>下面会上一张整个setContentView的时序图，用来巩固一下刚才的流程。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/setContent%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="上图为Android setContentView的时序图"></p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="http://blog.spinytech.com/2016/12/02/android_view_draw_setcontentview/">Android 视图及View绘制分析笔记之setContentView</a><br><a href="http://blog.spinytech.com/2016/12/12/android_view_on_measure/">View绘制分析笔记之onMeasure</a><br><a href="http://blog.spinytech.com/2016/12/15/android_view_on_layout/">View绘制分析笔记之onLayout</a><br><a href="http://blog.spinytech.com/2016/12/19/android_view_on_draw/">View绘制分析笔记之onDraw</a>  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#115;&#112;&#105;&#x6e;&#121;&#x2e;&#116;&#x65;&#x63;&#104;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#115;&#112;&#105;&#x6e;&#121;&#x2e;&#116;&#x65;&#x63;&#104;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从1983年第一台图形用户界面的个人电脑问世以来，几乎所有的PC操作系统都支持可视化操作，Android也不例外。对于所有Android Developer来说，我们接触最多的控件就是View。通常，我们使用自定义View，需要了解最多的除了事件分发，就是View的绘制过
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="View绘制" scheme="http://blog.spinytech.com/tags/View%E7%BB%98%E5%88%B6/"/>
    
      <category term="Android视图" scheme="http://blog.spinytech.com/tags/Android%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程注意事项</title>
    <link href="http://blog.spinytech.com/2016/11/20/android_multiple_process_notice/"/>
    <id>http://blog.spinytech.com/2016/11/20/android_multiple_process_notice/</id>
    <published>2016-11-20T12:00:00.000Z</published>
    <updated>2016-11-24T10:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/">《Android多进程使用场景》</a>中，我们分析了一下多进程的使用场景，今天这篇文章，我们来聊聊Android多进程开发过程中可能会遇到的问题。</p>
<h3 id="多虚拟机潜在的问题"><a href="#多虚拟机潜在的问题" class="headerlink" title="多虚拟机潜在的问题"></a>多虚拟机潜在的问题</h3><p>由于每个进程创建以后，都会拥有独立的空间，独立的VM，所以，很多Java特性都会在多进程开发中失效。</p>
<h4 id="1-静态变量和单例模式完全失效"><a href="#1-静态变量和单例模式完全失效" class="headerlink" title="1.静态变量和单例模式完全失效"></a>1.静态变量和单例模式完全失效</h4><p>因为进程间，内存空间是相互独立的，所以VM方法区内的静态变量也都是相互独立的。因为单利模式是基于静态变量的，所以单例也会失效。在两个不同进程访问一个相同类的静态变量，所得的值未必相同，所以在开发中请避免此类代码。</p>
<h4 id="2-线程同步机制完全失效"><a href="#2-线程同步机制完全失效" class="headerlink" title="2.线程同步机制完全失效"></a>2.线程同步机制完全失效</h4><p>由于Java的同步机制是VM来进行调度的，两个进程拥有两个不同的VM，所以，同步也会在多进程开发中失效。synchronized关键字、voliate关键字等都是基于VM级别的同步，所以请不要跨进程去使用线程同步。比如主进程有个生产者，子进程的消费者是无法正常使用消费功能的，只能通过跨进程通信，让主进程的消费者去消费，然后再回调。</p>
<h3 id="Application会多次创建"><a href="#Application会多次创建" class="headerlink" title="Application会多次创建"></a>Application会多次创建</h3><p>每个新进程在创建的时候，都会新建一个Application，所以多进程还会面临着Application多次创建的问题，<code>onCreate</code>方法会多次被调用。解决的办法其实也不是很麻烦，因为Application会多次创建，所以我们可以根据进程名来区分不同的进程，进行不同的初始化，同时，不要在Application中设置过多的静态变量，导致内存增加。</p>
<h3 id="文件读写潜在的问题"><a href="#文件读写潜在的问题" class="headerlink" title="文件读写潜在的问题"></a>文件读写潜在的问题</h3><p>这里的文件指的泛指所有需要并发访问的文件，例如：本地文件，数据库文件，sharepreference等。由于Java中，文件锁、队列机制都是VM级别的，所以不同进程访问同一个文件锁是不管用的。（通过C++可以实现多进程文件锁机制，不过不在文本讨论范围内。）所以在实际开发过程中，还是避免多进程同时访问统一文件，多利用Android中IPC的C/S思想，提供服务，接口调用，避免直接去访问对方进程的文件或者数据库，提升设计美感，同时也能提升代码的稳定性。</p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#58;&#x73;&#x70;&#x69;&#110;&#x79;&#x2e;&#116;&#101;&#x63;&#104;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;">&#x73;&#x70;&#x69;&#110;&#x79;&#x2e;&#116;&#101;&#x63;&#104;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章&lt;a href=&quot;http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/&quot;&gt;《Android多进程使用场景》&lt;/a&gt;中，我们分析了一下多进程的使用场景，今天这篇文章，
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="多进程" scheme="http://blog.spinytech.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程使用场景</title>
    <link href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/"/>
    <id>http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/</id>
    <published>2016-11-17T12:00:00.000Z</published>
    <updated>2016-12-12T10:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="http://blog.spinytech.com/2016/11/15/android_multiple_process/">《Android多进程介绍》</a>中，我们大概了解了一下Android中的进程的概念以及其生命周期，另外还有Low Memory Killer相关知识。了解完原理，就该进行实践了。今天这篇文章，我们就来聊一聊，到底如何利用多进程开发，使我们的应用更稳定、用户体验更好？换言之就是Android开发中多进程开发的使用场景分析。  </p>
<font color="blue" size="3">*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</font>  



<h2 id="什么情况需要使用多进程"><a href="#什么情况需要使用多进程" class="headerlink" title="什么情况需要使用多进程"></a>什么情况需要使用多进程</h2><h3 id="常驻后台任务应用"><a href="#常驻后台任务应用" class="headerlink" title="常驻后台任务应用"></a>常驻后台任务应用</h3><p>类似音乐类、跑步健身类、手机管家类等长时间需要在后台运行的应用。这些应用的特点就是，当用户切到别的应用，或者关掉手机屏幕的时候，应用本身的核心模块还在正常运行，提供服务。如果因为手机内存过低，或者是进程重要性降低，导致应用被杀掉，后台服务停止，对于这些应用来说，就是灭顶之灾。合理利用多进程，将核心后台服务模块和其他UI模块进行分离，保证应用能更稳定的提供服务，从而提升用户体验。</p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>现在要做一款音乐播放器，现在有以下几种方案：<br>A. 在Activity中直接播放音乐。<br>B. 启动后台Service，播放音乐。<br>C. 启动前台Service，播放音乐。<br>D. 在新的进程中，启动后台Service，播放音乐。<br>E. 在新的进程中，启动前台Service，播放音乐。  </p>
<h4 id="首先我们分析A"><a href="#首先我们分析A" class="headerlink" title="首先我们分析A"></a>首先我们分析A</h4><p>在A中，我们的播放器是直接在activity中启动的。首先这么做肯定是不对的，我们需要在后台播放音乐，所以当activity退出后就播不了了，之所以给出这个例子是为了控制变量作对比。<br>然后我们来看下A的使用场景。<br>音乐播放器无非是打开app，选歌，播放，退到桌面，切其他应用。我们选取了三个场景，打开、按home切换其他应用、按back退回桌面。让我们看一下A的相对应的oom_adj、oom_score、oom_score_adj的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>当我们应用在前台的时候，无论adj还是score还是score_adj，他们的值都非常的小，基本不会被LMK所杀掉，但是当我们按了Home之后，进程的adj就会急剧增大，变为7，相应的score和score_adj也会增大。在上篇文章中我们得知，adj=7即为被切换的进程，两个进程来回切换，上一个进程就会被设为7。当我们按Back键的时候，adj就会被设为9，也就是缓存进程，优先级比较低，有很大的几率被杀掉。  </p>
<h4 id="接着我们分析B"><a href="#接着我们分析B" class="headerlink" title="接着我们分析B"></a>接着我们分析B</h4><p>B是直接启动一个后台service并且播放音乐，这个处理看起来比A好了很多，那么实际上，B的各个场景的优先级和A又有什么不同呢？让我们来看下B的对应的打开、切换、退出相应的adj、score、score_adj的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>B的情况其实是与A类似的，三种状态的adj、score_adj的值都是一样的，只有score有一点出入，其实分析源码得知，LMK杀进程的时候，score的左右其实并不大，所以我们暂时忽略它。所以，与A相比，他们的adj和score_adj的值都相同，如果遇到内存不足的情况下，这两个应用谁占得内存更大，谁就会被杀掉。不过鉴于A实在activity中播放音乐，所以B还是比A略好的方案。  </p>
<p>这里有朋友肯定要问了，为什么切到后台后，adj的值是7而不是5，后台不是还有service在跑吗？<br>我们通过查看源码可以找出来，当切换Home的时候，会调用<code>ActivityStack.java</code>的<code>finishCurrentActivityLocked</code>函数，然后调用到了<code>ActivityManagerService.java</code>的<code>computeOomAdjLocked</code>函数，在这里，对进程的ADJ值进行重新计算。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0) &#123;</span><br><span class="line">    if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">        schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;previous&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程为PreviousProcess情况，则ADJ=7。<br>具体的计算流程请看这里<a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="external">computeOomAdjLocked计算流程</a>  </p>
<h4 id="接下来分析C"><a href="#接下来分析C" class="headerlink" title="接下来分析C"></a>接下来分析C</h4><p>C的话是启动一个前台Service来播放音乐。让我们来看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>在前台的时候，和AB是一样的，adj都是0，当切到后台，或者back结束时，C对应的adj就是2，也就是可感知进程。adj=2可以说是很高优先级了，非root手机，非系统应用已经没有办法将其杀掉了。具体可参见<a href="https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="external">ActivityManagerService</a>的<code>killBackgroundProcesses</code>方法以及<code>killPackageProcessesLocked</code>方法。adj&lt;5的应用不会被杀掉。<br>总的来说，C方案比B优秀，拥有前台Service的C更不容易被系统或者其他应用所杀掉了，进程的优先级一下子提高到了2，相对于B来说更稳定，用户体验更好。不过有一点不足是必须启动一个前台service。不过现在大部分的音乐类软件都会提供一个前台service，也就不是什么缺点了。其实也是有灰色方法可以启动一个不显示通知的前台service，这里就不过多介绍了。  </p>
<p>那么还有可改进的余地吗？<br>答案当然是肯定的。</p>
<h4 id="让我们来看看D"><a href="#让我们来看看D" class="headerlink" title="让我们来看看D"></a>让我们来看看D</h4><p>终于我们的主角，多进程登场了。<br>D把应用进行了拆分，把用于播放音乐的service放到了新的进程内，让我们看一下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>上面三张图对应的是D应用主进程的ADJ相关值，我们可以看出来，跟A类似，adj都是0，7，9。由于少了service部分，内存使用变少，最后计算出的oom_score_adj也更低了，意味着主进程部分也更不容易被杀死。  </p>
<p>下面我们看下拆分出的service的相关值  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1.png" alt="上图为后台Service的oom_adj、oom_score、oom_score_adj的值"></p>
<p>因为是service进程，所以不受打开，关闭，切换所影响，这里就放了一张图。<br>我们可以看到，service的adj值一直是5，也就是活跃的服务进程，相比于B来说，优先级高了不少。不过对于C来说，其实这个方案反倒不如C的adj=2的前台进程更稳定。但是D可以自主释放主进程，使D实际所占用的内存很小，从而不容易被杀掉。那么到底C和D谁是更优秀的设计？我个人认为，在ABCDE这5个设计中，D是最具智慧的设计，具体是为什么？先卖个关子，等我们说完了E，再作总结。</p>
<h4 id="那就赶紧分析E吧"><a href="#那就赶紧分析E吧" class="headerlink" title="那就赶紧分析E吧"></a>那就赶紧分析E吧</h4><p>E也是使用了多进程，并且在新进程中，使用了前台service，先来看下对应的值。（下面三张图依次对应为【打开状态】、【按了Home键被切换状态】、【按了Back键被退出状态】）  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-1.png" alt="上图为打开状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-2.png" alt="上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-3.png" alt="上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值"></p>
<p>这个不多解释，和ABD基本差不多，都是0，7，9。我们看下拆分出来的进程的值。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/per-1.png" alt="上图为后台Service的oom_adj、oom_score、oom_score_adj的值"></p>
<p>我们可以看到，这个进程的值是2，像C方案，非常小，非常稳定，而且，我们还可以在系统进入后台后，手动杀掉主进程，使整个应用的内存消耗降到最低，内存低，优先级又高，E获得了今天的最稳定的方案奖。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ABCDE，5种方案都已经分析完了。显然，E是最稳定的方案，不过，我刚才说过，我个人最倾向于D方案，并且认为D是最智慧的方案，这是为什么呢？<br>其实我们可以做个比喻，把整个Android系统比喻成一个旅游景点，Low Memory Killer就是景点的门卫兼保安，然后我们每个进程的ADJ相当于手里的门票，有的人是VIP门票，有的人是普通门票。景点平常没人的时候还好，谁拿票都能进，当人逐渐拥挤的时候，保安就开始根据票的等级，往外轰人。E方案就是一个拿着普通票的妈妈，带着一个VIP的孩子去参观，D方案就是一个拿着普通票的妈妈，带着一个拿着中等票的孩子参观。当内存不够的时候，保安会先把两个妈妈轰出去，孩子们在里面看，再不够了，就会把D孩子给轰出去。这么看来，显然E的效果更好一些，不过由于Android系统对于VIP票的发放没有节制，大家都可以领VIP票，那也就是相当于没有VIP票了。所以如果E方案是一种精明，那么D才是真正的智慧。将调度权还给系统，做好自己，维护好整个Android生态。  </p>
<p>其实现阶段，如果公司要做一个后台类型的应用，我个人也是会选择追逐眼前里利益，采用E方案的，这也是不得已而为之，大家都利用漏洞拿VIP票，你不拿，将来做出来的APP出了偏差，你是要负责任的，所以还是希望Android能把漏洞堵住，把内存分配给真正需要的人，而我们自己也应该遵守规矩，维护整个生态平衡。<br>还有一点，是因为现在部分Root的手机都有优化大师，其实这个优化大师，就好比是个临时工门卫，告诉你他能解决景区爆满问题，实际上他的做法是，把一些票的等级降低，比如把中等票变成赠票，然后给你名正言顺的轰出去，听着是不是很耳熟？“让一部分人先富裕起来，然后把不富裕的杀掉，达成共同富裕。”  </p>
<p>我的测试机之前装了某款优化软件，然后，在正常手机上的adj的值，都有一定程度的降低，来我们上证据。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1-king.png" alt="上图为D方案下，Service进程的oom_adj、oom_score、oom_score_adj的值"></p>
<p>看到没，安装了优化应用之后，本应该adj=5的活跃服务进程，被调整为8，意思是不活跃的服务进程，这种做法本身就违反了最初Android设计的思想。</p>
<p>还有<img src="http://ogsbxb571.bkt.clouddn.com/pem-3-king.png" alt="上图为E方案下，主进程在按了back键退出之后进程的oom_adj、oom_score、oom_score_adj的值"></p>
<p>本来应该adj=9的缓存进程，调整为adj=11。adj=11在Android中都没给出定义。</p>
<p>所以，选择E也是无奈之举。还是呼吁大家要克制吧，维护Android的生态系统是每个工程师的责任。</p>
<p>“喜欢是放肆，但爱是克制” — 阿尔伯特·爱因斯坦 [手动滑稽]</p>
<h3 id="多模块应用"><a href="#多模块应用" class="headerlink" title="多模块应用"></a>多模块应用</h3><p>多进程还有一种非常有用的场景，就是多模块应用。比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。  </p>
<p>首先多进程开发能为应用解决了OOM问题，Android对内存的限制是针对于进程的，这个阈值可以是48M、24M、16M等，视机型而定，所以，当我们需要加载大图之类的操作，可以在新的进程中去执行，避免主进程OOM。  </p>
<p>多进程不光解决OOM问题，还能更有效、合理的利用内存。我们可以在适当的时候生成新的进程，在不需要的时候及时杀掉，合理分配，提升用户体验。减少系统被杀掉的风险。  </p>
<p>多进程还能带来一个好处就是，单一进程崩溃并不影响整体应用的使用。例如我在图片浏览进程打开了一个过大的图片，java heap 申请内存失败，但是不影响我主进程的使用，而且，还能通过监控进程，将这个错误上报给系统，告知他在什么机型、环境下、产生了什么样的Bug，提升用户体验。  </p>
<p>再一个好处就是，当我们的应用开发越来越大，模块越来越多，团队规模也越来越大，协作开发也是个很麻烦的事情。项目解耦，模块化，是这阶段的目标。通过模块解耦，开辟新的进程，独立的JVM，来达到数据解耦目的。模块之间互不干预，团队并行开发，责任分工也明确。至于模块化开发与多进程的结合，后续会写一篇专门的文章来研究这个问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于多进程的使用场景今天大概先说这么多。使用多进程开发还是有很多好处的，不过也有不少坑，下一篇文章我就想总结一下<a href="http://blog.spinytech.com/2016/11/20/android_multiple_process_notice/">《多进程开发注意事项》</a>。 </p>
<p>最后，多进程不一定适合所有的应用，合理利用分配进程，使程序更加稳定，才是我们追求的目标。  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#x70;&#105;&#110;&#121;&#x2e;&#x74;&#x65;&#99;&#x68;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#115;&#x70;&#105;&#110;&#121;&#x2e;&#x74;&#x65;&#99;&#x68;&#64;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></p>
<p>本文相关源码地址：<a href="https://github.com/SpinyTech/MultipleProcess" target="_blank" rel="external">MultipleProcess</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;http://blog.spinytech.com/2016/11/15/android_multiple_process/&quot;&gt;《Android多进程介绍》&lt;/a&gt;中，我们大概了解了一下Android中的进程的概念以及其生命周期，另外还有Low M
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="架构思考" scheme="http://blog.spinytech.com/tags/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/"/>
    
      <category term="多进程" scheme="http://blog.spinytech.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程介绍</title>
    <link href="http://blog.spinytech.com/2016/11/15/android_multiple_process/"/>
    <id>http://blog.spinytech.com/2016/11/15/android_multiple_process/</id>
    <published>2016-11-15T12:00:00.000Z</published>
    <updated>2016-11-22T02:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中，默认情况下，同一应用的所有组件均运行在同一进程中，且大多数应用都不会改变这一点。不过，单进程开发并不是Android应用的全部，今天我们就来说说Android中的多进程开发以及多进程的使用场景。  </p>
<h2 id="多进程介绍"><a href="#多进程介绍" class="headerlink" title="多进程介绍"></a>多进程介绍</h2><p>本篇文章内容基于<a href="https://developer.android.com/guide/components/processes-and-threads.html#Processes" target="_blank" rel="external">Android Developer官网</a></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>我们都知道Android系统是基于Linux改造而来的，进程系统也是一脉相承，进程，其实就是程序的具体实现。当程序第一次启动，Android会启动一个Linux进程（具体由Zygote fork出来）以及一个主线程，默认的情况下，所有组件都将运行在该进程内。同一个应用由系统分配一个独立的Linux账户，该应用的产生的所有进程，都会是这同一个Linux账户。</p>
<h3 id="使用多进程"><a href="#使用多进程" class="headerlink" title="使用多进程"></a>使用多进程</h3><p>在开发中，我们通常会使用修改清单文件的<code>android:process</code>来达到多进程的目的。<code>activity</code>、<code>service</code>、<code>receiver</code> 和 <code>provider</code>均支持<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。如果<code>android:process</code>的value值以冒号开头的话，那么该进程就是私有进程，如果是以其他字符开头，那么就是公有进程，拥有相同 <font color="#ff0000">ShareUID</font> 的不同应用可以跑在同一进程里，后续我会专门针对公私有进程做个试验。另外，我们还可以通过设置<code>application</code>的<code>android:process</code>属性，来设置所有组件的默认进程。  </p>
<p>至于创建进程的具体源码分析，网上有一篇很详细的文章，在这就不重复造轮子了，有需要的朋友可以前往 <a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="external">理解Android进程创建流程</a></p>
<p>还有一种方法开启进程，是通过JNI，利用C/C++，调用fork()方法来生成子进程，一般开发者会利用这种方法来做一些daemon进程，来实现防杀，保活等效果，不过不是太推荐，这么做，毕竟Android生态系统需要大家维护。</p>
<h3 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h3><p>刚刚聊了一下进程的“生”，作为一个生命周期，是时候该聊聊进程的“死”了。这里再次呼吁一下大家能正视进程的“死”，合理的利用多进程，适当的杀死不必要的进程才是本篇文章所关注的焦点，我们不要把“永生”作为自己的实现目标，Android设备内存就那么大，就像地球一样，大家都永生了，生态系统就会破坏。那么Android系统是如何维护这个生态系统的呢？</p>
<p>其实也是类似于现实生活中的优胜略汰，Android利用<code>重要性层次结构</code>，就是将最重要的保留，杀掉不重要的进程。Android将<code>重要性层次结构</code>分为5个层级，分为了：（以下5级描述节选自<a href="https://developer.android.com/guide/components/processes-and-threads.html#Lifecycle" target="_blank" rel="external">Android进程生命周期</a>）  </p>
<ol>
<li><p>前台进程<br>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：  </p>
<ul>
<li>托管用户正在交互的 <code>Activity</code>（已调用 <code>Activity</code> 的 <code>onResume()</code> 方法）  </li>
<li>托管某个 <code>Service</code>，后者绑定到用户正在交互的 <code>Activity</code></li>
<li>托管正在“前台”运行的 <code>Service</code>（服务已调用 <code>startForeground()</code>）  </li>
<li>托管正执行一个生命周期回调的 <code>Service</code>（<code>onCreate()</code>、<code>onStart()</code> 或 <code>onDestroy()</code>）  </li>
<li><p>托管正执行其 <code>onReceive()</code> 方法的 <code>BroadcastReceiver</code>  </p>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。<br>这就需要依靠系统的资源。  </p>
</li>
</ul>
</li>
<li><p>可见进程<br>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：  </p>
<ul>
<li>托管不在前台、但仍对用户可见的 <code>Activity</code>（已调用其 <code>onPause()</code> 方法）。例如，如果前台 <code>Activity</code> 启动了一个对话框，允许在其后显示上一 <code>Activity</code>，则有可能会发生这种情况。</li>
<li><p>托管绑定到可见（或前台）<code>Activity</code> 的 <code>Service</code>。  </p>
<p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。  </p>
</li>
</ul>
</li>
<li><p>服务进程<br>正在运行已使用 <code>startService()</code> 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。  </p>
</li>
<li><p>后台进程<br>包含目前对用户不可见的 <code>Activity</code> 的进程（已调用 <code>Activity</code> 的 <code>onStop()</code> 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 <code>Activity</code> 的进程最后一个被终止。如果某个 <code>Activity</code> 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 <code>Activity</code> 时，<code>Activity</code> 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 <code>Activity</code>文档。  </p>
</li>
<li><p>空进程<br>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。  </p>
</li>
</ol>
<p>根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 <code>Activity</code>，则会将此进程评定为可见进程，而不是服务进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 <code>Activity</code> 的进程，因此启动长时间运行操作的 <code>Activity</code> 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 <code>Activity</code> 更加持久时尤要如此。例如，正在将图片上传到网站的 <code>Activity</code> 应该启动服务来执行上传，这样一来，即使用户退出 <code>Activity</code>，仍可在后台继续执行上传操作。使用服务可以保证，无论 <code>Activity</code> 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h3 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h3><p>进程按照状态分完重要性之后，就要开始杀进程了。Android的Low Memory Killer基于Linux的OOM机制，在Linux中，内存是以页面(page)为单位，当申请页面分配不足的时候，系统会通过Low Memory Killer来杀掉bad进程，释放内存。Low Memory Killer会根据进程的adj级别以及所占的内存，来决定是否杀掉该进程，adj越大，占用内存越多，进程越容易被杀掉。<br>关于adj的分级，我们可以参考<a href="https://github.com/android/platform_frameworks_base/blob/marshmallow-release/services/core/java/com/android/server/am/ProcessList.java" target="_blank" rel="external">ProcessList.java</a>，这里面的常量定义了ADJ的分级。（7.0以后的adj分级与之前的不太一样(<a href="https://github.com/android/platform_frameworks_base/blob/nougat-release/services/core/java/com/android/server/am/ProcessList.java" target="_blank" rel="external">Processlist.java-Nougat</a>)，这个我们后续可以研究一下具体的改动是什么）  </p>
<h4 id="adj分级："><a href="#adj分级：" class="headerlink" title="adj分级："></a>adj分级：</h4><ul>
<li><p>UNKNOWN_ADJ = 16<br>级别最低级的进程，通常是被缓存的进程，但是系统也不清楚缓存的内容。  </p>
</li>
<li><p>CACHED_APP_MAX_ADJ = 15<br>这是一个只托管不可见的活动的进程，因此可以在没有任何中断的情况下被杀死。  </p>
</li>
<li><p>CACHED_APP_MIN_ADJ = 9<br>缓存进程，没有英文解释。  </p>
</li>
<li><p>SERVICE_B_ADJ = 8<br>不活跃的服务，不想adj=5的服务那么活跃。<br>PS:这里说一句，在root以后，有的系统优化大师，会把所有服务统一调成adj=8这个级别，来达到内存优化的目的，后面我们会说到。</p>
</li>
<li><p>PREVIOUS_APP_ADJ = 7<br>被切换的进程，一般是用户前一个使用的进程。两个应用来回切换，那么前一个应用一般adj设置为7。  </p>
</li>
<li><p>HOME_APP_ADJ = 6<br>与主应用程序有交互的进程。  </p>
</li>
<li><p>SERVICE_ADJ = 5<br>活跃的服务进程。  </p>
</li>
<li><p>HEAVY_WEIGHT_APP_ADJ = 4<br>高权重进程  </p>
</li>
<li><p>BACKUP_APP_ADJ = 3<br>正在备份的进程   </p>
</li>
<li><p>PERCEPTIBLE_APP_ADJ = 2<br>可感知进程（通常是前台Service进程）  </p>
</li>
<li><p>VISIBLE_APP_ADJ = 1<br>可见进程  </p>
</li>
<li><p>FOREGROUND_APP_ADJ = 0<br>前台进程  </p>
</li>
</ul>
<p>剩下的就是adj值为负数的进程，基本上都是系统集成，不在本文的讨论范围内。负数进程是不会被lmk杀掉的。</p>
<h4 id="如何查看进程优先级"><a href="#如何查看进程优先级" class="headerlink" title="如何查看进程优先级"></a>如何查看进程优先级</h4><p>首先通过 adb shell ps 指令查找对应进程的pid<br>然后通过 adb shell cat /proc/${pid}/oom_adj（设备需要root）返回对应进程的adj值。<br>还可以把oom_adj替换成oom_score或者oom_score_adj来查看这两项的数值，当oom_adj相同时，LowMemoryKiller会根据oom_score_adj和RSS内存大小来杀掉对应的进程。</p>
<h4 id="查看设备的内存临界值"><a href="#查看设备的内存临界值" class="headerlink" title="查看设备的内存临界值"></a>查看设备的内存临界值</h4><p>我们可以通过adb shell cat 查看下面两个文件<br>/sys/module/lowmemorykiller/parameters/adj<br>/sys/module/lowmemorykiller/parameters/minfree<br>（这里请注意，这两个文件是只可以写入的，cat之前请先用chmod赋予权限。）  </p>
<p>adj 代表的是oom_score_adj的值，对应的minfree则代表内存临界值。<br>比如我的测试机小米4C测试机对应的值就是：  </p>
<p>adj: 0,58,117,176,529,1000<br>这个值其实是oom_score_adj的值，用这个值*17再除1000四舍五入取整数，就是对应的adj的值，例如第二个值58即为 58*17/1000 = 1，对应的adj也就是1，所以这6个值对应的adj是0，1，2，3，9，15。1000默认就是15  </p>
<p>minfree: 18432,23040,27648,32256,56250,81250<br>这个值是页值，一页等于4KB，换算成MB大概是72，90，108，126，220，318<br>当可用内存小于318MB的时候，系统开始杀adj=15的进程，以此类推。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上，我们大概了解了一下Android进程、多进程、生命周期以及Low Memory Killer的相关知识。至于如何运用到实际开发当中，我们在下一篇文章<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/">《Android多进程使用场景》</a>中继续探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android中，默认情况下，同一应用的所有组件均运行在同一进程中，且大多数应用都不会改变这一点。不过，单进程开发并不是Android应用的全部，今天我们就来说说Android中的多进程开发以及多进程的使用场景。  &lt;/p&gt;
&lt;h2 id=&quot;多进程介绍&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="Android" scheme="http://blog.spinytech.com/categories/Android/"/>
    
    
      <category term="多进程" scheme="http://blog.spinytech.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何恰当的在闪屏页加载繁重的数据和库</title>
    <link href="http://blog.spinytech.com/2016/07/25/2016-07-25/"/>
    <id>http://blog.spinytech.com/2016/07/25/2016-07-25/</id>
    <published>2016-07-25T03:50:57.000Z</published>
    <updated>2016-07-26T05:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我将为你们展示开发者开启App时，因为加载一些库和数据遇到的初始化非常慢的这种情况。在这种情况下，开发者通常不会在主线程中初始化，因为这样做会使整个App卡住。相反，开发者希望通过后台初始化数据和库，然后在主线程处理初始化结果。</p>
<h2 id="闪屏页-SplashActivity"><a href="#闪屏页-SplashActivity" class="headerlink" title="闪屏页 SplashActivity"></a>闪屏页 SplashActivity</h2><p>首先，如果你已经有了一些需要在自定义Application类中初始化的东西，你可能想着要做一个恰当的闪屏页。这意味着你点击App图标的同时，闪屏页已经完整的显示出来了。通过设置闪屏页Theme的背景图，我们可以轻易实现这个需求。</p>
<p>res/values/styles.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">style</span> <span class="attr">name</span>=<span class="string">"SplashTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.NoActionBar"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/background_splash<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span><br><span class="line">  <span class="attr">android:name</span>=<span class="string">".splash.SplashActivity"</span></span><br><span class="line">  <span class="attr">android:theme</span>=<span class="string">"@style/SplashTheme"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，闪屏页一般是放个logo，所以 <code>@drawable/background_splash</code> 可以写成一个 <code>layer-list</code></p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/holo_blue_dark"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitmap</span></span><br><span class="line">      <span class="attr">android:gravity</span>=<span class="string">"center"</span></span><br><span class="line">      <span class="attr">android:src</span>=<span class="string">"@drawable/ic_hockey_stick"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>顺便说一下，如果你用了矢量的 <code>&lt;vector&gt;</code> 作为 <code>&lt;src&gt;</code> 赋予 <code>&lt;bitmap&gt;</code> ，那么请你注意<a href="http://stackoverflow.com/questions/34831142/how-to-center-vector-drawable-in-layer-list-without-scaling" target="_blank" rel="external">这个bug</a>。<br>坑爹的是，这个bug现在没办法解决，所以在API小于23的时候你只能用PNG来代替矢量图。</p>
<h2 id="初始化数据和库"><a href="#初始化数据和库" class="headerlink" title="初始化数据和库"></a>初始化数据和库</h2><p>现在我们已经可以瞬间打开App了，那么接下来该怎么做？我们应该想办法如何初始化这种加载缓慢的库。<code>Dagger2</code> 和 <code>RxJava</code> 或许对我们有帮助。</p>
<p>如果只是在闪屏页需要这种‘长初始化’库，来加载必要的资源，那么我们可以定义一个 <code>SplashModule</code> ，那么我们就能把所有库的引用都写到这里。可以，这很解耦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@NonNull</span> <span class="meta">@SplashScope</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> SplashLibrary <span class="title">splashLibrary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SplashLibrary(); <span class="comment">// Takes &gt;5 seconds.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们还不能注入 <code>@Inject</code> ，因为这样做会阻塞我们的主线程。我们需要通过RxJava来创建一个观察者 <code>Observable</code> ，用来接收 <code>SplashLibrary</code> 实例，由于我们用了懒加载 <code>Lazy&lt;&gt;</code> ，我们的库仍未初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashModule</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@NonNull</span> <span class="meta">@SplashScope</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Observable&lt;SplashLibrary&gt; <span class="title">observable</span><span class="params">(<span class="keyword">final</span> Lazy&lt;SplashLibrary&gt; library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;SplashLibrary&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Observable&lt;SplashLibrary&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(library.get());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入这个库"><a href="#注入这个库" class="headerlink" title="注入这个库"></a>注入这个库</h2><p>最后，我们要把库 <code>Observable&lt;SplashLibrary&gt;</code> 注入到我们的闪屏页 <code>SplashActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Observable which will emit an item when fully initialized. */</span></span><br><span class="line"><span class="meta">@Inject</span> Observable&lt;SplashLibrary&gt; splashLibraryObservable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Subscription to unsubscribe in onStop(). */</span></span><br><span class="line"><span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  subscription = splashLibraryObservable</span><br><span class="line">      <span class="comment">// Init library on another thread.</span></span><br><span class="line">      .subscribeOn(Schedulers.computation())</span><br><span class="line">      <span class="comment">// Observe result on the main thread.</span></span><br><span class="line">      .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">      .subscribe(<span class="keyword">new</span> Action1&lt;SplashLibrary&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Use the initialized library.</span></span><br><span class="line"></span><br><span class="line">          Intent intent = <span class="keyword">new</span> Intent(activity, MainActivity.class);</span><br><span class="line">          startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿还有一些个小问题等着你：</p>
<ol>
<li>库加载的过程中，可能会抛出异常，我们需要在 <code>onError</code> 方法中去处理它们。</li>
<li>库加载过程中，用户可能会离开此页或旋转屏幕。由于我们在回调函数中引用了 <code>Activity</code> ，所以有可能导致内存泄露。</li>
</ol>
<h2 id="处理加载过程中的异常"><a href="#处理加载过程中的异常" class="headerlink" title="处理加载过程中的异常"></a>处理加载过程中的异常</h2><p>为了处理这个问题，我们可以传一个 <code>Observer</code> 实例给 <code>subscribe()</code> 方法。</p>
<p>很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;SplashLibrary&gt;() &#123;</span><br><span class="line">  <span class="keyword">final</span> String TAG = <span class="string">"Observer&lt;SplashLibrary&gt;"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Library init error!"</span>, e);</span><br><span class="line">    <span class="comment">// Possible UI interaction.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Use the initialized library.</span></span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(activity, MainActivity.class);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="处理内存溢出问题"><a href="#处理内存溢出问题" class="headerlink" title="处理内存溢出问题"></a>处理内存溢出问题</h2><p>在这个例子中，我们不能从 <code>Subscription</code> 中取消订阅，因为对象一旦加载开始，<code>Subscription</code> 就不能释放资源了。这也就是为什么在内存中还存在着已经销毁的Activity对象，它导致了内存泄露。如果我们在Application中加入了严苛模式 <code>StrictMode.enableDefaults();</code> ，我们可以很容易的在 <code>LogCat</code> 中看到看到Log。当我们旋转屏幕，严苛模式显示了Acitivty的实例信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E/StrictMode: class .SplashActivity; instances=2; limit=1</span><br><span class="line">android.os.StrictMode$InstanceCountViolation: class .SplashActivity; instances=2; limit=1</span><br><span class="line">at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)</span><br></pre></td></tr></table></figure>
<p>这就是为什么我们需要在创建的 <code>Observer</code> 中释放Activity的引用了。我们可以创建一个静态类去实现 <code>Observer&lt;SplashActivity&gt;</code> ，在给他传入一个Activity的引用，然后在 <code>onDestroy</code> 中清除引用。这样，我们可以确保没有内存泄漏异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnInitObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">SplashLibrary</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> SplashActivity splashActivity;</span><br><span class="line"></span><br><span class="line">  OnInitObserver(<span class="meta">@NonNull</span> SplashActivity splashActivity) &#123;</span><br><span class="line">    <span class="keyword">this</span>.splashActivity = splashActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    splashActivity = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">  onInitObserver.releaseListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住这几点，我们就能轻松地在闪屏页中加载库、数据，执行网络请求或者做一些其他的繁重的任务。</p>
<p>感谢阅读，获取源码请点<a href="https://github.com/zsavely/FastStartUp" target="_blank" rel="external">这里</a>。</p>
<hr>
<p>原文地址：<a href="http://szagurskii.com/blog/how-to-load-heavy-libraries-on-splash-screen/?utm_source=Android+Weekly&amp;utm_campaign=644e634e1a-Android_Weekly_215&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-644e634e1a-338049121" target="_blank" rel="external">How to Load Heavy Libraries on Splash Screen [the proper way]</a></p>
<p>作者：SAVELII ZAGURSKII</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我将为你们展示开发者开启App时，因为加载一些库和数据遇到的初始化非常慢的这种情况。在这种情况下，开发者通常不会在主线程中初始化，因为这样做会使整个App卡住。相反，开发者希望通过后台初始化数据和库，然后在主线程处理初始化结果。&lt;/p&gt;
&lt;h2 id=&quot;闪屏页
    
    </summary>
    
      <category term="翻译" scheme="http://blog.spinytech.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://blog.spinytech.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxJava" scheme="http://blog.spinytech.com/tags/RxJava/"/>
    
      <category term="Dagger2" scheme="http://blog.spinytech.com/tags/Dagger2/"/>
    
  </entry>
  
</feed>
