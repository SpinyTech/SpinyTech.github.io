<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Spiny</title>
  <subtitle>Stay Hungry, Stay Foolish, Stay Uncomfortable.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://spinytech.github.io/"/>
  <updated>2016-11-24T10:42:50.000Z</updated>
  <id>http://spinytech.github.io/</id>
  
  <author>
    <name>Spiny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android多进程注意事项</title>
    <link href="http://spinytech.github.io/2016/11/20/android_multiple_process_notice/"/>
    <id>http://spinytech.github.io/2016/11/20/android_multiple_process_notice/</id>
    <published>2016-11-20T12:00:00.000Z</published>
    <updated>2016-11-24T10:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/" target="_blank" rel="external">《Android多进程使用场景》</a>中，我们分析了一下多进程的使用场景，今天这篇文章，我们来聊聊Android多进程开发过程中可能会遇到的问题。</p>
<h3 id="多虚拟机潜在的问题"><a href="#多虚拟机潜在的问题" class="headerlink" title="多虚拟机潜在的问题"></a>多虚拟机潜在的问题</h3><p>由于每个进程创建以后，都会拥有独立的空间，独立的VM，所以，很多Java特性都会在多进程开发中失效。</p>
<h4 id="1-静态变量和单例模式完全失效"><a href="#1-静态变量和单例模式完全失效" class="headerlink" title="1.静态变量和单例模式完全失效"></a>1.静态变量和单例模式完全失效</h4><p>因为进程间，内存空间是相互独立的，所以VM方法区内的静态变量也都是相互独立的。因为单利模式是基于静态变量的，所以单例也会失效。在两个不同进程访问一个相同类的静态变量，所得的值未必相同，所以在开发中请避免此类代码。</p>
<h4 id="2-线程同步机制完全失效"><a href="#2-线程同步机制完全失效" class="headerlink" title="2.线程同步机制完全失效"></a>2.线程同步机制完全失效</h4><p>由于Java的同步机制是VM来进行调度的，两个进程拥有两个不同的VM，所以，同步也会在多进程开发中失效。synchronized关键字、voliate关键字等都是基于VM级别的同步，所以请不要跨进程去使用线程同步。比如主进程有个生产者，子进程的消费者是无法正常使用消费功能的，只能通过跨进程通信，让主进程的消费者去消费，然后再回调。</p>
<h3 id="Application会多次创建"><a href="#Application会多次创建" class="headerlink" title="Application会多次创建"></a>Application会多次创建</h3><p>每个新进程在创建的时候，都会新建一个Application，所以多进程还会面临着Application多次创建的问题，<code>onCreate</code>方法会多次被调用。解决的办法其实也不是很麻烦，因为Application会多次创建，所以我们可以根据进程名来区分不同的进程，进行不同的初始化，同时，不要在Application中设置过多的静态变量，导致内存增加。</p>
<h3 id="文件读写潜在的问题"><a href="#文件读写潜在的问题" class="headerlink" title="文件读写潜在的问题"></a>文件读写潜在的问题</h3><p>这里的文件指的泛指所有需要并发访问的文件，例如：本地文件，数据库文件，sharepreference等。由于Java中，文件锁、队列机制都是VM级别的，所以不同进程访问同一个文件锁是不管用的。（通过C++可以实现多进程文件锁机制，不过不在文本讨论范围内。）所以在实际开发过程中，还是避免多进程同时访问统一文件，多利用Android中IPC的C/S思想，提供服务，接口调用，避免直接去访问对方进程的文件或者数据库，提升设计美感，同时也能提升代码的稳定性。</p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#115;&#x70;&#x69;&#110;&#x79;&#x2e;&#x74;&#x65;&#x63;&#x68;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;">&#115;&#x70;&#x69;&#110;&#x79;&#x2e;&#x74;&#x65;&#x63;&#x68;&#64;&#103;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#109;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章&lt;a href=&quot;http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Android多进程使用场
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="多进程" scheme="http://spinytech.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程使用场景</title>
    <link href="http://spinytech.github.io/2016/11/17/android_multiple_process_usage_scenario/"/>
    <id>http://spinytech.github.io/2016/11/17/android_multiple_process_usage_scenario/</id>
    <published>2016-11-17T12:00:00.000Z</published>
    <updated>2016-12-05T09:30:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="http://blog.spinytech.com/2016/11/15/android_multiple_process/" target="_blank" rel="external">《Android多进程介绍》</a>中，我们大概了解了一下Android中的进程的概念以及其生命周期，另外还有Low Memory Killer相关知识。了解完原理，就该进行实践了。今天这篇文章，我们就来聊一聊，到底如何利用多进程开发，使我们的应用更稳定、用户体验更好？换言之就是Android开发中多进程开发的使用场景分析。  </p>
<font color="blue" size="3">*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</font>  



<h2 id="什么情况需要使用多进程"><a href="#什么情况需要使用多进程" class="headerlink" title="什么情况需要使用多进程"></a>什么情况需要使用多进程</h2><h3 id="常驻后台任务应用"><a href="#常驻后台任务应用" class="headerlink" title="常驻后台任务应用"></a>常驻后台任务应用</h3><p>类似音乐类、跑步健身类、手机管家类等长时间需要在后台运行的应用。这些应用的特点就是，当用户切到别的应用，或者关掉手机屏幕的时候，应用本身的核心模块还在正常运行，提供服务。如果因为手机内存过低，或者是进程重要性降低，导致应用被杀掉，后台服务停止，对于这些应用来说，就是灭顶之灾。合理利用多进程，将核心后台服务模块和其他UI模块进行分离，保证应用能更稳定的提供服务，从而提升用户体验。</p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>现在要做一款音乐播放器，现在有以下几种方案：<br>A. 在Activity中直接播放音乐。<br>B. 启动后台Service，播放音乐。<br>C. 启动前台Service，播放音乐。<br>D. 在新的进程中，启动后台Service，播放音乐。<br>E. 在新的进程中，启动前台Service，播放音乐。  </p>
<h4 id="首先我们分析A"><a href="#首先我们分析A" class="headerlink" title="首先我们分析A"></a>首先我们分析A</h4><p>在A中，我们的播放器是直接在activity中启动的。首先这么做肯定是不对的，我们需要在后台播放音乐，所以当activity退出后就播不了了，之所以给出这个例子是为了控制变量作对比。<br>然后我们来看下A的使用场景。<br>音乐播放器无非是打开app，选歌，播放，退到桌面，切其他应用。我们选取了三个场景，打开、按home切换其他应用、按back退回桌面。让我们看一下A的相对应的oom_adj、oom_score、oom_score_adj的值。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>当我们应用在前台的时候，无论adj还是score还是score_adj，他们的值都非常的小，基本不会被LMK所杀掉，但是当我们按了Home之后，进程的adj就会急剧增大，变为7，相应的score和score_adj也会增大。在上篇文章中我们得知，adj=7即为被切换的进程，两个进程来回切换，上一个进程就会被设为7。当我们按Back键的时候，adj就会被设为9，也就是缓存进程，优先级比较低，有很大的几率被杀掉。  </p>
<h4 id="接着我们分析B"><a href="#接着我们分析B" class="headerlink" title="接着我们分析B"></a>接着我们分析B</h4><p>B是直接启动一个后台service并且播放音乐，这个处理看起来比A好了很多，那么实际上，B的各个场景的优先级和A又有什么不同呢？让我们来看下B的对应的打开、切换、退出相应的adj、score、score_adj的值。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>B的情况其实是与A类似的，三种状态的adj、score_adj的值都是一样的，只有score有一点出入，其实分析源码得知，LMK杀进程的时候，score的左右其实并不大，所以我们暂时忽略它。所以，与A相比，他们的adj和score_adj的值都相同，如果遇到内存不足的情况下，这两个应用谁占得内存更大，谁就会被杀掉。不过鉴于A实在activity中播放音乐，所以B还是比A略好的方案。  </p>
<font color="blue" size="3">//TODO 疑问</font><br>这里有朋友肯定要问了，为什么切到后台后，adj的值是7而不是5，后台不是还有service在跑吗？<br>其实这里我也没有搞太明白，至少没找到源码给我解惑。不过，网上普遍的解答是，我们所讨论的优先级是进程级别的，并非是activity、service这样的组件级别。所以对系统而言，单进程的<code>activity</code>和<code>非前台service</code>这样的应用，当切换到其他应用或者按back键退出应用的时候，系统会认为这是个缓存进程，随时都可以杀掉的。<br><br>#### 接下来分析C<br>C的话是启动一个前台Service来播放音乐。让我们来看一下对应的值。<br><br><br><img src="http://ogsbxb571.bkt.clouddn.com/pc-1.png" alt=""><br><font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>在前台的时候，和AB是一样的，adj都是0，当切到后台，或者back结束时，C对应的adj就是2，也就是可感知进程。adj=2可以说是很高优先级了，非root手机，非系统应用已经没有办法将其杀掉了。具体可参见<a href="https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="external">ActivityManagerService</a>的<code>killBackgroundProcesses</code>方法以及<code>killPackageProcessesLocked</code>方法。adj&lt;5的应用不会被杀掉。<br>总的来说，C方案比B优秀，拥有前台Service的C更不容易被系统或者其他应用所杀掉了，进程的优先级一下子提高到了2，相对于B来说更稳定，用户体验更好。不过有一点不足是必须启动一个前台service。不过现在大部分的音乐类软件都会提供一个前台service，也就不是什么缺点了。其实也是有灰色方法可以启动一个不显示通知的前台service，这里就不过多介绍了。  </p>
<p>那么还有可改进的余地吗？<br>答案当然是肯定的。</p>
<h4 id="让我们来看看D"><a href="#让我们来看看D" class="headerlink" title="让我们来看看D"></a>让我们来看看D</h4><p>终于我们的主角，多进程登场了。<br>D把应用进行了拆分，把用于播放音乐的service放到了新的进程内，让我们看一下对应的值。<br><img src="http://ogsbxb571.bkt.clouddn.com/pdm-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>上面三张图对应的是D应用主进程的ADJ相关值，我们可以看出来，跟A类似，adj都是0，7，9。由于少了service部分，内存使用变少，最后计算出的oom_score_adj也更低了，意味着主进程部分也更不容易被杀死。  </p>
<p>下面我们看下拆分出的service的相关值  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1.png" alt=""></p>
<font color="gray" size="2">上图后台service的oom_adj、oom_score、oom_score_adj的值</font>  

<p>因为是service进程，所以不受打开，关闭，切换所影响，这里就放了一张图。<br>我们可以看到，service的adj值一直是5，也就是活跃的服务进程，相比于B来说，优先级高了不少。不过对于C来说，其实这个方案反倒不如C的adj=2的前台进程更稳定。但是D可以自主释放主进程，使D实际所占用的内存很小，从而不容易被杀掉。那么到底C和D谁是更优秀的设计？我个人认为，在ABCDE这5个设计中，D是最具智慧的设计，具体是为什么？先卖个关子，等我们说完了E，再作总结。</p>
<h4 id="那就赶紧分析E吧"><a href="#那就赶紧分析E吧" class="headerlink" title="那就赶紧分析E吧"></a>那就赶紧分析E吧</h4><p>E也是使用了多进程，并且在新进程中，使用了前台service，先来看下对应的值。<br><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>这个不多解释，和ABD基本差不多，都是0，7，9。我们看下拆分出来的进程的值。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/per-1.png" alt=""></p>
<font color="gray" size="2">上图后台service的oom_adj、oom_score、oom_score_adj的值</font>  

<p>我们可以看到，这个进程的值是2，像C方案，非常小，非常稳定，而且，我们还可以在系统进入后台后，手动杀掉主进程，使整个应用的内存消耗降到最低，内存低，优先级又高，E获得了今天的最稳定的方案奖。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ABCDE，5种方案都已经分析完了。显然，E是最稳定的方案，不过，我刚才说过，我个人最倾向于D方案，并且认为D是最智慧的方案，这是为什么呢？<br>其实我们可以做个比喻，把整个Android系统比喻成一个旅游景点，Low Memory Killer就是景点的门卫兼保安，然后我们每个进程的ADJ相当于手里的门票，有的人是VIP门票，有的人是普通门票。景点平常没人的时候还好，谁拿票都能进，当人逐渐拥挤的时候，保安就开始根据票的等级，往外轰人。E方案就是一个拿着普通票的妈妈，带着一个VIP的孩子去参观，D方案就是一个拿着普通票的妈妈，带着一个拿着中等票的孩子参观。当内存不够的时候，保安会先把两个妈妈轰出去，孩子们在里面看，再不够了，就会把D孩子给轰出去。这么看来，显然E的效果更好一些，不过由于Android系统对于VIP票的发放没有节制，大家都可以领VIP票，那也就是相当于没有VIP票了。所以如果E方案是一种精明，那么D才是真正的智慧。将调度权还给系统，做好自己，维护好整个Android生态。  </p>
<p>其实现阶段，如果公司要做一个后台类型的应用，我个人也是会选择追逐眼前里利益，采用E方案的，这也是不得已而为之，大家都利用漏洞拿VIP票，你不拿，将来做出来的APP出了偏差，你是要负责任的，所以还是希望Android能把漏洞堵住，把内存分配给真正需要的人，而我们自己也应该遵守规矩，维护整个生态平衡。<br>还有一点，是因为现在部分Root的手机都有优化大师，其实这个优化大师，就好比是个临时工门卫，告诉你他能解决景区爆满问题，实际上他的做法是，把一些票的等级降低，比如把中等票变成赠票，然后给你名正言顺的轰出去，听着是不是很耳熟？“让一部分人先富裕起来，然后把不富裕的杀掉，达成共同富裕。”  </p>
<p>我的测试机之前装了某款优化软件，然后，在正常手机上的adj的值，都有一定程度的降低，来我们上证据。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1-king.png" alt=""></p>
<font color="gray" size="2">上图为D方案下，Service进程的oom_adj、oom_score、oom_score_adj的值</font>  

<p>看到没，安装了优化应用之后，本应该adj=5的活跃服务进程，被调整为8，意思是不活跃的服务进程，这种做法本身就违反了最初Android设计的思想。</p>
<p>还有<img src="http://ogsbxb571.bkt.clouddn.com/pem-3-king.png" alt=""></p>
<font color="gray" size="2">上图为E方案下，主进程在按了back键退出之后进程的oom_adj、oom_score、oom_score_adj的值</font>  

<p>本来应该adj=9的缓存进程，调整为adj=11。adj=11在Android中都没给出定义。</p>
<p>所以，选择E也是无奈之举。还是呼吁大家要克制吧，维护Android的生态系统是每个工程师的责任。</p>
<p>“喜欢是放肆，但爱是克制” — 阿尔伯特·爱因斯坦 [手动滑稽]</p>
<h3 id="多模块应用"><a href="#多模块应用" class="headerlink" title="多模块应用"></a>多模块应用</h3><p>多进程还有一种非常有用的场景，就是多模块应用。比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。  </p>
<p>首先多进程开发能为应用解决了OOM问题，Android对内存的限制是针对于进程的，这个阈值可以是48M、24M、16M等，视机型而定，所以，当我们需要加载大图之类的操作，可以在新的进程中去执行，避免主进程OOM。  </p>
<p>多进程不光解决OOM问题，还能更有效、合理的利用内存。我们可以在适当的时候生成新的进程，在不需要的时候及时杀掉，合理分配，提升用户体验。减少系统被杀掉的风险。  </p>
<p>多进程还能带来一个好处就是，单一进程崩溃并不影响整体应用的使用。例如我在图片浏览进程打开了一个过大的图片，java heap 申请内存失败，但是不影响我主进程的使用，而且，还能通过监控进程，将这个错误上报给系统，告知他在什么机型、环境下、产生了什么样的Bug，提升用户体验。  </p>
<p>再一个好处就是，当我们的应用开发越来越大，模块越来越多，团队规模也越来越大，协作开发也是个很麻烦的事情。项目解耦，模块化，是这阶段的目标。通过模块解耦，开辟新的进程，独立的JVM，来达到数据解耦目的。模块之间互不干预，团队并行开发，责任分工也明确。至于模块化开发与多进程的结合，后续会写一篇专门的文章来研究这个问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于多进程的使用场景今天大概先说这么多。使用多进程开发还是有很多好处的，不过也有不少坑，下一篇文章我就想总结一下<a href="http://blog.spinytech.com/2016/11/20/android_multiple_process_notice/" target="_blank" rel="external">《多进程开发注意事项》</a>。 </p>
<p>最后，多进程不一定适合所有的应用，合理利用分配进程，使程序更加稳定，才是我们追求的目标。  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#111;&#x3a;&#115;&#x70;&#x69;&#110;&#x79;&#x2e;&#116;&#101;&#99;&#x68;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;">&#115;&#x70;&#x69;&#110;&#x79;&#x2e;&#116;&#101;&#99;&#x68;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109;</a></p>
<p>本文相关源码地址：<a href="https://github.com/SpinyTech/MultipleProcess" target="_blank" rel="external">MultipleProcess</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇&lt;a href=&quot;http://blog.spinytech.com/2016/11/15/android_multiple_process/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Android多进程介绍》&lt;/a&gt;中，我们大概了解了一下
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="多进程" scheme="http://spinytech.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="架构思考" scheme="http://spinytech.github.io/tags/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Android多进程介绍</title>
    <link href="http://spinytech.github.io/2016/11/15/android_multiple_process/"/>
    <id>http://spinytech.github.io/2016/11/15/android_multiple_process/</id>
    <published>2016-11-15T12:00:00.000Z</published>
    <updated>2016-11-22T02:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android中，默认情况下，同一应用的所有组件均运行在同一进程中，且大多数应用都不会改变这一点。不过，单进程开发并不是Android应用的全部，今天我们就来说说Android中的多进程开发以及多进程的使用场景。  </p>
<h2 id="多进程介绍"><a href="#多进程介绍" class="headerlink" title="多进程介绍"></a>多进程介绍</h2><p>本篇文章内容基于<a href="https://developer.android.com/guide/components/processes-and-threads.html#Processes" target="_blank" rel="external">Android Developer官网</a></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>我们都知道Android系统是基于Linux改造而来的，进程系统也是一脉相承，进程，其实就是程序的具体实现。当程序第一次启动，Android会启动一个Linux进程（具体由Zygote fork出来）以及一个主线程，默认的情况下，所有组件都将运行在该进程内。同一个应用由系统分配一个独立的Linux账户，该应用的产生的所有进程，都会是这同一个Linux账户。</p>
<h3 id="使用多进程"><a href="#使用多进程" class="headerlink" title="使用多进程"></a>使用多进程</h3><p>在开发中，我们通常会使用修改清单文件的<code>android:process</code>来达到多进程的目的。<code>activity</code>、<code>service</code>、<code>receiver</code> 和 <code>provider</code>均支持<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。如果<code>android:process</code>的value值以冒号开头的话，那么该进程就是私有进程，如果是以其他字符开头，那么就是公有进程，拥有相同 <font color="#ff0000">ShareUID</font> 的不同应用可以跑在同一进程里，后续我会专门针对公私有进程做个试验。另外，我们还可以通过设置<code>application</code>的<code>android:process</code>属性，来设置所有组件的默认进程。  </p>
<p>至于创建进程的具体源码分析，网上有一篇很详细的文章，在这就不重复造轮子了，有需要的朋友可以前往 <a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="external">理解Android进程创建流程</a></p>
<p>还有一种方法开启进程，是通过JNI，利用C/C++，调用fork()方法来生成子进程，一般开发者会利用这种方法来做一些daemon进程，来实现防杀，保活等效果，不过不是太推荐，这么做，毕竟Android生态系统需要大家维护。</p>
<h3 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h3><p>刚刚聊了一下进程的“生”，作为一个生命周期，是时候该聊聊进程的“死”了。这里再次呼吁一下大家能正视进程的“死”，合理的利用多进程，适当的杀死不必要的进程才是本篇文章所关注的焦点，我们不要把“永生”作为自己的实现目标，Android设备内存就那么大，就像地球一样，大家都永生了，生态系统就会破坏。那么Android系统是如何维护这个生态系统的呢？</p>
<p>其实也是类似于现实生活中的优胜略汰，Android利用<code>重要性层次结构</code>，就是将最重要的保留，杀掉不重要的进程。Android将<code>重要性层次结构</code>分为5个层级，分为了：（以下5级描述节选自<a href="https://developer.android.com/guide/components/processes-and-threads.html#Lifecycle" target="_blank" rel="external">Android进程生命周期</a>）  </p>
<ol>
<li><p>前台进程<br>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：  </p>
<ul>
<li>托管用户正在交互的 <code>Activity</code>（已调用 <code>Activity</code> 的 <code>onResume()</code> 方法）  </li>
<li>托管某个 <code>Service</code>，后者绑定到用户正在交互的 <code>Activity</code></li>
<li>托管正在“前台”运行的 <code>Service</code>（服务已调用 <code>startForeground()</code>）  </li>
<li>托管正执行一个生命周期回调的 <code>Service</code>（<code>onCreate()</code>、<code>onStart()</code> 或 <code>onDestroy()</code>）  </li>
<li><p>托管正执行其 <code>onReceive()</code> 方法的 <code>BroadcastReceiver</code>  </p>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。<br>这就需要依靠系统的资源。  </p>
</li>
</ul>
</li>
<li><p>可见进程<br>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：  </p>
<ul>
<li>托管不在前台、但仍对用户可见的 <code>Activity</code>（已调用其 <code>onPause()</code> 方法）。例如，如果前台 <code>Activity</code> 启动了一个对话框，允许在其后显示上一 <code>Activity</code>，则有可能会发生这种情况。</li>
<li><p>托管绑定到可见（或前台）<code>Activity</code> 的 <code>Service</code>。  </p>
<p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。  </p>
</li>
</ul>
</li>
<li><p>服务进程<br>正在运行已使用 <code>startService()</code> 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。  </p>
</li>
<li><p>后台进程<br>包含目前对用户不可见的 <code>Activity</code> 的进程（已调用 <code>Activity</code> 的 <code>onStop()</code> 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 <code>Activity</code> 的进程最后一个被终止。如果某个 <code>Activity</code> 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 <code>Activity</code> 时，<code>Activity</code> 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅 <code>Activity</code>文档。  </p>
</li>
<li><p>空进程<br>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。  </p>
</li>
</ol>
<p>根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 <code>Activity</code>，则会将此进程评定为可见进程，而不是服务进程。</p>
<p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p>
<p>由于运行服务的进程其级别高于托管后台 <code>Activity</code> 的进程，因此启动长时间运行操作的 <code>Activity</code> 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 <code>Activity</code> 更加持久时尤要如此。例如，正在将图片上传到网站的 <code>Activity</code> 应该启动服务来执行上传，这样一来，即使用户退出 <code>Activity</code>，仍可在后台继续执行上传操作。使用服务可以保证，无论 <code>Activity</code> 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p>
<h3 id="Low-Memory-Killer"><a href="#Low-Memory-Killer" class="headerlink" title="Low Memory Killer"></a>Low Memory Killer</h3><p>进程按照状态分完重要性之后，就要开始杀进程了。Android的Low Memory Killer基于Linux的OOM机制，在Linux中，内存是以页面(page)为单位，当申请页面分配不足的时候，系统会通过Low Memory Killer来杀掉bad进程，释放内存。Low Memory Killer会根据进程的adj级别以及所占的内存，来决定是否杀掉该进程，adj越大，占用内存越多，进程越容易被杀掉。<br>关于adj的分级，我们可以参考<a href="https://github.com/android/platform_frameworks_base/blob/marshmallow-release/services/core/java/com/android/server/am/ProcessList.java" target="_blank" rel="external">ProcessList.java</a>，这里面的常量定义了ADJ的分级。（7.0以后的adj分级与之前的不太一样(<a href="https://github.com/android/platform_frameworks_base/blob/nougat-release/services/core/java/com/android/server/am/ProcessList.java" target="_blank" rel="external">Processlist.java-Nougat</a>)，这个我们后续可以研究一下具体的改动是什么）  </p>
<h4 id="adj分级："><a href="#adj分级：" class="headerlink" title="adj分级："></a>adj分级：</h4><ul>
<li><p>UNKNOWN_ADJ = 16<br>级别最低级的进程，通常是被缓存的进程，但是系统也不清楚缓存的内容。  </p>
</li>
<li><p>CACHED_APP_MAX_ADJ = 15<br>这是一个只托管不可见的活动的进程，因此可以在没有任何中断的情况下被杀死。  </p>
</li>
<li><p>CACHED_APP_MIN_ADJ = 9<br>缓存进程，没有英文解释。  </p>
</li>
<li><p>SERVICE_B_ADJ = 8<br>不活跃的服务，不想adj=5的服务那么活跃。<br>PS:这里说一句，在root以后，有的系统优化大师，会把所有服务统一调成adj=8这个级别，来达到内存优化的目的，后面我们会说到。</p>
</li>
<li><p>PREVIOUS_APP_ADJ = 7<br>被切换的进程，一般是用户前一个使用的进程。两个应用来回切换，那么前一个应用一般adj设置为7。  </p>
</li>
<li><p>HOME_APP_ADJ = 6<br>与主应用程序有交互的进程。  </p>
</li>
<li><p>SERVICE_ADJ = 5<br>活跃的服务进程。  </p>
</li>
<li><p>HEAVY_WEIGHT_APP_ADJ = 4<br>高权重进程  </p>
</li>
<li><p>BACKUP_APP_ADJ = 3<br>正在备份的进程   </p>
</li>
<li><p>PERCEPTIBLE_APP_ADJ = 2<br>可感知进程（通常是前台Service进程）  </p>
</li>
<li><p>VISIBLE_APP_ADJ = 1<br>可见进程  </p>
</li>
<li><p>FOREGROUND_APP_ADJ = 0<br>前台进程  </p>
</li>
</ul>
<p>剩下的就是adj值为负数的进程，基本上都是系统集成，不在本文的讨论范围内。负数进程是不会被lmk杀掉的。</p>
<h4 id="如何查看进程优先级"><a href="#如何查看进程优先级" class="headerlink" title="如何查看进程优先级"></a>如何查看进程优先级</h4><p>首先通过 adb shell ps 指令查找对应进程的pid<br>然后通过 adb shell cat /proc/${pid}/oom_adj（设备需要root）返回对应进程的adj值。<br>还可以把oom_adj替换成oom_score或者oom_score_adj来查看这两项的数值，当oom_adj相同时，LowMemoryKiller会根据oom_score_adj和RSS内存大小来杀掉对应的进程。</p>
<h4 id="查看设备的内存临界值"><a href="#查看设备的内存临界值" class="headerlink" title="查看设备的内存临界值"></a>查看设备的内存临界值</h4><p>我们可以通过adb shell cat 查看下面两个文件<br>/sys/module/lowmemorykiller/parameters/adj<br>/sys/module/lowmemorykiller/parameters/minfree<br>（这里请注意，这两个文件是只可以写入的，cat之前请先用chmod赋予权限。）  </p>
<p>adj 代表的是oom_score_adj的值，对应的minfree则代表内存临界值。<br>比如我的测试机小米4C测试机对应的值就是：  </p>
<p>adj: 0,58,117,176,529,1000<br>这个值其实是oom_score_adj的值，用这个值*17再除1000四舍五入取整数，就是对应的adj的值，例如第二个值58即为 58*17/1000 = 1，对应的adj也就是1，所以这6个值对应的adj是0，1，2，3，9，15。1000默认就是15  </p>
<p>minfree: 18432,23040,27648,32256,56250,81250<br>这个值是页值，一页等于4KB，换算成MB大概是72，90，108，126，220，318<br>当可用内存小于318MB的时候，系统开始杀adj=15的进程，以此类推。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上，我们大概了解了一下Android进程、多进程、生命周期以及Low Memory Killer的相关知识。至于如何运用到实际开发当中，我们在下一篇文章<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/" target="_blank" rel="external">《Android多进程使用场景》</a>中继续探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android中，默认情况下，同一应用的所有组件均运行在同一进程中，且大多数应用都不会改变这一点。不过，单进程开发并不是Android应用的全部，今天我们就来说说Android中的多进程开发以及多进程的使用场景。  &lt;/p&gt;
&lt;h2 id=&quot;多进程介绍&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="Android" scheme="http://spinytech.github.io/categories/Android/"/>
    
    
      <category term="多进程" scheme="http://spinytech.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【译】如何恰当的在闪屏页加载繁重的数据和库</title>
    <link href="http://spinytech.github.io/2016/07/25/2016-07-25/"/>
    <id>http://spinytech.github.io/2016/07/25/2016-07-25/</id>
    <published>2016-07-25T03:50:57.000Z</published>
    <updated>2016-07-26T05:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我将为你们展示开发者开启App时，因为加载一些库和数据遇到的初始化非常慢的这种情况。在这种情况下，开发者通常不会在主线程中初始化，因为这样做会使整个App卡住。相反，开发者希望通过后台初始化数据和库，然后在主线程处理初始化结果。</p>
<h2 id="闪屏页-SplashActivity"><a href="#闪屏页-SplashActivity" class="headerlink" title="闪屏页 SplashActivity"></a>闪屏页 SplashActivity</h2><p>首先，如果你已经有了一些需要在自定义Application类中初始化的东西，你可能想着要做一个恰当的闪屏页。这意味着你点击App图标的同时，闪屏页已经完整的显示出来了。通过设置闪屏页Theme的背景图，我们可以轻易实现这个需求。</p>
<p>res/values/styles.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">style</span> <span class="attr">name</span>=<span class="string">"SplashTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.NoActionBar"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/background_splash<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span><br><span class="line">  <span class="attr">android:name</span>=<span class="string">".splash.SplashActivity"</span></span><br><span class="line">  <span class="attr">android:theme</span>=<span class="string">"@style/SplashTheme"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，闪屏页一般是放个logo，所以 <code>@drawable/background_splash</code> 可以写成一个 <code>layer-list</code></p>
<p>例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/holo_blue_dark"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bitmap</span></span><br><span class="line">      <span class="attr">android:gravity</span>=<span class="string">"center"</span></span><br><span class="line">      <span class="attr">android:src</span>=<span class="string">"@drawable/ic_hockey_stick"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>顺便说一下，如果你用了矢量的 <code>&lt;vector&gt;</code> 作为 <code>&lt;src&gt;</code> 赋予 <code>&lt;bitmap&gt;</code> ，那么请你注意<a href="http://stackoverflow.com/questions/34831142/how-to-center-vector-drawable-in-layer-list-without-scaling" target="_blank" rel="external">这个bug</a>。<br>坑爹的是，这个bug现在没办法解决，所以在API小于23的时候你只能用PNG来代替矢量图。</p>
<h2 id="初始化数据和库"><a href="#初始化数据和库" class="headerlink" title="初始化数据和库"></a>初始化数据和库</h2><p>现在我们已经可以瞬间打开App了，那么接下来该怎么做？我们应该想办法如何初始化这种加载缓慢的库。<code>Dagger2</code> 和 <code>RxJava</code> 或许对我们有帮助。</p>
<p>如果只是在闪屏页需要这种‘长初始化’库，来加载必要的资源，那么我们可以定义一个 <code>SplashModule</code> ，那么我们就能把所有库的引用都写到这里。可以，这很解耦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@NonNull</span> <span class="meta">@SplashScope</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> SplashLibrary <span class="title">splashLibrary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SplashLibrary(); <span class="comment">// Takes &gt;5 seconds.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们还不能注入 <code>@Inject</code> ，因为这样做会阻塞我们的主线程。我们需要通过RxJava来创建一个观察者 <code>Observable</code> ，用来接收 <code>SplashLibrary</code> 实例，由于我们用了懒加载 <code>Lazy&lt;&gt;</code> ，我们的库仍未初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashModule</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="meta">@NonNull</span> <span class="meta">@SplashScope</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Observable&lt;SplashLibrary&gt; <span class="title">observable</span><span class="params">(<span class="keyword">final</span> Lazy&lt;SplashLibrary&gt; library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;SplashLibrary&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Observable&lt;SplashLibrary&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.just(library.get());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注入这个库"><a href="#注入这个库" class="headerlink" title="注入这个库"></a>注入这个库</h2><p>最后，我们要把库 <code>Observable&lt;SplashLibrary&gt;</code> 注入到我们的闪屏页 <code>SplashActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Observable which will emit an item when fully initialized. */</span></span><br><span class="line"><span class="meta">@Inject</span> Observable&lt;SplashLibrary&gt; splashLibraryObservable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Subscription to unsubscribe in onStop(). */</span></span><br><span class="line"><span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  subscription = splashLibraryObservable</span><br><span class="line">      <span class="comment">// Init library on another thread.</span></span><br><span class="line">      .subscribeOn(Schedulers.computation())</span><br><span class="line">      <span class="comment">// Observe result on the main thread.</span></span><br><span class="line">      .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">      .subscribe(<span class="keyword">new</span> Action1&lt;SplashLibrary&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Use the initialized library.</span></span><br><span class="line"></span><br><span class="line">          Intent intent = <span class="keyword">new</span> Intent(activity, MainActivity.class);</span><br><span class="line">          startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿还有一些个小问题等着你：</p>
<ol>
<li>库加载的过程中，可能会抛出异常，我们需要在 <code>onError</code> 方法中去处理它们。</li>
<li>库加载过程中，用户可能会离开此页或旋转屏幕。由于我们在回调函数中引用了 <code>Activity</code> ，所以有可能导致内存泄露。</li>
</ol>
<h2 id="处理加载过程中的异常"><a href="#处理加载过程中的异常" class="headerlink" title="处理加载过程中的异常"></a>处理加载过程中的异常</h2><p>为了处理这个问题，我们可以传一个 <code>Observer</code> 实例给 <code>subscribe()</code> 方法。</p>
<p>很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;SplashLibrary&gt;() &#123;</span><br><span class="line">  <span class="keyword">final</span> String TAG = <span class="string">"Observer&lt;SplashLibrary&gt;"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">"Library init error!"</span>, e);</span><br><span class="line">    <span class="comment">// Possible UI interaction.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Use the initialized library.</span></span><br><span class="line"></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(activity, MainActivity.class);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">    finish();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="处理内存溢出问题"><a href="#处理内存溢出问题" class="headerlink" title="处理内存溢出问题"></a>处理内存溢出问题</h2><p>在这个例子中，我们不能从 <code>Subscription</code> 中取消订阅，因为对象一旦加载开始，<code>Subscription</code> 就不能释放资源了。这也就是为什么在内存中还存在着已经销毁的Activity对象，它导致了内存泄露。如果我们在Application中加入了严苛模式 <code>StrictMode.enableDefaults();</code> ，我们可以很容易的在 <code>LogCat</code> 中看到看到Log。当我们旋转屏幕，严苛模式显示了Acitivty的实例信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E/StrictMode: class .SplashActivity; instances=2; limit=1</span><br><span class="line">android.os.StrictMode$InstanceCountViolation: class .SplashActivity; instances=2; limit=1</span><br><span class="line">at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)</span><br></pre></td></tr></table></figure>
<p>这就是为什么我们需要在创建的 <code>Observer</code> 中释放Activity的引用了。我们可以创建一个静态类去实现 <code>Observer&lt;SplashActivity&gt;</code> ，在给他传入一个Activity的引用，然后在 <code>onDestroy</code> 中清除引用。这样，我们可以确保没有内存泄漏异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnInitObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">SplashLibrary</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> SplashActivity splashActivity;</span><br><span class="line"></span><br><span class="line">  OnInitObserver(<span class="meta">@NonNull</span> SplashActivity splashActivity) &#123;</span><br><span class="line">    <span class="keyword">this</span>.splashActivity = splashActivity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(SplashLibrary splashLibrary)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    splashActivity = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">  onInitObserver.releaseListener();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住这几点，我们就能轻松地在闪屏页中加载库、数据，执行网络请求或者做一些其他的繁重的任务。</p>
<p>感谢阅读，获取源码请点<a href="https://github.com/zsavely/FastStartUp" target="_blank" rel="external">这里</a>。</p>
<hr>
<p>原文地址：<a href="http://szagurskii.com/blog/how-to-load-heavy-libraries-on-splash-screen/?utm_source=Android+Weekly&amp;utm_campaign=644e634e1a-Android_Weekly_215&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-644e634e1a-338049121" target="_blank" rel="external">How to Load Heavy Libraries on Splash Screen [the proper way]</a></p>
<p>作者：SAVELII ZAGURSKII</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这篇文章中，我将为你们展示开发者开启App时，因为加载一些库和数据遇到的初始化非常慢的这种情况。在这种情况下，开发者通常不会在主线程中初始化，因为这样做会使整个App卡住。相反，开发者希望通过后台初始化数据和库，然后在主线程处理初始化结果。&lt;/p&gt;
&lt;h2 id=&quot;闪屏页
    
    </summary>
    
      <category term="翻译" scheme="http://spinytech.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://spinytech.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxJava" scheme="http://spinytech.github.io/tags/RxJava/"/>
    
      <category term="Dagger2" scheme="http://spinytech.github.io/tags/Dagger2/"/>
    
  </entry>
  
</feed>
