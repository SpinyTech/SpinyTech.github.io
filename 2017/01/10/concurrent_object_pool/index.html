<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>高并发对象池思考 | Spiny</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">高并发对象池思考</h1><a id="logo" href="/.">Spiny</a><p class="description">Stay Hungry, Stay Foolish, Stay Uncomfortable.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">高并发对象池思考</h1><div class="post-meta">Jan 10, 2017<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2017/01/10/concurrent_object_pool/" href="/2017/01/10/concurrent_object_pool/#comments" class="ds-thread-count"></a><div class="post-content"><p>这两天在整理一套Android的路由框架，在整理的过程中，发现在路由消息传递过程中，传输载体类会大量的生成，对于这种载体类来说，他们本身是可重复利用的，并不需要大量的创建，大量的废弃，所以，我打算引入对象池，来解决类的重复创建问题。</p>
<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>Java对象的生命周期大致包括三个阶段：<strong>对象的创建，对象的使用，对象的清除</strong>。因此，对象的生命周期长度可用如下的表达式表示：T = T1 + T2 +T3。其中T1表示对象的创建时间，T2表示对象的使用时间，而T3则表示其清除时间。由此，我们可以看出，只有T2是真正有效的时间，而T1、T3则是对象本身的开销。所以，避免和减少T1和T3的时间，能有效的提升程序的性能。</p>
<h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>在EffectJava的第五条建议中，明确给出了<strong>“避免创建不必要的对象”</strong>这样的建议。对于<strong>可重复利用的对象</strong>，我们不应该频繁的创建销毁，而是应该反复利用。  </p>
<p>重复利用对象，我们就需要建一个对象池，把所有可复用的对象都统一放到池中，同时对外提供<code>obtain()</code>方法来获取对象。通常，我们利用静态对象数组来实现对象池。</p>
<p>对象池的初始化策略分为两种，一种是统一初始化，即在特定时机统一初始化池内所有对象，第一次使用的时候会有一定的开销。另一种是即时初始化，就是在使用中进行初始化，每次都会有一定的开销，直到池内充满。</p>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>在对象池创建好之后，我们就需要考虑如何分配、回收对象池的对象了。由于是路由系统的载体类，所以势必会有多线程进行访问，我们还要考虑到线程安全，以及并发性能。  </p>
<p>关于线程安全，一般的做法是通过<code>synchronized</code>关键字来进行线程同步。不过这么做的话，相当于是对<code>obtain()</code>函数加了<strong>悲观锁</strong>。这么做虽然可以有效的防止同步问题，而且<code>synchronized</code>关键字也经过了JVM多次性能优化，不过，在性能上依然不能满足高并发的要求。</p>
<p>这时候我们参考可以参考<code>ConcurrentHashMap</code>，利用<strong>CAS算法</strong>(非阻塞同步算法)实现乐观锁。我们在类中创建一个<code>AtomicBoolean</code>变量，命名为<code>isIdle</code>，默认值为true(空闲状态)，当多个线程去争抢一个对象的时候，会调用<code>isIdle.compareAndSet(true,false)</code>，该方法会返回boolean类型的结果，如果返回true，则表明竞争成功，isIdle被设置为false（占用中），如果返回false，则表明该类已经被别的线程所占用，重新申请另外的对象，直到该对象的isIdle竞争成功。</p>
<p>相关代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 顺序计数器</span><br><span class="line">private static AtomicInteger sIndex;</span><br><span class="line">// 空闲标识</span><br><span class="line">AtomicBoolean isIdle;</span><br><span class="line">// 计数器重置参数</span><br><span class="line">private static final int RESET_NUM = 1000;</span><br><span class="line">public static ConcurrentRouterRequest obtain()&#123;</span><br><span class="line">    // 获取下一个计数器的值</span><br><span class="line">    int index = sIndex.getAndIncrement();</span><br><span class="line">    // 如果计数器过大，则置0</span><br><span class="line">    if(index&gt;RESET_NUM)&#123;</span><br><span class="line">        sIndex.compareAndSet(index,0);</span><br><span class="line">        if(index&gt;RESET_NUM*2)&#123;</span><br><span class="line">            sIndex.set(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算计数器对应对象数组的对象下标</span><br><span class="line">    int num = index&amp;(length-1);</span><br><span class="line"></span><br><span class="line">    // 获取对应对象</span><br><span class="line">    ConcurrentRouterRequest target = table[num];</span><br><span class="line"></span><br><span class="line">    // 竞争该对象的空闲标识，其中第一个参数true是我们希望的值，第二个参数是需要设置的值false。  </span><br><span class="line">    // 如果设置成功，那么直接返回target，如果失败，则继续寻找下一个空闲的对象。</span><br><span class="line">    if(target.isIdle.compareAndSet(true,false))&#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return obtain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要说一下，关于对象池如何分配对象的问题，这里采用的是顺序分配，每次获取都会在对象池中往后顺延一位。同时，对象池的长度默认为2的N次方，这样做的好处是通过按位与计算，能快速找出对象池中的数组下标，这个模仿了HashMap中的Hash值存储。</p>
<h3 id="测试对比"><a href="#测试对比" class="headerlink" title="测试对比"></a>测试对比</h3><p>模拟的条件是100条线程并发请求，每单个线程请求1000次，总计十万次并发。</p>
<table>
<thead>
<tr>
<th></th>
<th>时间开销</th>
<th>内存开销</th>
</tr>
</thead>
<tbody>
<tr>
<td>新建对象</td>
<td>220ms</td>
<td>1.53MB</td>
</tr>
<tr>
<td>利用对象池</td>
<td>180ms</td>
<td>1.25KB</td>
</tr>
</tbody>
</table>
<p>第一种情况是直接用new关键字新建对象，处理请求，最后的结果是耗时220ms，内存消耗100000*16(byte)=1.53MB。</p>
<p>第二种情况是使用对象池处理请求，最后耗时180ms，内存消耗为64*20(byte)=1.25KB。</p>
<p>通过对比我们可以看出，首先，由于减少了对象的创建，虽然多了同步，不过在时间性能上，对象池还是优于新建对象，大概提升了20%左右的性能。该时间还不包括GC回收的开销，如果加上的话，性能提升会更明显。其次，在内存上面，两者的差距是1000倍左右的，极大地节省了内存的开销，减少了GC的触发。</p>
<h3 id="对象池实现"><a href="#对象池实现" class="headerlink" title="对象池实现"></a>对象池实现</h3><p>下面放一个纯Java实现的高并发对象池</p>
<p>对象池：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public final class ObjectPool&lt;OBJECT extends ObjectPool.RecyclableObject&gt; &#123;</span><br><span class="line">    private OBJECT[] mTable;</span><br><span class="line">    private AtomicInteger mOrderNumber;</span><br><span class="line">    public static int RESET_NUM = 1000;</span><br><span class="line"></span><br><span class="line">    public ObjectPool(OBJECT[] inputArray) &#123;</span><br><span class="line">        mOrderNumber = new AtomicInteger(0);</span><br><span class="line">        mTable = inputArray;</span><br><span class="line">        if (mTable == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;The input array is null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int length = inputArray.length;</span><br><span class="line">        if ((length &amp; length - 1) != 0) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;The length of input array is not 2^n.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void recycle(OBJECT object) &#123;</span><br><span class="line">        object.isIdle.set(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public OBJECT obtain() &#123;</span><br><span class="line">        int index = mOrderNumber.getAndIncrement();</span><br><span class="line">        if (index &gt; RESET_NUM) &#123;</span><br><span class="line">            mOrderNumber.compareAndSet(index, 0);</span><br><span class="line">            if (index &gt; RESET_NUM * 2) &#123;</span><br><span class="line">                mOrderNumber.set(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int num = index &amp; (mTable.length - 1);</span><br><span class="line"></span><br><span class="line">        OBJECT target = mTable[num];</span><br><span class="line"></span><br><span class="line">        if (target.isIdle.compareAndSet(true, false)) &#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 注意：此处可能会因为OBJECT回收不及时，而导致栈溢出。</span><br><span class="line">            // 请增加retryTime参数，以及retryTime过多后的判断。</span><br><span class="line">            // 具体思路请参考</span><br><span class="line">            // https://github.com/SpinyTech/ModularizationArchitecture/blob/master/macore/src/main/java/com/spinytech/macore/router/RouterRequest.java</span><br><span class="line">            // 中的obtain()及obtain(int retryTime);方法</span><br><span class="line">            return obtain();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract static class RecyclableObject &#123;</span><br><span class="line">        AtomicBoolean isIdle = new AtomicBoolean(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestObject[] array = new TestObject[32];</span><br><span class="line">        for(int i = 0 ; i &lt; 32 ;i++)&#123;</span><br><span class="line">            array[i] = new TestObject();</span><br><span class="line">        &#125;</span><br><span class="line">        final ObjectPool&lt;TestObject&gt; objectPool = new ObjectPool&lt;&gt;(array);</span><br><span class="line"></span><br><span class="line">        for(int i = 0 ; i &lt; 50; i++)&#123;</span><br><span class="line">            new Thread(&quot;Thread:&quot;+i)&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    super.run();</span><br><span class="line">                    for(int j = 0 ; j &lt; 50 ; j++)&#123;</span><br><span class="line">                        TestObject testObject = objectPool.obtain();</span><br><span class="line">                        testObject.print(getName(),&quot;--index:&quot;+j);</span><br><span class="line">                        objectPool.recycle(testObject);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class TestObject extends ObjectPool.RecyclableObject&#123;</span><br><span class="line">        public TestObject()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        public void print(String thread, String index)&#123;</span><br><span class="line">            System.out.println(thread+index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#58;&#115;&#x70;&#x69;&#x6e;&#121;&#46;&#116;&#x65;&#x63;&#x68;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;">&#115;&#x70;&#x69;&#x6e;&#121;&#46;&#116;&#x65;&#x63;&#x68;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.spinytech.com/2017/01/10/concurrent_object_pool/" data-id="ciz7r0bo6001tbdfy6ecqopgz" class="article-share-link">分享到</a><div class="tags"><a href="/tags/高并发/">高并发</a><a href="/tags/对象池/">对象池</a></div><div class="post-nav"><a href="/2017/02/01/ma_get_start_cn/" class="pre">ModularizationArchitecture 使用教程</a><a href="/2016/12/28/android_modularization/" class="next">Android架构思考(模块化、多进程)</a></div><div data-thread-key="2017/01/10/concurrent_object_pool/" data-title="高并发对象池思考" data-url="http://blog.spinytech.com/2017/01/10/concurrent_object_pool/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2017/01/10/concurrent_object_pool/" data-title="高并发对象池思考" data-url="http://blog.spinytech.com/2017/01/10/concurrent_object_pool/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.spinytech.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/高并发/" style="font-size: 15px;">高并发</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/对象池/" style="font-size: 15px;">对象池</a> <a href="/tags/ModularizationArchitecture/" style="font-size: 15px;">ModularizationArchitecture</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Dagger2/" style="font-size: 15px;">Dagger2</a> <a href="/tags/多进程/" style="font-size: 15px;">多进程</a> <a href="/tags/架构思考/" style="font-size: 15px;">架构思考</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/View绘制/" style="font-size: 15px;">View绘制</a> <a href="/tags/Android视图/" style="font-size: 15px;">Android视图</a> <a href="/tags/Architecture/" style="font-size: 15px;">Architecture</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/ma_get_start_en/">The guide of the ModularizationArchitecture</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/01/ma_get_start_cn/">ModularizationArchitecture 使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/10/concurrent_object_pool/">高并发对象池思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/28/android_modularization/">Android架构思考(模块化、多进程)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/19/android_view_on_draw/">View绘制分析笔记之onDraw</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/android_view_on_layout/">View绘制分析笔记之onLayout</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/android_view_on_measure/">View绘制分析笔记之onMeasure</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/android_view_draw_setcontentview/">Android 视图及View绘制分析笔记之setContentView</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/android_multiple_process_notice/">Android多进程注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/android_multiple_process_usage_scenario/">Android多进程使用场景</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Spiny.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'SpinyTech'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>