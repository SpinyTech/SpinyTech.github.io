<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android多进程使用场景 | Spiny</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android多进程使用场景</h1><a id="logo" href="/.">Spiny</a><p class="description">Stay Hungry, Stay Foolish, Stay Uncomfortable.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android多进程使用场景</h1><div class="post-meta">Nov 17, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/11/17/android_multiple_process_usage_scenario/" href="/2016/11/17/android_multiple_process_usage_scenario/#comments" class="ds-thread-count"></a><div class="post-content"><p>*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</p>
<p>在上一篇<a href="http://blog.spinytech.com/2016/11/15/android_multiple_process/" target="_blank" rel="external">《Android多进程介绍》</a>中，我们大概了解了一下Android中的进程的概念以及其生命周期，另外还有Low Memory Killer相关知识。了解完原理，就该进行实践了。今天这篇文章，我们就来聊一聊，到底如何利用多进程开发，使我们的应用更稳定、用户体验更好？换言之就是Android开发中多进程开发的使用场景分析。</p>
<h2 id="什么情况需要使用多进程"><a href="#什么情况需要使用多进程" class="headerlink" title="什么情况需要使用多进程"></a>什么情况需要使用多进程</h2><h3 id="常驻后台任务应用"><a href="#常驻后台任务应用" class="headerlink" title="常驻后台任务应用"></a>常驻后台任务应用</h3><p>类似音乐类、跑步健身类、手机管家类等长时间需要在后台运行的应用。这些应用的特点就是，当用户切到别的应用，或者关掉手机屏幕的时候，应用本身的核心模块还在正常运行，提供服务。如果因为手机内存过低，或者是进程重要性降低，导致应用被杀掉，后台服务停止，对于这些应用来说，就是灭顶之灾。合理利用多进程，将核心后台服务模块和其他UI模块进行分离，保证应用能更稳定的提供服务，从而提升用户体验。</p>
<h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p>现在要做一款音乐播放器，现在有以下几种方案：<br>A. 在Activity中直接播放音乐。<br>B. 启动后台Service，播放音乐。<br>C. 启动前台Service，播放音乐。<br>D. 在新的进程中，启动后台Service，播放音乐。<br>E. 在新的进程中，启动前台Service，播放音乐。  </p>
<h4 id="首先我们分析A"><a href="#首先我们分析A" class="headerlink" title="首先我们分析A"></a>首先我们分析A</h4><p>在A中，我们的播放器是直接在activity中启动的。首先这么做肯定是不对的，我们需要在后台播放音乐，所以当activity退出后就播不了了，之所以给出这个例子是为了控制变量作对比。<br>然后我们来看下A的使用场景。<br>音乐播放器无非是打开app，选歌，播放，退到桌面，切其他应用。我们选取了三个场景，打开、按home切换其他应用、按back退回桌面。让我们看一下A的相对应的oom_adj、oom_score、oom_score_adj的值。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pa-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>当我们应用在前台的时候，无论adj还是score还是score_adj，他们的值都非常的小，基本不会被LMK所杀掉，但是当我们按了Home之后，进程的adj就会急剧增大，变为7，相应的score和score_adj也会增大。在上篇文章中我们得知，adj=7即为被切换的进程，两个进程来回切换，上一个进程就会被设为7。当我们按Back键的时候，adj就会被设为9，也就是缓存进程，优先级比较低，有很大的几率被杀掉。  </p>
<h4 id="接着我们分析B"><a href="#接着我们分析B" class="headerlink" title="接着我们分析B"></a>接着我们分析B</h4><p>B是直接启动一个后台service并且播放音乐，这个处理看起来比A好了很多，那么实际上，B的各个场景的优先级和A又有什么不同呢？让我们来看下B的对应的打开、切换、退出相应的adj、score、score_adj的值。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pb-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>B的情况其实是与A类似的，三种状态的adj、score_adj的值都是一样的，只有score有一点出入，其实分析源码得知，LMK杀进程的时候，score的左右其实并不大，所以我们暂时忽略它。所以，与A相比，他们的adj和score_adj的值都相同，如果遇到内存不足的情况下，这两个应用谁占得内存更大，谁就会被杀掉。不过鉴于A实在activity中播放音乐，所以B还是比A略好的方案。  </p>
<font color="blue" size="3">//TODO 疑问</font><br>这里有朋友肯定要问了，为什么切到后台后，adj的值是7而不是5，后台不是还有service在跑吗？<br>其实这里我也没有搞太明白，至少没找到源码给我解惑。不过，网上普遍的解答是，我们所讨论的优先级是进程级别的，并非是activity、service这样的组件级别。所以对系统而言，单进程的<code>activity</code>和<code>非前台service</code>这样的应用，当切换到其他应用或者按back键退出应用的时候，系统会认为这是个缓存进程，随时都可以杀掉的。<br><br>#### 接下来分析C<br>C的话是启动一个前台Service来播放音乐。让我们来看一下对应的值。<br><br><br><img src="http://ogsbxb571.bkt.clouddn.com/pc-1.png" alt=""><br><font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pc-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>在前台的时候，和AB是一样的，adj都是0，当切到后台，或者back结束时，C对应的adj就是2，也就是可感知进程。adj=2可以说是很高优先级了，非root手机，非系统应用已经没有办法将其杀掉了。具体可参见<a href="https://github.com/android/platform_frameworks_base/blob/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="external">ActivityManagerService</a>的<code>killBackgroundProcesses</code>方法以及<code>killPackageProcessesLocked</code>方法。adj&lt;5的应用不会被杀掉。<br>总的来说，C方案比B优秀，拥有前台Service的C更不容易被系统或者其他应用所杀掉了，进程的优先级一下子提高到了2，相对于B来说更稳定，用户体验更好。不过有一点不足是必须启动一个前台service。不过现在大部分的音乐类软件都会提供一个前台service，也就不是什么缺点了。其实也是有灰色方法可以启动一个不显示通知的前台service，这里就不过多介绍了。  </p>
<p>那么还有可改进的余地吗？<br>答案当然是肯定的。</p>
<h4 id="让我们来看看D"><a href="#让我们来看看D" class="headerlink" title="让我们来看看D"></a>让我们来看看D</h4><p>终于我们的主角，多进程登场了。<br>D把应用进行了拆分，把用于播放音乐的service放到了新的进程内，让我们看一下对应的值。<br><img src="http://ogsbxb571.bkt.clouddn.com/pdm-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/pdm-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>上面三张图对应的是D应用主进程的ADJ相关值，我们可以看出来，跟A类似，adj都是0，7，9。由于少了service部分，内存使用变少，最后计算出的oom_score_adj也更低了，意味着主进程部分也更不容易被杀死。  </p>
<p>下面我们看下拆分出的service的相关值  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1.png" alt=""></p>
<font color="gray" size="2">上图后台service的oom_adj、oom_score、oom_score_adj的值</font>  

<p>因为是service进程，所以不受打开，关闭，切换所影响，这里就放了一张图。<br>我们可以看到，service的adj值一直是5，也就是活跃的服务进程，相比于B来说，优先级高了不少。不过对于C来说，其实这个方案反倒不如C的adj=2的前台进程更稳定。但是D可以自主释放主进程，使D实际所占用的内存很小，从而不容易被杀掉。那么到底C和D谁是更优秀的设计？我个人认为，在ABCDE这5个设计中，D是最具智慧的设计，具体是为什么？先卖个关子，等我们说完了E，再作总结。</p>
<h4 id="那就赶紧分析E吧"><a href="#那就赶紧分析E吧" class="headerlink" title="那就赶紧分析E吧"></a>那就赶紧分析E吧</h4><p>E也是使用了多进程，并且在新进程中，使用了前台service，先来看下对应的值。<br><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-1.png" alt=""></p>
<font color="gray" size="2">上图为打开状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-2.png" alt=""></p>
<font color="gray" size="2">上图为按了Home键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p><img src="http://ogsbxb571.bkt.clouddn.com/new-pem-3.png" alt=""></p>
<font color="gray" size="2">上图为按了Back键状态下oom_adj、oom_score、oom_score_adj的值</font>  

<p>这个不多解释，和ABD基本差不多，都是0，7，9。我们看下拆分出来的进程的值。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/per-1.png" alt=""></p>
<font color="gray" size="2">上图后台service的oom_adj、oom_score、oom_score_adj的值</font>  

<p>我们可以看到，这个进程的值是2，像C方案，非常小，非常稳定，而且，我们还可以在系统进入后台后，手动杀掉主进程，使整个应用的内存消耗降到最低，内存低，优先级又高，E获得了今天的最稳定的方案奖。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ABCDE，5种方案都已经分析完了。显然，E是最稳定的方案，不过，我刚才说过，我个人最倾向于D方案，并且认为D是最智慧的方案，这是为什么呢？<br>其实我们可以做个比喻，把整个Android系统比喻成一个旅游景点，Low Memory Killer就是景点的门卫兼保安，然后我们每个进程的ADJ相当于手里的门票，有的人是VIP门票，有的人是普通门票。景点平常没人的时候还好，谁拿票都能进，当人逐渐拥挤的时候，保安就开始根据票的等级，往外轰人。E方案就是一个拿着普通票的妈妈，带着一个VIP的孩子去参观，D方案就是一个拿着普通票的妈妈，带着一个拿着中等票的孩子参观。当内存不够的时候，保安会先把两个妈妈轰出去，孩子们在里面看，再不够了，就会把D孩子给轰出去。这么看来，显然E的效果更好一些，不过由于Android系统对于VIP票的发放没有节制，大家都可以领VIP票，那也就是相当于没有VIP票了。所以如果E方案是一种精明，那么D才是真正的智慧。将调度权还给系统，做好自己，维护好整个Android生态。  </p>
<p>其实现阶段，如果公司要做一个后台类型的应用，我个人也是会选择追逐眼前里利益，采用E方案的，这也是不得已而为之，大家都利用漏洞拿VIP票，你不拿，将来做出来的APP出了偏差，你是要负责任的，所以还是希望Android能把漏洞堵住，把内存分配给真正需要的人，而我们自己也应该遵守规矩，维护整个生态平衡。<br>还有一点，是因为现在部分Root的手机都有优化大师，其实这个优化大师，就好比是个临时工门卫，告诉你他能解决景区爆满问题，实际上他的做法是，把一些票的等级降低，比如把中等票变成赠票，然后给你名正言顺的轰出去，听着是不是很耳熟？“让一部分人先富裕起来，然后把不富裕的杀掉，达成共同富裕。”  </p>
<p>我的测试机之前装了某款优化软件，然后，在正常手机上的adj的值，都有一定程度的降低，来我们上证据。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/pdr-1-king.png" alt=""></p>
<font color="gray" size="2">上图为D方案下，Service进程的oom_adj、oom_score、oom_score_adj的值</font>  

<p>看到没，安装了优化应用之后，本应该adj=5的活跃服务进程，被调整为8，意思是不活跃的服务进程，这种做法本身就违反了最初Android设计的思想。</p>
<p>还有<img src="http://ogsbxb571.bkt.clouddn.com/pem-3-king.png" alt=""></p>
<font color="gray" size="2">上图为E方案下，主进程在按了back键退出之后进程的oom_adj、oom_score、oom_score_adj的值</font>  

<p>本来应该adj=9的缓存进程，调整为adj=11。adj=11在Android中都没给出定义。</p>
<p>所以，选择E也是无奈之举。还是呼吁大家要克制吧，维护Android的生态系统是每个工程师的责任。</p>
<p>“喜欢是放肆，但爱是克制” — 阿尔伯特·爱因斯坦 [手动滑稽]</p>
<h3 id="多模块应用"><a href="#多模块应用" class="headerlink" title="多模块应用"></a>多模块应用</h3><p>多进程还有一种非常有用的场景，就是多模块应用。比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。  </p>
<p>首先多进程开发能为应用解决了OOM问题，Android对内存的限制是针对于进程的，这个阈值可以是48M、24M、16M等，视机型而定，所以，当我们需要加载大图之类的操作，可以在新的进程中去执行，避免主进程OOM。  </p>
<p>多进程不光解决OOM问题，还能更有效、合理的利用内存。我们可以在适当的时候生成新的进程，在不需要的时候及时杀掉，合理分配，提升用户体验。减少系统被杀掉的风险。  </p>
<p>多进程还能带来一个好处就是，单一进程崩溃并不影响整体应用的使用。例如我在图片浏览进程打开了一个过大的图片，java heap 申请内存失败，但是不影响我主进程的使用，而且，还能通过监控进程，将这个错误上报给系统，告知他在什么机型、环境下、产生了什么样的Bug，提升用户体验。  </p>
<p>再一个好处就是，当我们的应用开发越来越大，模块越来越多，团队规模也越来越大，协作开发也是个很麻烦的事情。项目解耦，模块化，是这阶段的目标。通过模块解耦，开辟新的进程，独立的JVM，来达到数据解耦目的。模块之间互不干预，团队并行开发，责任分工也明确。至于模块化开发与多进程的结合，后续会写一篇专门的文章来研究这个问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于多进程的使用场景今天大概先说这么多。使用多进程开发还是有很多好处的，不过也有不少坑，下一篇文章我就想总结一下<a href="http://blog.spinytech.com/2016/11/20/android_multiple_process_notice/" target="_blank" rel="external">《多进程开发注意事项》</a>。 </p>
<p>最后，多进程不一定适合所有的应用，合理利用分配进程，使程序更加稳定，才是我们追求的目标。  </p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#115;&#x70;&#x69;&#x6e;&#121;&#x2e;&#x74;&#x65;&#x63;&#x68;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#115;&#x70;&#x69;&#x6e;&#121;&#x2e;&#x74;&#x65;&#x63;&#x68;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a></p>
<p>本文相关源码地址：<a href="https://github.com/SpinyTech/MultipleProcess" target="_blank" rel="external">MultipleProcess</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://spinytech.github.io/2016/11/17/android_multiple_process_usage_scenario/" data-id="civtbb1tc000fgpfyllci9obi" class="article-share-link">分享到</a><div class="tags"><a href="/tags/多进程/">多进程</a><a href="/tags/架构思考/">架构思考</a></div><div class="post-nav"><a href="/2016/11/20/android_multiple_process_notice/" class="pre">Android多进程注意事项</a><a href="/2016/11/15/android_multiple_process/" class="next">Android多进程介绍</a></div><div data-thread-key="2016/11/17/android_multiple_process_usage_scenario/" data-title="Android多进程使用场景" data-url="http://spinytech.github.io/2016/11/17/android_multiple_process_usage_scenario/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/11/17/android_multiple_process_usage_scenario/" data-title="Android多进程使用场景" data-url="http://spinytech.github.io/2016/11/17/android_multiple_process_usage_scenario/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://spinytech.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/多进程/" style="font-size: 15px;">多进程</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Dagger2/" style="font-size: 15px;">Dagger2</a> <a href="/tags/架构思考/" style="font-size: 15px;">架构思考</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/android_multiple_process_notice/">Android多进程注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/android_multiple_process_usage_scenario/">Android多进程使用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/android_multiple_process/">Android多进程介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/25/2016-07-25/">【译】如何恰当的在闪屏页加载繁重的数据和库</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developer" target="_blank">Android Developer</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Spiny.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'SpinyTech'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>