<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android 视图及View绘制分析笔记之setContentView | Spiny</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android 视图及View绘制分析笔记之setContentView</h1><a id="logo" href="/.">Spiny</a><p class="description">Stay Hungry, Stay Foolish, Stay Uncomfortable.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android 视图及View绘制分析笔记之setContentView</h1><div class="post-meta">Dec 2, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/12/02/android_view_draw_setcontentview/" href="/2016/12/02/android_view_draw_setcontentview/#comments" class="ds-thread-count"></a><div class="post-content"><p>自从1983年第一台图形用户界面的个人电脑问世以来，几乎所有的PC操作系统都支持可视化操作，Android也不例外。对于所有Android Developer来说，我们接触最多的控件就是View。通常，我们使用自定义View，需要了解最多的除了事件分发，就是View的绘制过程。然而关于View的绘制，涉及到的知识点纷繁复杂，这么多的代码知识，要梳理起来，肯定是先要找个头。那么平常我们用的最多的方法是哪个方法呢？当然是<code>setContentView()</code>！</p>
<h1 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h1><p>首先我们直接在Android Studio中找到一个Activity（请注意，本文分析的是Activity，如果你看的是AppCompatActivity，实际代码会有出入），然后找到setContent方法然后点进去，我们可以看到  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后查找<code>getWindow()</code>方法  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    private Window mWindow;</span><br><span class="line">    public Window getWindow() &#123;</span><br><span class="line">        return mWindow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">得知调用的是Window类的setContent()方法。然后再全类搜索mWindow，在attach方法中找到了赋值语句。</span><br></pre></td></tr></table></figure>
<pre><code>final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window) {
    ···
    mWindow = new PhoneWindow(this, window);
    mWindow.setWindowControllerCallback(this);
    mWindow.setCallback(this);
    mWindow.setOnWindowDismissedCallback(this);
    mWindow.getLayoutInflater().setPrivateFactory(this);
    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
        mWindow.setSoftInputMode(info.softInputMode);
    }
    if (info.uiOptions != 0) {
        mWindow.setUiOptions(info.uiOptions);
    }
    ···
    mWindow.setWindowManager(
            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
            mToken, mComponent.flattenToString(),
            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
    if (mParent != null) {
        mWindow.setContainer(mParent.getWindow());
    }
    mWindowManager = mWindow.getWindowManager();
    ···
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后就引出了我们今天主要分析的对象PhoneWindow。  </span><br><span class="line"># PhoneWindow</span><br><span class="line">查找PhoneWindow的setContentView方法，可以看到有三个重载方法。</span><br></pre></td></tr></table></figure>
<pre><code>@Override
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
        transitionTo(newScene);
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    mContentParent.requestApplyInsets();
    final Callback cb = getCallback();
    if (cb != null &amp;&amp; !isDestroyed()) {
        cb.onContentChanged();
    }
    mContentParentExplicitlySet = true;
}

@Override
public void setContentView(View view) {
    setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
}

@Override
public void setContentView(View view, ViewGroup.LayoutParams params) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        view.setLayoutParams(params);
        final Scene newScene = new Scene(mContentParent, view);
        transitionTo(newScene);
    } else {
        mContentParent.addView(view, params);
    }
    mContentParent.requestApplyInsets();
    final Callback cb = getCallback();
    if (cb != null &amp;&amp; !isDestroyed()) {
        cb.onContentChanged();
    }
    mContentParentExplicitlySet = true;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">三个方法大体的处理流程是：  </span><br><span class="line">1. 初始化DecorView  </span><br><span class="line">2. 检查并处理转场动画  </span><br><span class="line">3. 将实际要显示的Layout或者View添加到mContentParent中  </span><br><span class="line">4. 通知Callback(即Activity)调用onContentChanged方法  </span><br><span class="line"></span><br><span class="line"># DecorView</span><br><span class="line">在上面的流程里面，相对比较重要的就是第一步的初始化DecorView，也就是`installDecor()`方法，下面我们继续分析这个方法。</span><br></pre></td></tr></table></figure>
<pre><code>private void installDecor() {
    ···
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        ···
        }
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        ···
    }
    ···
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在`installDecor()`方法里，主要做的就是两件事，一个是generateDecor，生成mDecor，还有一个是generateLayout，生成mContentParent。generateDecor中，没有太多复杂逻辑，就是做一些判断，然后实例化出来一个DecorView，这里需要说一点的就是在Android7.0以前，DecorView是PhoneWindow的内部类，7.0以后，DecorView单独提出来变成了一个类，所以如果有用到反射的话，这里可能会出现问题，需要做好版本判断。然后我们看下generateLayout的逻辑：</span><br></pre></td></tr></table></figure>
<pre><code>protected ViewGroup generateLayout(DecorView decor) {
    //通过系统获取样式
    TypedArray a = getWindowStyle();
    //然后一系列的判断，获取样式里的属性，然后设置features
    //例如是否悬浮，是否有Title等等
    ···
    int layoutResource;
    int features = getLocalFeatures();
    //拿到刚才设置的features，作出一系列if eles判断，找出对应的resourceId
    //然后调用DecorView的onResourcesLoaded，对这个layout进行inflate
    ···
    mDecor.startChanging();
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);

    //通过com.android.internal.R.id.content找到对应的mContentParent
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    if (contentParent == null) {
        throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);
    }
    //在经过一系列后续设置
    ···
    mDecor.finishChanging();
    //最后返回contentParent
    return contentParent;
}
</code></pre><p>```</p>
<p>在generateLayout中，大概的流程是这样的。  </p>
<ol>
<li>先获取样式  </li>
<li>设置样式到Window的features里  </li>
<li>拿到features，判断对应的resourceId  </li>
<li>通过resourceId，inflate出来一个ViewGroup，添加到mDecor中</li>
<li>再通过findViewById，找到刚刚inflate的ViewGroup中的  com.android.internal.R.id.content，作为mContentParent</li>
<li>在经过一系列设置  </li>
<li>返回contentParent  </li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此，我们的setContentView就已经基本走完了，剩下的就等着Activity、WindowManager、WindowManagerGlobal、ViewRootImpl去调用了，这些类的调用，涉及到了Activity的启动流程，我们会在其他笔记中详细分析这一过程。  </p>
<p>下面会上一张整个setContentView的时序图，用来巩固一下刚才的流程。  </p>
<p><img src="" alt="上图为Android setContentView的时序图"></p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x73;&#112;&#105;&#x6e;&#x79;&#46;&#116;&#101;&#99;&#x68;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;">&#x73;&#112;&#105;&#x6e;&#x79;&#46;&#116;&#101;&#99;&#x68;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://spinytech.github.io/2016/12/02/android_view_draw_setcontentview/" data-id="ciwdgbb3k0012o7fyckhb2v0x" class="article-share-link">分享到</a><div class="tags"><a href="/tags/View绘制/">View绘制</a><a href="/tags/Android视图/">Android视图</a></div><div class="post-nav"><a href="/2016/11/20/android_multiple_process_notice/" class="next">Android多进程注意事项</a></div><div data-thread-key="2016/12/02/android_view_draw_setcontentview/" data-title="Android 视图及View绘制分析笔记之setContentView" data-url="http://spinytech.github.io/2016/12/02/android_view_draw_setcontentview/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/12/02/android_view_draw_setcontentview/" data-title="Android 视图及View绘制分析笔记之setContentView" data-url="http://spinytech.github.io/2016/12/02/android_view_draw_setcontentview/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://spinytech.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/架构思考/" style="font-size: 15px;">架构思考</a> <a href="/tags/多进程/" style="font-size: 15px;">多进程</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Dagger2/" style="font-size: 15px;">Dagger2</a> <a href="/tags/View绘制/" style="font-size: 15px;">View绘制</a> <a href="/tags/Android视图/" style="font-size: 15px;">Android视图</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/android_view_draw_setcontentview/">Android 视图及View绘制分析笔记之setContentView</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/android_multiple_process_notice/">Android多进程注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/android_multiple_process_usage_scenario/">Android多进程使用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/android_multiple_process/">Android多进程介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/25/2016-07-25/">【译】如何恰当的在闪屏页加载繁重的数据和库</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://developer.android.com/index.html" title="Android Developer" target="_blank">Android Developer</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Spiny.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'SpinyTech'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>