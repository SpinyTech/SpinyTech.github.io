<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android架构思考(模块化、多进程) | Spiny</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android架构思考(模块化、多进程)</h1><a id="logo" href="/.">Spiny</a><p class="description">Stay Hungry, Stay Foolish, Stay Uncomfortable.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android架构思考(模块化、多进程)</h1><div class="post-meta">Dec 28, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/12/28/android_modularization/" href="/2016/12/28/android_modularization/#comments" class="ds-thread-count"></a><div class="post-content"><p>关于<strong>模块化(组件化)</strong>这个问题，我想每个开发者可能都认真的思考过。随着项目的开发，<strong>业务不断壮大，业务模块越来越多，各个模块间相互引用，耦合越来越严重</strong>，同时有些项目（比如我们公司）还伴随着子应用单独包装推广，影子应用单独发布等等需求，重新调整架构迫在眉睫。今天，我们就来聊聊模块化(组件化)，这篇文章同时也是我这几年，对项目架构的理解。</p>
<h2 id="最初的超小型项目"><a href="#最初的超小型项目" class="headerlink" title="最初的超小型项目"></a>最初的超小型项目</h2><p>当我们最开始做Android项目的时候，大多数人都是没考虑项目架构的，我们先上一张图。<br><img src="http://ogsbxb571.bkt.clouddn.com/old_architecture1.jpg" alt="2012年开发的一个小项目"></p>
<p>这个分包结构有没有很熟悉，各种组件都码在一个包里，完全没有层级结构，<strong>业务、界面、<br>逻辑都耦合在一起</strong>。这是我12年底刚开始入门Android的时候开发的一个小项目，半年后，来了个小伙伴，然后我们一起开发，然后天天因为谁修改了谁的代码<strong>打的不可开交</strong>。  </p>
<h2 id="架构改进，小型项目"><a href="#架构改进，小型项目" class="headerlink" title="架构改进，小型项目"></a>架构改进，小型项目</h2><p>再后来开发App，人员比之前多了，所以不能按照以前那样了，必须得重构。于是我把公用的代码提取出来制作成<strong>SDK基础库</strong>，把单独的功能封装成<strong>Library包</strong>，不同业务通过分包结构分到不同<strong>module</strong>下，组内每人开发自己的module。刚开始都还轻松加愉快，并行开发啥的，一片融洽的场景，如下图。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E6%97%A9%E6%9C%9F%E6%9E%B6%E6%9E%84-1.png" alt="刚刚重构之后的架构"></p>
<p>随着时间推移，我们的App迭代了几个版本，这几个版本也没什么别的，大体来讲就是三件事情：</p>
<ul>
<li>扩展了一些新业务模块，同时模块间相互调用也增加了。  </li>
<li>修改增加了一些新的库文件，来支持新的业务模块。  </li>
<li>对Common SDK进行了扩展、修复。  </li>
</ul>
<p><del>很惭愧，就做了一些微小的工作</del>，但是架构就变成下图这样。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E6%97%A9%E6%9C%9F%E6%9E%B6%E6%9E%84-2.png" alt="做了几件微小的工作之后"></p>
<p>可以看到，随着几个版本业务的增加，各个业务某块之间耦合愈发严重，导致代码很难维护，更新，更别说写测试代码了。虽然后期引入统一广播系统，一定程度改善了模块间相互引用的问题，但是局限性和耦合性还是很高，没办法根治这个问题。这个架构做到最后，<strong>扩展性和可维护性都是很差</strong>，并且<strong>难以测试</strong>，所以最终被历史的进程所抛弃。</p>
<h2 id="中小型项目，路由架构"><a href="#中小型项目，路由架构" class="headerlink" title="中小型项目，路由架构"></a>中小型项目，路由架构</h2><p>时间很快就来到了2015年，这一年动态加载、热修复很火，360、阿里等大公司先后开源了自己的解决方案，如droidplugin、andfix等。在研究了一圈发现，这些技术对架构升级有一定的帮助，尤其是droidplugin的加载apk的思想，能很好地解决耦合度高、方法数超过65535、动态修复bug等问题，不过由于项目本身不是很大，并且没有专门的人来维护架构，所以最后放弃了功能强大、但是问题也同样多的<strong>插件化</strong>，退而求其次，选择了利用<strong>路由机制</strong>来实现<strong>组件化</strong>解耦。  </p>
<p>关于路由机制，熟悉iOS开发的朋友可能并不陌生，在iOS上有很多架构方案都是采用路由机制来时间模块之间的解耦的，比如<strong>VIPER（View Interactor Presenter Entity Routing）</strong>思想等等。其实思路都是相同的，Android上面组件化也是通过<strong>公用的路由</strong>，来实现模块与模块之间的隔离。  </p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>我们先来看下路由架构图。  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-1.png" alt="路由架构">  </p>
<p><a href="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-1.png" target="_blank" rel="external">大图点我</a>  </p>
<p>通过上图可以看到，我们在最基础的Common库中，创建了一个路由<code>Router</code>，中间有n个模块<code>Module</code>，这个<code>Module</code>实际上就是Android Studio中的module，这些<code>Module</code>都是<strong>Android Library Module</strong>，最上面的Module Main是<strong>可运行的Android  Application Module</strong>。  </p>
<p><strong>这几个<code>Module</code>都引用了Common库，同时Main Module还引用了A、B、N这几个<code>Module</code></strong>，经过这样的处理之后，<strong>所有的<code>Module</code>之间的相互调用就都消失了，耦合性降低，所有的通信统一都交给Router来处理分发，而注册工作则交由Main Module去进行初始化</strong>。这个架构思想其实和Binder的思想很类似，采用C/S模式，模块之间隔离，数据通过共享区域进行传递。模块与模块之间只暴露对外开放的Action，所以也具备<strong>面向接口编程思想</strong>。  </p>
<p>图中的红色矩形代表的是行动<code>Action</code>，<code>Action</code>是具体的执行类，其内部的<strong>invoke方法是具体执行的代码逻辑</strong>。如果涉及到<strong>并发操作</strong>的话，可以在<strong>invoke方法内加入锁，或者直接在invoke方法上加上synchronized描述</strong>。  </p>
<p>图中的黄色矩形代表的是供应商<code>Provider</code>，每个<code>Provider</code>中包含1个或多个<code>Action</code>，其内部的数据结构以<strong>HashMap</strong>来存储Action。<strong>首先HashMap查询的时间复杂度是O(1)，符合我们对调用速度上的要求，其次，由于我们是统一进行注册，所以在写入时并不存在并发线程并发问题，在读取时，并发问题则交由Action的invoke去具体处理。</strong>在每一个<code>Module</code>内都会有1个或多个供应商<code>Provider</code>（如果不包含<code>Provider</code>，那么这个<code>Module</code>将无法为其他<code>Module</code>提供服务）。</p>
<p>途中蓝色巨星代表的是路由<code>Router</code>，每个<code>Router</code>中包含多个<code>Provider</code>，其内部的数据结构也是以<strong>HashMap</strong>来存储<code>Provider</code>，原理也和<code>Provider</code>是一样的。之所以用了两次HashMap，有两点原因，一个是因为这样做，<strong>不容易导致<code>Action</code>的重名</strong>，另一个是因为在注册的时候，只注册<code>Provider</code>会<strong>减少注册代码，更易读</strong>。并且由于HashMap的查询时间复杂度是O(1)，所以两次查找不会浪费太多时间。当查找不到对应<code>Action</code>的时候，Router会生成一个<code>ErrorAction</code>，会告之调用者没有找到对应的<code>Action</code>，由调用者来决定接下来如何处理。  </p>
<h3 id="一次请求流程"><a href="#一次请求流程" class="headerlink" title="一次请求流程"></a>一次请求流程</h3><p>通过Router调用的具体流程是这样的:  </p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/Router%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Router时序图"></p>
<ol>
<li>任意代码创建一个<code>RouterRequest</code>，包含<code>Provider</code>和<code>Action</code>信息，向<code>Router</code>进行请求。  </li>
<li><code>Router</code>接到请求，通过<code>RouterRequest</code>的<code>Provider</code>信息，在内部的HashMap中查找对应的<code>Provider</code>。  </li>
<li><code>Provider</code>接到请求，在内部的HashMap中查找到对应的<code>Action</code>信息。  </li>
<li><code>Action</code>调用invoke方法。    </li>
<li>返回invoke方法生成的<code>ActionResult</code>。    </li>
<li>将<code>Result</code>封装成<code>RouterResponse</code>，返回给调用者。  </li>
</ol>
<h3 id="耦合降低"><a href="#耦合降低" class="headerlink" title="耦合降低"></a>耦合降低</h3><p>所有的<code>Module</code>之间的相互依赖没有了，我们可以在主app中，取消任意的<code>Module</code>引用而不影响整体App的编译及运行。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-2.png" alt="取消对Module N的依赖"></p>
<p>如图所示，我们取消了对<code>Module N</code>的依赖，整体应用依然可以稳定运行，遇到调用<code>Module N</code>的地方，会返回Not Found提示，实际开发中可以根据需求做具体的处理。</p>
<h3 id="可测试性增强"><a href="#可测试性增强" class="headerlink" title="可测试性增强"></a>可测试性增强</h3><p>由于每个<code>Module</code>并不依赖其他的<code>Module</code>，所以在开发过程中，我们只针对自己的模块进行开发，并可以建一个测试App来进行白盒测试。</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E8%B7%AF%E7%94%B1-3.png" alt="测试Module A"></p>
<h3 id="复用性增强"><a href="#复用性增强" class="headerlink" title="复用性增强"></a>复用性增强</h3><p>关于复用性这块。作者所处的行业是招商投资这块，这个行业需要围绕主业务开发很多影子APP，将覆盖面扩大（有点类似58-&gt;58租房、58招聘，美团-&gt;美团外卖等）。这个时候，这个架构的复用性就体现出来了，我们可以把业务进行拆分，然后写一个包装App，就可以生成一个独立的影子APP，这个影子APP用到哪些<code>Module</code>就引用哪些就可以了，开发迅速，并且后期<code>Module</code>业务有变化，也不用更改所有的代码，减少了代码的复制。比如我们就曾经把IM模块和投资咨询模块单独拿出来，写了一些界面和样式，就生成了“招商经纪人”App。</p>
<h3 id="支持并行开发"><a href="#支持并行开发" class="headerlink" title="支持并行开发"></a>支持并行开发</h3><p>整套架构符合Git的Branch思想，每个<code>Module</code>有专门的Branch进行开发，在进行集成测试的时候再去与主分支进行合并。每个<code>Module</code>都有自己单独的版本控制，便于管理及问题溯源。</p>
<h2 id="多进程思考，中型项目"><a href="#多进程思考，中型项目" class="headerlink" title="多进程思考，中型项目"></a>多进程思考，中型项目</h2><p>随着项目的不断扩大，App在运行时的内存消耗也在不断增加，而且有时线上的BUG也会导致整体崩溃。为了保证良好的用户体验，减少对系统资源的消耗，我们开始考虑采取多进程重新架构程序，通过按需加载，及时释放，达到优化的目的。  </p>
<h3 id="多进程优势"><a href="#多进程优势" class="headerlink" title="多进程优势"></a>多进程优势</h3><p>多进程的优点和使用场景，之前在<a href="http://blog.spinytech.com/2016/11/17/android_multiple_process_usage_scenario/">《Android多进程使用场景》</a>中也做过介绍，大体优点有这么几个：</p>
<ul>
<li>提高各个进程的稳定性，单一进程崩溃后不影响整个程序。  </li>
<li>对于内存的时候更可控，可以通过手工释放进程，达到内存优化目的。  </li>
<li>基于独立的JVM，各个模块可以充分解耦。  </li>
<li>只保留daemon进程的情况下，会使应用存活时间更长，不容易被回收掉。  </li>
</ul>
<h3 id="潜在问题"><a href="#潜在问题" class="headerlink" title="潜在问题"></a>潜在问题</h3><p>但是启用多线程，那就意味着Router系统的失效。<strong>Router是JVM级别的单例模式，并不支持跨进程访问</strong>。也就是说，你的后台进程的所有<code>Provider</code>、<code>Action</code>，是注册给后台Router的。当你在前台进程调用的时候，根本调用不到其他进程的<code>Action</code>。  </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实解决的方法也并不复杂。原来的路由系统还可以继续使用，我们可以<strong>把整套架构想象成互联网</strong>，现在多个进程有多个路由，我们只需要把多个路由连接到一起，那么整个路由系统还是可以正常运行的。所以我们把原有的路由<code>Router</code>称之为本地路由<code>LocalRouter</code>，现在，我们需要提供一个IPS、DNS供应商，那就创建一个进程，该进程的作用就是注册路由，链接路由，转发报文，我们称之为广域路由<code>WideRouter</code>。  </p>
<p>我们先来看下路由连接架构图</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B7%AF%E7%94%B1%E8%BF%9E%E6%8E%A5%E5%9B%BE.png" alt="路由连接架构"></p>
<p><a href="http://ogsbxb571.bkt.clouddn.com/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%B7%AF%E7%94%B1%E8%BF%9E%E6%8E%A5%E5%9B%BE.png" target="_blank" rel="external">点击大图</a></p>
<p>如图所示，竖直方向上，每一列，代表一个进程，通过虚线隔开，分别有Process WideRouter、Process Main、Process A、···、Process N这些进程。浅黄色的代表<code>WideRouter</code>，深黄色的代表<code>WideRouter</code>的守护Service。浅蓝色的代表每个进程的<code>LocalRouter</code>，深蓝色的代表每个<code>LocalRouter</code>的守护Service。<code>WideRouter</code>通过AIDL与每个进程<code>LocalRouter</code>的守护Service绑定到一起，每个<code>LocalRouter</code>也是通过AIDL与<code>WideRouter</code>的守护Service绑定到一起，这样，就达到了所有路由都是双向互连的目的。</p>
<h3 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h3><p>之前单一路由的事件分发是通过两层HashMap查找<code>Provider</code>和<code>Action</code>，进行事件下发。那么现在在外面加了一层<code>WideRouter</code>，那么我们再加一层<code>Domain</code>，<strong><code>Domain</code>对应的是Android应用内，各个进程的进程名</strong>。通常情况下，如果事件是在同一进程下，那么就类似于局域网内部事件传递，不需要通过<code>WideRouter</code>，直接内部按照之前的路由逻辑进行转发，如果不在相同进程内，就由<code>WideRouter</code>进行进程间通信，达到跨进程调用的效果。  </p>
<p>事件请求<code>RouterRequest</code>可以写成两种，<strong>一种是URL，一种JSON</strong>。（内部处理的时候统一使用JSON），同时也提供了对URL和JSON的解析方法，方便使用。  </p>
<p>URL:xxxDomain/xxxProvider/xxxAction?data1=xxx&amp;data2=xxx<br>这就和Http请求很像了。这样做的好处就是对后续WebView上可以非常便利得直接调用本地<code>Action</code>。</p>
<p>JSON:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    domain: xxx,</span><br><span class="line">    provider: xxx,</span><br><span class="line">    action: xxx,</span><br><span class="line">    data&#123;</span><br><span class="line">        data1: xxx,</span><br><span class="line">        data2: xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON方式简单明了，可作为接口返回值由服务器下发给客户端。  </p>
<p>下面仔细讲一下一次跨进程请求，事件是如何传递的：</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E5%B9%BF%E5%9F%9F%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="事件传递图"></p>
<p><a href="http://ogsbxb571.bkt.clouddn.com/%E5%B9%BF%E5%9F%9F%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%97%B6%E5%BA%8F%E5%9B%BE.png" target="_blank" rel="external">点击大图</a>  </p>
<p>从图中可以清晰地看出，我们主要是分两大部分去完成事件分发传递的。</p>
<ul>
<li>第一部分，跨进程判断目标<code>Action</code>是否是异步程序。</li>
<li>第二部分，跨进程执行目标<code>Action</code>调用。</li>
</ul>
<p>首先我们先通过<code>Domain</code>、<code>Provider</code>、<code>Action</code>去跨进程查找是否是异步程序。如果是异步程序，那么我们直接生成RouterResponse(Step13)，并且，将Step14-Step24统一封装成Future，放在RouterResponse中，直接返回。如果是同步程序，那么就在当前方法内执行Step14-Step24，将返回结果放入RouterResponse内(Step25)，直接返回。这么做的目的是，我们的路由调用方法<code>route(RouterRequest)</code>默认是同步方法，不耗时的，可以直接在主线程里调用而不造成阻塞，不造成ANR。如果调用的目标<code>Action</code>是异步的，那么可以利用Java的FutureTask原理，调用<code>RouterResponse</code>的<code>get()</code>方法，获取结果。这个<code>get()</code>方法有可能是耗时的，是否耗时，取决于<code>RouterResponse.isAsync</code>的值是否是<code>true</code>。</p>
<p>至于本地事件分发，还是与之前的Router模式，从Step17到Step21，都是我们上文中，单进程同步Router分发机制，没有作任何改变。  </p>
<h3 id="多进程Application逻辑分发"><a href="#多进程Application逻辑分发" class="headerlink" title="多进程Application逻辑分发"></a>多进程Application逻辑分发</h3><p>在多进程中，每启动一个新的进程，都会重新创建一次Application，所以，我们需要把各个进程的Application逻辑剥离出来，然后根据不同的<code>Process Name</code>，选择不同的Application逻辑进行处理。  </p>
<p>实际的Application启动流程如下：</p>
<p><img src="http://ogsbxb571.bkt.clouddn.com/%E5%A4%9A%E8%BF%9B%E7%A8%8BApplication%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="多进程Application启动流程"></p>
<p>首先，我们先把所有<code>ApplicationLogic</code>注册到Application中，然后，Application会根据注册时的进程名信息进行筛选，选择相同进程名的<code>ApplicationLogic</code>，保存到本进程中，然后，对这些本进程的<code>ApplicationLogic</code>进行实例化，最后，调用<code>ApplicationLogic</code>的<code>onCreate</code>方法，实现<code>ApplicationLogic</code>与<code>Application</code>生命周期同步，同时还有<code>onTerminate</code>、<code>onLowMemory</code>、<code>onTrimMemory</code>、<code>onConfigurationChanged</code>等方法，与<code>onCreate</code>一致。</p>
<h3 id="结束进程，释放内存"><a href="#结束进程，释放内存" class="headerlink" title="结束进程，释放内存"></a>结束进程，释放内存</h3><p>在我们不使用某些进程的时候，比如听音乐的时候，可以把主界面关掉等等。我们可以调用对应进程的<code>LocalRouter</code>的<code>stopSelf()</code>方法，该方法可以使本进程与<code>WideRouter</code>进行解绑，然后我们在手动关掉进程内的其他组件，最后调用<code>System.exit()</code>，达到释放内存的目的。合理的释放内存，能有效的改善用户体验。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章大概讲了一下作者这几年对Android架构的理解。其实本文中没有什么很深的技术点，大多是一些设计模式，架构思想。这套框比起大公司的一些优秀的动态更新、编译分包、apk插件化加载，还是简单很多的，更适合中小型应用。</p>
<p>这套框架目前还有比较多可以改进的地方，目前正在整理的：</p>
<ul>
<li>增加对<code>Action</code>的动态关闭功能。</li>
<li>通过<code>Instant Run</code>原理，实现<code>Action</code>的热更新。</li>
<li>增加<code>Message Pool</code>，实现<code>Request</code>、<code>Response</code>的循环利用，减少GC触发。<br>已解决<a href="http://blog.spinytech.com/2017/01/10/concurrent_object_pool/">《高并发对象池思考》</a></li>
<li>优化<code>Message</code>在传递过程中的打包，拆包的速度，提升整体性能。</li>
<li>etc.</li>
</ul>
<p>本文项目地址：<a href="https://github.com/SpinyTech/ModularizationArchitecture" target="_blank" rel="external">ModularizationArchitecture</a>，欢迎大家star、fork、提建议。</p>
<p>或者直接在项目中引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.spinytech.ma:macore:0.1.2&apos;</span><br></pre></td></tr></table></figure>
<p>相关教程：<a href="http://blog.spinytech.com/2017/02/01/ma_get_start_cn/">ModularizationArchitecture 使用教程</a></p>
<p>如果有疑问或者建议，欢迎联系我，邮箱是：<a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#115;&#x70;&#x69;&#x6e;&#121;&#46;&#x74;&#101;&#99;&#x68;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#115;&#x70;&#x69;&#x6e;&#121;&#46;&#x74;&#101;&#99;&#x68;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a><br>谢谢大家阅读</p>
<hr>
<p>原创文章，转载请先联系作者：<a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#115;&#x70;&#x69;&#x6e;&#x79;&#x2e;&#x74;&#101;&#x63;&#x68;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#115;&#x70;&#x69;&#x6e;&#x79;&#x2e;&#x74;&#101;&#x63;&#x68;&#64;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://blog.spinytech.com/2016/12/28/android_modularization/" data-id="ciyuat0sl0003tu014db8iqr5" class="article-share-link">分享到</a><div class="tags"><a href="/tags/架构思考/">架构思考</a><a href="/tags/模块化/">模块化</a><a href="/tags/多进程/">多进程</a></div><div class="post-nav"><a href="/2017/01/10/concurrent_object_pool/" class="pre">高并发对象池思考</a><a href="/2016/12/19/android_view_on_draw/" class="next">View绘制分析笔记之onDraw</a></div><div data-thread-key="2016/12/28/android_modularization/" data-title="Android架构思考(模块化、多进程)" data-url="http://blog.spinytech.com/2016/12/28/android_modularization/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/12/28/android_modularization/" data-title="Android架构思考(模块化、多进程)" data-url="http://blog.spinytech.com/2016/12/28/android_modularization/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://blog.spinytech.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/Dagger2/" style="font-size: 15px;">Dagger2</a> <a href="/tags/架构思考/" style="font-size: 15px;">架构思考</a> <a href="/tags/模块化/" style="font-size: 15px;">模块化</a> <a href="/tags/多进程/" style="font-size: 15px;">多进程</a> <a href="/tags/View绘制/" style="font-size: 15px;">View绘制</a> <a href="/tags/Android视图/" style="font-size: 15px;">Android视图</a> <a href="/tags/高并发/" style="font-size: 15px;">高并发</a> <a href="/tags/对象池/" style="font-size: 15px;">对象池</a> <a href="/tags/ModularizationArchitecture/" style="font-size: 15px;">ModularizationArchitecture</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Architecture/" style="font-size: 15px;">Architecture</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/ma_get_start_en/">The guide of the ModularizationArchitecture</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/01/ma_get_start_cn/">ModularizationArchitecture 使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/10/concurrent_object_pool/">高并发对象池思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/28/android_modularization/">Android架构思考(模块化、多进程)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/19/android_view_on_draw/">View绘制分析笔记之onDraw</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/15/android_view_on_layout/">View绘制分析笔记之onLayout</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/12/android_view_on_measure/">View绘制分析笔记之onMeasure</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/android_view_draw_setcontentview/">Android 视图及View绘制分析笔记之setContentView</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/20/android_multiple_process_notice/">Android多进程注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/17/android_multiple_process_usage_scenario/">Android多进程使用场景</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Spiny.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'SpinyTech'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>